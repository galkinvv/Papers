%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english,russian]{article}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{geometry}
\geometry{verbose}
\setcounter{secnumdepth}{-1}
\usepackage{color}
#ifndef VESTNIK
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}
\AtBeginDocument{\DeclareFontEncoding{T2A}{}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\newcommand{\lyxaddress}[1]{
\par {\raggedright #1
\vspace{1.4em}
\noindent\par}
}
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
  \theoremstyle{definition}
  \newtheorem{defn}[thm]{\protect\definitionname}
  \theoremstyle{plain}
  \newtheorem{lem}[thm]{\protect\lemmaname}
  \theoremstyle{plain}
  \newtheorem{cor}[thm]{\protect\corollaryname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
#endif
\usepackage{babel}
\newcommand{\Sig}{\mathcal{S}}
\newcommand{\HM}{\mathrm{HM}}
\newcommand{\totaldeg}{\mathrm{deg}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\sigidx}{\mathrm{index}}

#ifdef VESTNIK
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{allerree}

\def\wdeb{0}

\newcounter{countergvtheorems}

\newenvironment{proofwithpar}
{\par{\bf Доказательство.}}
{ $\square$\par}

\newenvironment{fact}
{\refstepcounter{countergvtheorems}\begin{theorem}{Факт \arabic{countergvtheorems}.}}
{\end{theorem}}

\newenvironment{claim}
{\refstepcounter{countergvtheorems}\begin{theorem}{Утверждение \arabic{countergvtheorems}.}}
{\end{theorem}}

\newenvironment{lem}
{\refstepcounter{countergvtheorems}\begin{theorem}{Лемма  \arabic{countergvtheorems}.}}
{\end{theorem}}

\newenvironment{thm}
{\refstepcounter{countergvtheorems}\begin{theorem}{Теорема \arabic{countergvtheorems}.}}
{\end{theorem}}

\newenvironment{cor}
{\refstepcounter{countergvtheorems}\begin{theorem}{Следствие \arabic{countergvtheorems}.}}
{\end{theorem}}


\newenvironment{defn}
{\par \refstepcounter{countergvtheorems} {\bf Определение \arabic{countergvtheorems}.}}
{\par}

\newenvironment{example}
{\par \refstepcounter{countergvtheorems} {\bf Пример \arabic{countergvtheorems}.}}
{\par}

#else
\newcommand{\iabstract}[4]{
\begin{abstract}
#3
\footnote{\emph{Keywords:} #4}
\end{abstract}
}

\makeatother

  \addto\captionsenglish{\renewcommand{\corollaryname}{\inputencoding{latin9}Corollary}}
  \addto\captionsenglish{\renewcommand{\definitionname}{\inputencoding{latin9}Definition}}
  \addto\captionsenglish{\renewcommand{\lemmaname}{\inputencoding{latin9}Lemma}}
  \addto\captionsenglish{\renewcommand{\theoremname}{\inputencoding{latin9}Theorem}}
  \addto\captionsrussian{\renewcommand{\corollaryname}{\inputencoding{koi8-r}чЩЧПД}}
  \addto\captionsrussian{\renewcommand{\definitionname}{\inputencoding{koi8-r}пРТЕДЕМЕОЙЕ}}
  \addto\captionsrussian{\renewcommand{\lemmaname}{\inputencoding{koi8-r}мЕННБ}}
  \addto\captionsrussian{\renewcommand{\theoremname}{\inputencoding{koi8-r}фЕПТЕНБ}}
  \providecommand{\corollaryname}{\inputencoding{koi8-r}чЩЧПД}
  \providecommand{\definitionname}{\inputencoding{koi8-r}пРТЕДЕМЕОЙЕ}
  \providecommand{\lemmaname}{\inputencoding{koi8-r}мЕННБ}
\providecommand{\theoremname}{\inputencoding{koi8-r}фЕПТЕНБ}

\begin{document}
#endif 
#ifdef VESTNIK
\begin{document}
\cleanbegin 
\def\udk{512}
\ltitle{ОСТАНОВКА АЛГОРИТМА F5} {В.\,В.~Галкин\footnote[1]{{\it Галкин Василий Витальевич} --- асп. каф. алгебры мех.-мат. ф-та МГУ, e-mail: galkin-vv@yandex.ru.}}
\iabstract
{Алгоритм F5, предложенный Фожером, принимает в качестве входных данных произвольное множество однородных многочленов. Его корректность доказана при условии остановки алгоритма. Однако остановка алгоритма за конечное число шагов доказана лишь для случая, когда на вход алгоритма подаётся регулярная последовательность многочленов. В этой работе показано, что алгоритм останавливается на любых входных данных без какого-либо использования регулярности.}
{базис Грёбнера, алгоритм F5, доказательство остановки}
{The original F5 algorithm introduced by Faug{\`e}re is formulated for any homogeneous polynomial set input. The correctness of output is shown for any input that terminates the algorithm, but the termination itself is proved only for the case of input being regular polynomial sequence. This article shows that algorithm correctly terminates for any homogeneous input without any reference to regularity.} {Groebner basis, F5 algorithm, termination proof}
#else



\title{Остановка Алгоритма F5}


\author{Василий Галкин}

\maketitle

\lyxaddress{МГУ}


\lyxaddress{galkin-vv@ya.ru}
\begin{abstract}
Алгоритм F5, предложенный Фожером, принимает в качестве входных данных
произвольное множество однородных многочленов. Его корректность доказана
при условии остановки алгоритма. Однако остановка алгоритма за конечное
число шагов доказана лишь для случая, когда на вход алгоритма подаётся
регулярная последовательность многочленов. В этой работе показано,
что алгоритм останавливается на любых входных данных без какого-либо
использования регулярности. Схема доказательства состоит из двух частей:
в первой части показано, что если алгоритм не останавливается, то
рано или поздно он получит пару многочленов, в которой первый может
редуцировать второй. При этом, однако, не утверждается, что такая
редукция будет разрешена критериями, предложенными в F5. Вторая часть
показывает, что при существовании такой пары также будет существовать
пара в которой редукция разрешена всеми критериями. Существование
такой пары приводит к противоречию.
\end{abstract}
#endif

Алгоритм Фожера F5 является эффективным алгоритмом вычисления базисов
Грёбнера, но обладает рядом проблем, связанных с его обоснованием.
Корректность его работы при условии остановки показана в первоисточнике
\cite{FaugereF5} и в работах \cite{GermanF5Proof_ru,F5InBBStyle,NewF5Proof},
предложивших другие способы её доказательства. Но остановка алгоритма,
как в \cite{FaugereF5}, так и в детальных исследованиях \cite{F5-revisited},
показана только для случая регулярной последовательности на входе.
Один из подходов к решению проблемы -- добавление в алгоритм дополнительных
проверок и критериев, гарантирующих остановку. Это даёт строгое доказательство
остановки для модифицированной версии F5, содержащей дополнительные
проверки, работа которой может отличаться от базовой. Этот подход
применяется в работах \cite{Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG,Hashemi-ExtF5,ZobninGeneralization_ru}.

Другой подход состоит в доказательстве остановки семейства алгоритмов,
основанных на идеях F5, с последующей попыткой переформулировать F5
так, чтобы он являлся представителем этого семейства. Основная проблема
этого подхода появляется в процессе переформулировки: описание F5
в других терминах может привести к неявному внесению различий в поведение
алгоритма. К примеру, \cite{2012GrbTermination} доказывает остановку
алгоритма F5GEN, который отличается от F5 отсутствием проверки критериев
при выборе редуктора. Работа \cite{HuangConception} даёт доказательство
остановки алгоритма TRB-F5, который имеет два отличия от F5. Первое
-- другая схема построения правил, приводящая к тому, что в TRB-F5
правила в массивах $Rule$ оказываются отсортированными по возрастанию
сигнатуры. Второе -- отсутствие применения оператора нормальной формы
$\varphi$ перед редукцией, поэтому TRB-F5 при выборе редуктора проверяет
критерии для элементов, которые в F5 используются неявно в $\varphi$.
Предположительно, эти алгоритмы могут быть изменены таким образом,
чтобы в точности повторять поведение алгоритма F5, а доказательство
остановки может быть перенесено на изменённые версии. Однако подход
с алгоритмами, эквивалентными F5 имеет недостаток: он усложняет понимание
того, как теоремы, используемые для доказательства остановки отражают
поведение исходного алгоритма F5.

Подход к доказательству остановки, предлагаемый в данной работе, применяется
к F5 без каких-либо модификаций. Первый шаг доказательства основан
на предлагаемой ниже идее цепей S-пар. Второй шаг основывается на
методе, использованном в теореме 21 работы \cite{F5C} для доказательства
корректности алгоритма F5C: представление S-многочлена в виде суммы
домноженных многочленов, вычисленных ранее, может быть модифицировано
последовательностью замен S-пар, и за конечное число таких шагов приведено
к состоянию, когда выполняются определённые <<хорошие>> свойства.

Работа оформлена как альтернативное доказательство остановки алгоритма,
описанного в статье \cite{FaugereF5}, построенное от противного в
предположении, что найдена минимальная последовательность многочленов
$\left\{ f_{1},\ldots,f_{m}\right\} $ в кольце $\mathcal{K}[x_{1},\ldots,x_{n}]$,
на которой алгоритм не останавливается -- зацикливается при обработке
последнего рассматриваемого элемента $f_{1}$. Большинство используемой
терминологии, включая названия процедур, взято оттуда: $T$ обозначает
множество мономов, $\Sig$ -- сигнатуру отмеченного многочлена, \foreignlanguage{english}{$\HM$}
-- старший моном. $R$ -- множество отмеченных многочленов $r_{i}$,
представленное упорядоченным списком. $G$ -- множество индексов многочленов
в этом списке, образующих промежуточный базис. Термин ``signature-safe''
переводится как <<сигнатурный>>:
\begin{defn}
Редукция отмеченного многочлена $r_{k}$ по отмеченному многочлену
$r_{m}$ называется\emph{ сигнатурной редукцией,} если $\Sig(r_{k})\succ t\cdot\Sig(r_{m})$,
где $t=\frac{\HM(r_{k})}{\HM(r_{m})}$ -- моном, на который умножается
редуктор. Редуктор, соответствующий такой редукции, называется \emph{сигнатурным
редуктором}. 
\end{defn}

\subsection{Цепи S-пар}

При отсутствии остановки алгоритм даёт бесконечную последовательность
многочленов $\left\{ r_{1},r_{2},\ldots,r_{m},\ldots,r_{l},\ldots\right\} $,
в которой $r_{1},\ldots,r_{m}$ соответствуют $m$ исходным многочленам,
а остальные были получены в процедурах \texttt{Spol} и \texttt{TopReduction},
как S-многочлены двух уже добавленных. В этой главе мы будем искать
бесконечную подпоследовательность $\left\{ r_{k_{1}},r_{k_{2}},\ldots,r_{k_{n}},\ldots\right\} $
этой последовательности, обладающую тем свойством, что $r_{k_{n}}$
является S-многочленом $r_{k_{n-1}}$ и некоторой другой части с меньшей
сигнатурой: $\Sig(r_{k_{n}})=u_{k_{n}}\Sig(r_{k_{n-1}})\Longleftrightarrow\Sig(r_{k_{n-1}})|\Sig(r_{k_{n}}).$
\begin{defn}
Конечную или бесконечную последовательность отмеченных многочленов,
соседние элементы которой удовлетворяют последнему свойству, будем
называть \emph{цепью S-пар}.
\end{defn}
Каждый порождаемый многочлен $r_{l}$ имеет конечную цепь S-пар, оканчивающуюся
этим многочленом. Эта цепь может быть последовательно построена, начиная
с последнего элемента $r_{l}$, если на каждом шаге переходить от
текущего многочлена к части породившей его S-пары с большей сигнатурой.
\begin{thm}
Любой отмеченный многочлен может являться начальным элементом лишь
конечного числа различных цепей S-пар длины 2.\end{thm}
\begin{proof}
Рассмотрим произвольный отмеченный многочлен $r_{L}$ с сигнатурой
$\Sig(r_{L})=s$ и упорядоченное по порядку добавления подмножество
$\{r_{l_{1}},\ldots,r_{l_{i}},\ldots\}$ отмеченных многочленов с
сигнатурами удовлетворяющими условию $\Sig(r_{l_{i}})=v_{i}\Sig(r_{L})$.
Идеал $\left(v_{1},\ldots,v_{i},\ldots\right)$ в $T$ является конечно
порождённым по лемме Диксона, поэтому после некоторого шага $i_{0}$
будет выполняться $\forall i>i_{0}\,\exists j\leqslant i_{0}$ такое
что $v_{j}|v_{i}$. С другой стороны, при построения S-многочлена
с сигнатурой $s$ старшая часть S-пары соответствует последнему из
правил с сигнатурой, делящей $s$. Поэтому при $\forall i>i_{0}$
последовательность $\{r_{L},r_{l_{i}}\}$ не может являться цепью
S-пар, поскольку $\Sig(r_{L})\cdot v_{i}$ перезаписывается $\Sig(r_{l_{j}})\cdot\frac{v_{i}}{v_{j}}$
и существует не более чем $i_{0}$ цепей S-пар длины 2, начинающихся
с многочлена $r_{L}$.\end{proof}
\begin{defn}
Конечное множество концов цепей S-пар длины 2, начинающихся с $r_{L}$
будет называться \emph{множеством S-порождённых} $r_{L}$.\end{defn}
\begin{thm}
Если алгоритм не останавливается на некоторых входных данных, то он
порождает бесконечную цепь S-пар $\{h_{i}\}$.\end{thm}
\begin{proof}
Если алгоритм не останавливается, то многочлен входного множества
$r_{1}=(1\mathbf{F}_{1},f_{1})$ является началом бесконечного числа
различных конечных цепей S-пар -- каждому многочлену $r_{l}$ соответствует
цепь $\{r_{1},\ldots,r_{l}\}$. Среди конечного числа его S-порождённых
также найдётся элемент, являющийся началом бесконечного числа S-пар.
В его S-порождённых можно выбрать элемент с тем же свойством. Продолжая
выбирать элементы таким образом, мы получим искомую бесконечную последовательность,
состоящую из элементов, являющихся началами бесконечного числа S-пар.
\end{proof}
Для следующей теоремы необходимо ввести порядок на частных, образованных
мономами, путём транзитивного расширения порядка на мономах: $\frac{m_{1}}{m_{2}}>_{q}\frac{m_{3}}{m_{4}}\Leftrightarrow m_{1}m_{4}>m_{3}m_{2}$.
\begin{thm}
\label{thm:f_g_3_props}Если алгоритм не останавливается на некоторых
входных данных, то после некоторого конечного шага множество $G$
содержит пару отмеченных многочленов $f',f$, причём $f$ сгенерирован
после $f'$ и выполняются свойства $\HM(f')|\HM(f)$ и $\frac{\HM(f')}{\Sig(f')}>_{q}\frac{\HM(f)}{\Sig(f)}$.\end{thm}
\begin{proof}
При работе с цепями S-пар является важным тот факт, что многочлен
никогда не редуцируется дальше, после того как он был использован
для создания S-пары в качестве старшей по сигнатуре части. Факт выполняется,
поскольку все многочлены, которые ещё могут быть подвергнуты редукции
находятся в множестве $ToDo$, а все многочлены, используемые как
старшая часть S-пары, находятся в $G$ или в $Done$. Поэтому многочлен
$h_{n}$, предшествующий многочлену $h_{n+1}$ в цепи S-пар, сохраняет
одно и то же значение $\poly(h_{n})$ после того как был использован
для создания какой-либо S-пары. И можно утверждать, что выполняется
равенство $\poly(h_{n+1})=c\frac{\Sig(h_{n+1})}{\Sig(h_{n})}\poly(h_{n})+g_{n}$,
где $g_{n}$ -- многочлен, соответствующей младшей части S-пары, использованный
при генерации $h_{n+1}$ из $h_{n}$, удовлетворяющее следующему:
\begin{equation}
\HM(h_{n+1})<\HM\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)=\HM(g_{n}),\,\Sig(h_{n+1})=\Sig\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)\succ\Sig(g_{n}).\label{eq:spair-chain}
\end{equation}
Из первого неравенства в \eqref{eq:spair-chain} получаем, что $\frac{\HM(h_{n})}{\Sig(h_{n})}>_{q}\frac{\HM(h_{n+1})}{\Sig(h_{n+1})}$,
поэтому в цепи S-пар частные $\frac{\HM(h_{i})}{\Sig(h_{i})}$ строго
убывают в смысле порядка на частных.

В цепи S-пар $\{h_{i}\}$ для различных $h_{i}$ и $h_{j}$ делимость
$\HM(h_{i})|\HM(h_{j})$ возможна только в случае $i<j$ и $\totaldeg(h_{i})<\totaldeg(h_{j})$.
Для нахождения таких многочленов используем идею из Предложения 14
работы \cite{TheF5Revised}: для бесконечной цепи S-пар $\{h_{i}\}$,
рассмотрим бесконечную последовательность в $T$, образованную $\left\{ \HM(h_{i})\right\} $.
В ней по лемме Диксона существует два элемента, удовлетворяющие $\HM(h_{i})|\HM(h_{j})$.
При этом $i<j$, а при помощи свойств цепи S-пар мы получаем, что
$\frac{\HM(h_{i})}{\Sig(h_{i})}>_{q}\frac{\HM(h_{i+1})}{\Sig(h_{i+1})}>_{q}\cdots>_{q}\frac{\HM(h_{j})}{\Sig(h_{j})}$,
поэтому можно взять $f'=h_{i}$ и $f=h_{j}$.
\end{proof}
Из неравенства на частных следует, что $f$ -- сигнатурный редуктор
$f'$. Последующие главы посвящены доказательству невозможности такой
ситуации, приводящей к противоречию предположение об отсутствии остановки.


\subsection{S-пары с сигнатурами, меньшими $\Sig(g)$}

В этой и последующих частях $g$ подразумевается некоторым фиксированным
многочленом с индексом сигнатуры 1, добавленным на некоторой итерации
алгоритма в $Done$. Мы будем анализировать состояние алгоритма в
момент непосредственно предшествующий добавлению $g$ в $Done$. Рассмотрим
в этот момент конечное множество $G_{1}\cup Done$. Оно состоит из
чисел, являющихся позициями отмеченных многочленов в $R$, поэтому
его элементы могут быть упорядочены в соответствии с позицией в $R$
и оно окажется записанным в виде упорядоченной последовательности
целых чисел $G_{g}=\{b_{1},\ldots,b_{N}\}$ с $b_{j}<b_{j+1}$. Необходимо
отметить, что этот порядок соответствует порядку отмеченных многочленов
в последовательности, получаемой склеиванием массивов правил $Rule[m]:Rule[m-1]:\cdots:Rule[1]$,
поскольку добавление нового многочлена в $R$ всегда сопровождается
добавлением соответствующего правила. Но этот порядок может отличаться
от порядка в котором многочлены добавлялись в множество $G_{1}\cup Done$,
поскольку многочлены одной полной степени добавляются в $Done$ в
порядке возрастания сигнатуры, при том что добавление многочленов
одной полной степени в $R$ производится в довольно случайном порядке
в процедурах \texttt{Spol} и \texttt{TopReduction}. Далее для простоты
мы будем говорить о отмеченных многочленах $b_{j}$ в $G_{g}$, подразумевая
что $G_{g}$ является не упорядоченным списком позиций, а упорядоченным
списком отмеченных многочленов, расположенных на этих позициях. В
этой терминологии можно сказать, что все входные многочлены $\left\{ f_{1},\ldots,f_{m}\right\} $
присутствуют в $G_{g}$, поскольку они присутствуют в $G_{1}$ в момент
его создания.

S-пары могут обрабатываться в алгоритме различным путями, но главный
факт, описывающий порядок их обработки выражается следующими свойствами,
соответствующими свойствам, использованным в Теореме 21 работы \cite{F5C},
но рассматриваются на произвольной итерации алгоритма, а не после
его остановки.
\begin{thm}
\label{thm:Exist-gg-repr}К моменту добавления $g$ в $Done$ каждая
S-пара элементов $G_{g}$, сигнатура которой меньше $\Sig(g)$, удовлетворяет
одному из трёх свойств:\end{thm}
\begin{enumerate}
\item S-пара имеет часть, которая была отброшена критерием проверки нормальной
формы $\varphi$ (в \texttt{CritPair} или в \texttt{IsReducible}).
Такие S-пары будут называться \emph{S-парами с частью, удовлетворяющей
критерию F5}. 
\item S-пара имеет часть, которая была отброшена проверкой \texttt{Rewritten?}
(в \texttt{SPol} или в \texttt{IsReducible}). Такие S-пары будут называться
\emph{S-парами с частью, удовлетворяющей критерию Перезаписи}.
\item S-пара не была отброшена, её S-многочлен был сигнатурно редуцирован
по некоторым элементам $G_{g}$ и результат был добавлен в $G_{g}$.
Такие S-пары будут называться \emph{S-парами с известным $G_{g}$-представлением}.\end{enumerate}
\begin{proof}
Вытекает из порядка обработки S-пар и S-многочленов в алгоритме.
\end{proof}
Понятия \emph{удовлетворять критерию F5 }и \emph{удовлетворять критерию
Перезаписи} могут быть расширены на произвольные умноженные на моном
отмеченные многочлены $sh,\, h\in G_{g}$:
\begin{defn}
Умноженный на моном отмеченный многочлен  $sr_{i},\, r_{i}\in G_{g}$
называется \emph{удовлетворяющим критерию F5}, если $\varphi_{index(r_{i})+1}(s\Sig(r_{i}))\ne s\Sig(r_{i})$,
где $\varphi_{index(r_{i})+1}$ -- нормальная форма относительно $G_{index(r_{i})+1}$.
\end{defn}
Это определение эквивалентно тому, что $sr_{i}$ является ненормализованным
отмеченным многочленом с точки зрения определения 2 в части 5 работы
\cite{FaugereF5}.
\begin{defn}
Умноженный на моном отмеченный многочлен $sr_{i},\, r_{i}\in G_{g}$
называется \emph{удовлетворяющим критерию Перезаписи}, если $\exists j>i$
такое что $\Sig(r_{j})|s\Sig(r_{i})$.
\end{defn}
Для обоих критериев выполняется важное свойство, утверждающее, что
если $sr_{i}$ удовлетворяет критерию, то то и дополнительно домноженный
многочлен $s_{1}sr_{i}$ также ему удовлетворяет.


\subsection{Представления}

Идея представлений, определённых ниже, приходит из \cite{F5C}, где
подобный метод используется в доказательстве Теоремы 21. Представления
используются для описания способов, которыми многочлен $p$ может
быть записан как элемент идеала $\left(G_{g}\right)$. Одно представление
соответствует записи отмеченного многочлена $p$ в виде конечной суммы
вида $p=\sum_{k}m_{k}\cdot b_{i_{k}},\; b_{i_{k}}\in G_{g}$ с коэффициентами
$m_{k}=c_{k}t_{k}\in\mathcal{K}\times T$. 
\begin{defn}
Сумма такого вида, в которой все пары $\left(t_{k},b_{i_{k}}\right)$
различны, называется \emph{$G_{g}$-представлением} $p$. Символические
произведения $m_{k}\cdot b_{i_{k}}$ называются \emph{элементами}
представления. Они же, рассмотренные как умножение многочленов, дают
отмеченные многочлены $m_{k}b_{i_{k}}$, соответствующие элементам
представления. 
\end{defn}
Большинство представлений также имеют следующее свойство, ограничивающее
сигнатуру элементов:
\begin{defn}
$G_{g}$-представление $p$ называется \emph{сигнатурным}, если $\forall k\,\Sig(m_{k}b_{i_{k}})\preccurlyeq\Sig(p)$.
\end{defn}

\subsection{Порядок на представлениях}
\begin{defn}
Для введения порядка на $G_{g}$-представлениях мы начнём с \emph{порядка
}$\gtrdot_{1}$\emph{ на элементах представления}: будем говорить,
что $c_{i}t_{i}\cdot b_{i}\gtrdot_{1}c_{j}t_{j}\cdot b_{j}$ если
$t_{i}\Sig(b_{i})\succ t_{j}\Sig(b_{j})$ или $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
и $i<j$.
\end{defn}
Используем \emph{упорядоченную форму} представления -- $\gtrdot_{1}$-убывающий
список его элементов.
\begin{defn}
Введём \emph{порядок $\gtrdot$ на $G_{g}$-представлениях}: представление
$\sum_{k}m'_{k}\cdot b_{i'_{k}}$ является \emph{$\gtrdot$}-большим,
чем $\sum_{k}m_{k}\cdot b_{i_{k}}$, если их упорядоченные формы удовлетворяют
лексикографически расширенному отношению $\gtrdot_{1}$. 
\end{defn}
Порядок на представлениях совместим с понятием сигнатурности представления:
\begin{thm}
Если для пары представлений отмеченного многочлена $p$ выполняется
отношение $\sum_{k}m'_{k}\cdot b_{i'_{k}}\lessdot\sum_{k}m_{k}\cdot b_{i_{k}}$
и правое представление сигнатурно, то и левое представление сигнатурно.\end{thm}
\begin{proof}
Теорема легко следует из того, что сигнатуры элементов $\lessdot$-меньшего
представления не могут быть $\succ$-больше, чем максимальная сигнатура
$\gtrdot$-большего представления.
\end{proof}
Важным фактом, позволяющим брать $\lessdot$-минимальный элемент,
является вполне упорядоченность:
\begin{thm}
Представления вполне упорядочены порядком $\lessdot$.\end{thm}
\begin{proof}
Вполне упорядоченность сигнатур по $\prec$ даёт вполне упорядоченность
элементов представлений по $\lessdot{}_{1}$. Теорема 2.5.5 книги
\cite{Baader.Nipkow98Term} утверждает вполне упорядоченность конечных
наборов, упорядоченных лексикографическим расширением порядка на их
составляющих. Это применимо к представлениям -- наборам своих элементов.
\end{proof}

\subsection{Последовательность представлений}

В этой части строится конечная последовательность $\lessdot$-убывающих
$G_{g}$-представлений для некоторого отмеченного многочлена $mh,\, m\in\mathcal{K}\times T,\, h\in G_{g}$
со свойством $\Sig(mh)\prec\Sig(g)$. Она начинается с сигнатурного
представления $mh=m\cdot h$, и заканчивается представлением $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
со свойствами, выполняющимися для $\forall k$:
\begin{enumerate}
\item $m_{k}b_{i_{k}}$ не удовлетворяет критерию F5.
\item $m_{k}b_{i_{k}}$ не удовлетворяет критерию Перезаписи.
\item $\HM(m_{k}b_{i_{k}})\leqslant\HM(mh)$
\end{enumerate}
Доказательство существования такой последовательности основано на
том, что если некоторое сигнатурное представление $mh$ содержит не
удовлетворяющий одному из свойств элемент $m_{K}\cdot b_{i_{K}}$,
то может быть найдено $\lessdot$-меньшее представление. Схема построения
такова: выбирается элемент $m_{Q}\cdot b_{i_{Q}}$ в представлении
$mh$, где $Q$ может как совпадать, так и отличаться от $K$. Далее
строится некоторое представление $m_{Q}b_{i_{Q}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
для этого элемента и показывается, что оно $\lessdot$-меньше, чем
представление $m_{Q}b_{i_{Q}}=m_{Q}\cdot b_{i_{Q}}$. К нему применяется
следующая лемма:
\begin{lem}
Если элемент $m_{Q}\cdot b_{i_{Q}}$ представления $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
имеет представление $m_{Q}b_{i_{Q}}=\sum_{l}m_{l}\cdot b_{i_{l}}$,
$\lessdot$-меньшее, чем $m_{Q}b_{i_{Q}}=m_{Q}\cdot b_{i_{Q}}$, то
$mh$ имеет представление $\lessdot$-меньшее, чем $\sum_{k}m_{k}\cdot b_{i_{k}}$.\end{lem}
\begin{proof}
Заменим элемент $m_{Q}\cdot b_{i_{Q}}$ в представлении $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
на $\sum_{l}m_{l}\cdot b_{i_{l}}$ и скомбинируем коэффициенты при
элементах с одновременно одинаковыми мономами и многочленами.
\end{proof}
Осталось показать, что представление элемента по вышеуказанной схеме
может быть построено. Выражения, позволяющие построить такое представления
описаны в работе \cite{F5C} и довольно громоздки, поэтому здесь мы
лишь приведём точную формулировку лемм, позволяющих применить эти
выражения в нашем случае.
\begin{lem}
Если сигнатурное $G_{g}$-представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
содержит элемент $m_{K}\cdot b_{i_{K}}$, не удовлетворяющий свойству
1, то он обладает $G_{g}$-представлением $m_{K}b_{i_{K}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
$\lessdot$-меньшим, чем представление $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$.\end{lem}
\begin{proof}
Рассмотрим выражение, аналогичное упоминаемому в Теореме 20 из \cite{F5C}.\end{proof}
\begin{lem}
Если сигнатурное $G_{g}$-представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
с $\Sig(mh)\prec\Sig(g)$ содержит элемент $m_{K}\cdot b_{i_{K}}$,
не удовлетворяющий свойству 2, то он обладает $G_{g}$-представлением
$m_{K}b_{i_{K}}=\sum_{l}m_{l}\cdot b_{i_{l}}$ $\lessdot$-меньшим,
чем представление $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$.\end{lem}
\begin{proof}
Рассмотрим выражение, аналогичное упоминаемому в Предложении 17 из
\cite{F5C}.\end{proof}
\begin{lem}
Если все элементы сигнатурного представления $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
с $\Sig(mh)\prec\Sig(g)$ удовлетворяют свойствам 1 и 2, но хотя бы
один из них не удовлетворяет свойству 3, то найдётся элемент $m_{Q}\cdot b_{i_{Q}}$,
имеющий представление $m_{Q}b_{i_{Q}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
$\lessdot$-меньшее, чем представление $m_{Q}b_{i_{Q}}=m_{Q}\cdot b_{i_{Q}}$.\end{lem}
\begin{proof}
Применим идею о сокращении старших мономов, аналогично Теореме 21
из \cite{F5C}.\end{proof}
\begin{thm}
\label{thm:exist-smaller-signature-safe-representation}Или сигнатурное
представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ с $\Sig(mh)\prec\Sig(g)$
удовлетворяет свойствам 1-3 или существует другое сигнатурное представление
$mh=\sum_{l}m_{l}\cdot b_{i_{l}}$ $\lessdot$-меньшее, чем \textup{$\sum_{k}m_{k}\cdot b_{i_{k}}$.}\end{thm}
\begin{proof}
Теорема немедленно следует из комбинации четырёх предыдущих лемм.\end{proof}
\begin{thm}
Для любого многочлена $mh,\, m\in\mathcal{K}\times T,\, h\in G_{g}$
с $\Sig(mh)\prec\Sig(g)$ существует удовлетворяющее свойствам 1-3
сигнатурное $G_{g}$-представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$\textup{.}\end{thm}
\begin{proof}
Начнём с представления $mh=m\cdot h$ и будем заменять текущее представление
на $\lessdot$-меньшее из теоремы \ref{thm:exist-smaller-signature-safe-representation}
до тех пор, пока текущее представление не будет удовлетворять свойствам
1-3. Конечность процесса гарантируется вполне упорядоченностью представлений
по $\lessdot$.\end{proof}
\begin{cor}
\label{cor:all-needed-for-terminaton}Рассмотрим произвольный многочлен
$f$ без ограничений на его сигнатуру. Если существует сигнатурный
редуктор $f'\in G_{g}$ для $f$ с $\Sig(f')\frac{\HM(f)}{\HM(f')}\prec\Sig(g)$,
то $G_{g}$ содержит сигнатурный редуктор для $f$, который не отбрасывается
критериями F5 и перезаписи.\end{cor}
\begin{proof}
Пусть $mf',\, m=\frac{\HM(f)}{\HM(f')}\in\mathcal{K}\times T,\, f'\in G_{g}$
умноженный редуктор с $\Sig(mf')\prec\Sig(g)$. Из предыдущей теоремы
мы можем найти удовлетворяющее свойствам 1-3 представление $mf'=\sum_{k}m_{k}\cdot b_{i_{k}}$.
Свойство 3 означает отсутствие элементов с $\HM$, большим чем у $mf'$,
значит существует $K$, на котором достигается равенство с $\HM(mf')$:
$\HM(m_{K}\cdot b_{i_{K}})=\HM(mf')=\HM(f)$. Из сигнатурности имеем
$\Sig(m_{K}\cdot b_{i_{K}})\preccurlyeq\Sig(mf')\prec\Sig(f)$, а
значит $m_{K}b_{i_{K}}$ -- сигнатурный редуктор для $f$ и свойства
1-2 гарантируют прохождение критериев.
\end{proof}

\subsection{Обнаружение противоречия}

Теорема \ref{thm:f_g_3_props} при отсутствии остановки утверждает
существование многочленов $f',f\in G$, таких что $\HM(f')|\HM(f)$,
$\frac{\HM(f')}{\Sig(f')}>_{q}\frac{\HM(f)}{\Sig(f)}$. Применяя к
ним последнее следствие построим приводящие к противоречию многочлены.
\begin{thm}
\label{thm:always-exist-ok-reductor}Если алгоритм не останавливается
на некоторых входных данных, то найдётся шаг, после которого конечное
множество \textup{$G\cup Done$} содержит пару отмеченных многочленов
$f'_{1},f$, для которых выполняется: $f'_{1}$ было добавлено в \textup{$G\cup Done$}
до $f$; $f'_{1}$ -- сигнатурный редуктор для $f$; $t_{1}f'_{1}$
не удовлетворяет критериям F5 и Перезаписи, где $t_{1}=\frac{\HM(f)}{\HM(f'_{1})}$.\end{thm}
\begin{proof}
Пусть $f',f$ -- многочлены из теоремы \ref{thm:f_g_3_props} и $t=\frac{\HM(f)}{\HM(f')}$.
Построенная выше теория о представлениях может быть рассмотрена применительно
к случаю $g$ равного $f$. Поскольку $tf'$ -- сигнатурный редуктор
для $f$ -- мы имеем $\Sig(f')t\prec\Sig(f)$ и следствие \ref{cor:all-needed-for-terminaton}
может быть применено для нахождения сигнатурного редуктора $t_{1}f'_{1}$
для $f$, который не удовлетворяет критериям.\end{proof}
\begin{thm}
Алгоритм F5, описанный в \cite{FaugereF5}, останавливается на любых
входных данных.\end{thm}
\begin{proof}
Предположим отсутствие остановки и рассмотрим многочлены $f'_{1},f$
из теоремы \ref{thm:always-exist-ok-reductor}. Вызов \texttt{TopReduction}
после которого $f$ был добавлен в $Done$ вернул многочлен $f$ как
первую половину возвращаемого значения, то есть предшествующий вызов
\texttt{IsReducible} вернул пустое множество. Значит, для всех многочленов
в $G\cup Done$ хотя бы одно из условий (a) - (d) не выполнилось.
Это невозможно, поскольку для $f'_{1}$ их выполнение следует из утверждения
теоремы \ref{thm:always-exist-ok-reductor}.
\end{proof}

\subsection{Выводы}

Данная работа показывает, что исходный алгоритм F5 завершается на
любых однородных входных данных, не ссылаясь на остановку других алгоритмов.
При этом не даётся никакого ограничения на количество операций. Простейшее
доказательство остановки алгоритма Бухбергера основано на свойстве
Нётеровости и тоже не даёт такого ограничения. Однако доказательство
остановки, приведённое здесь, значительно отличается по структуре
от доказательства остановки алгоритма Бухбергера, поэтому не может
быть использовано для сравнения эффективности алгоритма F5 c алгоритмом
Бухбергера. В отличие от этого, остановка изменённых вариаций алгоритма
F5 в работах \cite{Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG}
показывается методом, близким к доказательству остановки алгоритма
Бухбергера, за счёт чего остаётся возможность сравнения их эффективности
с алгоритмом Бухбергера.

С точки зрения практической компьютерной алгебры существует вопрос
эффективности изменённых вариаций по сравнению с исходным F5. Изменённые
вариации могут проводить больше времени в дополнительных проверках,
инициирующих остановку. Но в некоторых случаях возможна ситуация,
когда за счёт этих проверок остановка в изменённых версиях инициируется
раньше, чем в исходной, за счёт чего изменённые версии проводят меньше
редукций. Поэтому становится возможным, что на некоторых входных данных
быстрее оказывается исходный алгоритм, а на других -- модифицированный.
Экспериментально измеренные времена работы в Таблице 1 работы \cite{Modifying-for-termination}
показывают, что оба случая действительно встречаются на практике,
но разница во временах работы незначительна. Поэтому, хотя данная
работа и показывает, что останавливаются не только модифицированные
версии, но и исходный алгоритм, вопрос сравнения эффективности версий
 остаётся открытым.

В доказательстве используются три свойства исходного алгоритма F5,
которые отсутствуют или опциональны в других F5-подобных алгоритмах:
однородность входных многочленов, наличие критерия перезаписи и совпадения
порядка на мономах $<$ с порядком на сигнатурах $\prec$. Возможность
расширения доказательства на F5-подобные алгоритмы, не обладающие
этими свойствами, остаётся открытым. Автор предполагает, что доказательство
может быть модифицировано таким образом, что зависимость от первых
двух свойств исчезнет, однако от третьего избавиться не получится,
поскольку оно является ключевым моментом при получении противоречия
на основе результата теоремы \ref{thm:f_g_3_props}.\\


Автор благодарит Christian Eder, Jean-Charles Faug\`{e}re, Amir Hashemi,
John Perry, Till Stagers и Алексея Зобнина за их работы и комментарии,
воодушевившие автора на исследования в этой области. Спасибо!

#ifdef VESTNIK
\newpage
\spisoklit
\small
#endif

\bibliographystyle{vestnik}
\bibliography{f5_references_1251}


#ifdef VESTNIK
\lend
#endif
\end{document}
