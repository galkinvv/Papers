#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\DeclareMathOperator{\HC}{HC}
\DeclareMathOperator{\HM}{HM}
\DeclareMathOperator{\LCM}{LCM}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\SIG}{\mathcal{S}}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language russian
\language_package babel
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_numerical
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 4cm
\topmargin 4cm
\rightmargin 4cm
\bottommargin 4cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWl}{<_{\text{\textnormal{gvw}}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWg}{>_{\text{\textnormal{gvw}}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\eqdef}{\overset{\mathrm{def}}{=}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\equivdef}{\overset{\mathrm{def}}{\Leftrightarrow}}
\end_inset


\end_layout

\begin_layout Title
Простой итеративный алгоритм вычисления базисов Грёбнера, основанный на
 сигнатурах
\end_layout

\begin_layout Abstract
Данная работа описывает алгоритм вычисления базисов Грёбнера, основанный
 на использовании отмеченных многочленов и идеях из алгоритма F5.
 Отличительными особенностями рассматриваемого алгоритма являются простота
 реализации и доказательств корректной работы.
\end_layout

\begin_layout Section
Определения
\end_layout

\begin_layout Standard
Рассмотрим кольцо многочленов 
\begin_inset Formula $P=k[x_{1},\dots,x_{n}]$
\end_inset

 над полем 
\begin_inset Formula $k$
\end_inset

.
 Будем предполагать, что на моноиде его мономов 
\begin_inset Formula $\mathbb{T}$
\end_inset

 задан допустимый мономиальный порядок 
\begin_inset Formula $\prec$
\end_inset

.
 В этом кольце может быть поставлена задача вычисления базиса Грёбнера для
 произвольного идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{l}\right)$
\end_inset

.
 Один из способов её решения инкрементальный: последовательно вычисляются
 базисы идеалов 
\begin_inset Formula $\left(f_{1},\dots,f_{i}\right),i=2\dots l$
\end_inset

 на основе уже вычисленного для идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{i-1}\right)$
\end_inset

 базиса 
\begin_inset Formula $R_{i-1}$
\end_inset

 и многочлена 
\begin_inset Formula $f_{i}$
\end_inset

.
 Представляемый алгоритм позволяет выполнить шаг такого вычисления.
 Таким образом, входные данные для алгоритма -- это некоторый многочлен
 
\begin_inset Formula $f$
\end_inset

 и множество многочленов, обозначаемое 
\begin_inset Formula $\left\{ g_{1},\dots,g_{m}\right\} $
\end_inset

, являющееся базисом Грёбнера идеала 
\begin_inset Formula $I_{0}=\left(g_{1},\dots,g_{m}\right)$
\end_inset

.
 В качестве результата своей работы алгоритм должен построить множество
 многочленов 
\begin_inset Formula $R$
\end_inset

, являющееся базисом Грёбнера идеала 
\begin_inset Formula $I=\left(g_{1},\dots,g_{m},f\right)$
\end_inset

.
 Поскольку случаи 
\begin_inset Formula $f=0\Rightarrow I=I_{0}$
\end_inset

 и 
\begin_inset Formula $\exists i\, g_{i}\in k\Rightarrow I=P$
\end_inset

 не представляет интереса, далее предполагается что 
\begin_inset Formula $f\neq0,\forall i\, g_{i}\notin k.$
\end_inset


\end_layout

\begin_layout Standard
Введём обозначения: 
\begin_inset Formula $\mathbb{T}_{0}=\mathbb{T}\cup\left\{ 0\right\} $
\end_inset

 -- моноид мономов, расширенный нулём.
 Порядок 
\begin_inset Formula $\prec$
\end_inset

 продолжается с сохранением вполне упорядоченности на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 как 
\begin_inset Formula $\prec_{0}$
\end_inset

 определением 
\begin_inset Formula $\forall t\in\mathbb{T}\, t\succ_{0}0$
\end_inset

.
 Понятие делимости мономов также расширяется на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

: 
\begin_inset Formula $t_{1}|t_{2}\eqdef\exists t_{3}:t_{1}t_{3}=t_{2}$
\end_inset

.
 Для 
\begin_inset Formula $p\in P,p\neq0$
\end_inset

 старшие по 
\begin_inset Formula $\prec$
\end_inset

 моном и коэффициент обозначим 
\begin_inset Formula $\HM(p)\in\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\HC(p)\in k$
\end_inset

.
 Для нуля -- 
\begin_inset Formula $\HM(0)\eqdef0\in\mathbb{T}_{0}$
\end_inset

, 
\begin_inset Formula $\HC(0)\eqdef0\in k$
\end_inset

.
 За 
\begin_inset Formula $\LCM(t_{1},t_{2})\in\mathbb{T}$
\end_inset

 обозначим наименьшее общее кратное 
\begin_inset Formula $t_{1},t_{2}\in\mathbb{T}$
\end_inset

.
 Далее все определения даются для фиксированных 
\begin_inset Formula $I_{0}$
\end_inset

 и 
\begin_inset Formula $f$
\end_inset

:
\end_layout

\begin_layout Definition

\emph on
Отмеченным многочленом
\emph default
 называется пара 
\begin_inset Formula $h=(\sigma,p)\in\mathbb{T}_{0}\times P$
\end_inset

, удовлетворяющая условию корректности: 
\begin_inset Formula $\exists u\in P:\HM(u)=\sigma,uf=p\mod I_{0}.$
\end_inset

 На отмеченные многочлены распространяются определения старшего монома 
\begin_inset Formula $\HM(h)\eqdef\HM(p)$
\end_inset

 и коэффициента 
\begin_inset Formula $\HC(h)\eqdef\HC(p)$
\end_inset

.
 Также определяются 
\emph on
сигнатура
\emph default
 
\begin_inset Formula $\SIG(h)\eqdef\sigma$
\end_inset

 и вводится обозначение многочлена -- второго элемента пары: 
\begin_inset Formula $\poly(h)\eqdef p$
\end_inset

.
 Множество отмеченных многочленов обозначается за 
\begin_inset Formula $H\subset\mathbb{T}_{0}\times P$
\end_inset

.
 Тривиальными примерами отмеченных многочленов являются 
\begin_inset Formula $\left(1,f\right)$
\end_inset

 и 
\begin_inset Formula $\left(0,g\right)$
\end_inset

 для 
\begin_inset Formula $g\in I_{0}$
\end_inset

.
\end_layout

\begin_layout Lemma
Умножение для 
\begin_inset Formula $h\in H,t\in\mathbb{T}$
\end_inset

, заданное как 
\begin_inset Formula $th\eqdef(t\sigma,tp)\in H,$
\end_inset

 корректно.
\end_layout

\begin_layout Standard
Корректность определения проверяется явным нахождением 
\begin_inset Formula $u$
\end_inset

 для 
\begin_inset Formula $h$
\end_inset

.
\end_layout

\begin_layout Definition
Если для некоторых
\emph on
 
\begin_inset Formula $h'_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset


\emph default
 выполняется 
\begin_inset Formula $\SIG(h'_{1})\succ_{0}\SIG(th_{2}),\HM(h'{}_{1})=\HM(th{}_{2})\neq0,$
\end_inset

 то возможна 
\emph on
редукция 
\begin_inset Formula $h'_{1}$
\end_inset

 по 
\begin_inset Formula $h_{2}$
\end_inset

 с сохранением сигнатуры
\emph default
, дающая в результате многочлен 
\begin_inset Formula $h_{1}\in H$
\end_inset

, равный: 
\begin_inset Formula 
\[
h_{1}=\left(\SIG(h'_{1}),\poly(h'_{1})+Kt\poly(h_{2})\right),
\]

\end_inset

где коэффициент 
\begin_inset Formula $K\in k$
\end_inset

 взят так, чтоб при сложении сократились старшие мономы и выполнилось 
\begin_inset Formula $\HM(h{}_{1})\prec_{0}\HM(h'{}_{1})$
\end_inset

.
 По сути такая редукция представляет из себя обычную top-редукцию многочлена,
 дополненную требованием того, что сигнатура редуктора меньше сигнатуры
 редуцируемого.
 Корректность проверяется как и выше.
\end_layout

\begin_layout Standard
Введём частичный порядок 
\begin_inset Formula $\GVWl$
\end_inset

 на 
\begin_inset Formula $H$
\end_inset

: 
\begin_inset Formula 
\[
h_{1}=(\sigma_{1},p_{1})\GVWl h_{2}=(\sigma_{2},p_{2})\equivdef\HM(p_{1})\sigma_{2}\prec_{0}\HM(p_{2})\sigma_{1}.
\]

\end_inset

Элементы с нулевой сигнатурой и старшим мономом оказываются экстремумами:
 
\begin_inset Formula $\forall\sigma_{1},\sigma_{2},p_{1},p_{2}\,\left(0,p_{1}\right)\not\GVWl\left(\sigma_{2},p_{2}\right),\,\left(\sigma_{1},0\right)\not\GVWg\left(\sigma_{2},p_{2}\right)$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset

.
 Тогда 
\begin_inset Formula $h_{1}\GVWg h_{2}\Longleftrightarrow h_{1}\GVWg th_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Выводится из того, что умножение на 
\begin_inset Formula $t$
\end_inset

 одного из сравниваемых отмеченных многочленов приводит к умножению на 
\begin_inset Formula $t$
\end_inset

 обоих частей в определении 
\begin_inset Formula $\GVWg$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,\HM(h_{1})|\HM(h_{2}),\HM(h_{2})\neq0$
\end_inset

.
 Тогда редукция 
\begin_inset Formula $h_{2}$
\end_inset

 по 
\begin_inset Formula $h_{1}$
\end_inset

 с сохранением сигнатуры возможна если и только если 
\begin_inset Formula $h_{1}\GVWg h_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Следует из того что оба утверждения равносильны 
\begin_inset Formula $\SIG(h_{2})\succ_{0}\SIG(h_{1})\frac{\HM(h_{2})}{\HM(h_{1})}$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1}\in H$
\end_inset

 -- результат редукции 
\begin_inset Formula $h_{1}'$
\end_inset

 с сохранением сигнатур по некоторому многочлену.
 Тогда 
\begin_inset Formula $h_{1}\GVWl h_{1}'$
\end_inset

.
\end_layout

\begin_layout Standard
Следует из 
\begin_inset Formula $\SIG(h_{1})=\SIG(h_{1}')$
\end_inset

 и уменьшения 
\begin_inset Formula $\HM$
\end_inset

 при редукции: 
\begin_inset Formula $\HM(h_{1})\prec_{0}\HM(h_{1}').$
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:greater-or-smaller"

\end_inset

Пусть 
\begin_inset Formula $h_{1}\GVWl h_{2}$
\end_inset

 отмеченные многочлены.
 Тогда для любого отмеченного многочлена 
\begin_inset Formula $h_{3}\neq(0,0)$
\end_inset

 выполняется по крайней мере одно из двух неравенств 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

 и 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Из условия леммы известно, что
\begin_inset Formula 
\begin{equation}
\HM(h_{1})\SIG(h_{2})\prec_{0}\HM(h_{2})\SIG(h_{1})\label{eq:gvw-order-3}
\end{equation}

\end_inset

откуда 
\begin_inset Formula $\HM(h_{2})\neq0,\SIG(h_{1})\neq0$
\end_inset

.
 Поэтому, если 
\begin_inset Formula $\HM(h_{3})=0$
\end_inset

, имеем 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

, а если 
\begin_inset Formula $\SIG(h_{3})=0$
\end_inset

 -- то 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

.
 Иначе можно домножить неравенство 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:gvw-order-3"

\end_inset

 на ненулевой элемент 
\begin_inset Formula $\HM(h_{3})\SIG(h_{3})$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
\HM(h_{3})\SIG(h_{3})\HM(h_{1})\SIG(h_{2})\prec_{0}\HM(h_{3})\SIG(h_{3})\HM(h_{2})\SIG(h_{1}).\label{eq:left-or-right-monom}
\end{equation}

\end_inset

Поэтому 
\begin_inset Formula $\HM(h_{3})^{2}\SIG(h_{2})\SIG(h_{1})\in\mathbb{T}_{0}$
\end_inset

 будет или 
\begin_inset Formula $\succ_{0}$
\end_inset

 левой или 
\begin_inset Formula $\prec_{0}$
\end_inset

 правой части неравенства 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:left-or-right-monom"

\end_inset

, и после сокращения даст эквивалентное утверждению леммы неравенство.
\end_layout

\begin_layout Section
Алгоритм
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Вход: многочлены 
\begin_inset Formula $\{g_{1},\dots,g_{m}\}$
\end_inset

, образующие базис Грёбнера; многочлен 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Переменные: 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 -- подмножества 
\begin_inset Formula $H$
\end_inset

; 
\begin_inset Formula $(\sigma,p')\in H$
\end_inset

 -- отмеченный многочлен текущего шага до редукции; 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- он же после редукции; 
\begin_inset Formula $r,b$
\end_inset

 -- элементы 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(g_{1},\dots,g_{m},f\right)$
\end_inset


\end_layout

\begin_layout Paragraph*
SimpleSignatureGroebner
\begin_inset Formula $\left(\left\{ g_{1},\dots,g_{n}\right\} ,f\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\{(0,g_{1}),(0,g_{2}),\dots,(0,g_{n})\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\sigma,p')\leftarrow(1,f)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do forever:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-before-reduce"

\end_inset


\begin_inset Formula $p\leftarrow$
\end_inset

ReduceCheckingSignatures(
\begin_inset Formula $\sigma,p',R$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-after-reduce"

\end_inset


\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
for 
\begin_inset Formula $\{r\in R|r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R|r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
\lang russian
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-from-B"

\end_inset


\begin_inset Formula $B\leftarrow B\setminus\{b\in B|\exists r\in R,\, r\GVWl b\wedge\SIG(r)|\SIG(b)\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if 
\begin_inset Formula $B\neq\emptyset$
\end_inset

: 
\series default

\begin_inset Formula $(\sigma,p')\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate

\series bold
else: break
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)|r\in R\}$
\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "ReduceCheckingSignatures:"

\end_inset

ReduceCheckingSignatures
\begin_inset Formula $\left(\sigma,p,R\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $\exists r\in R|r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

редуцировать 
\begin_inset Formula $p$
\end_inset

 с сохранением сигнатуры по 
\begin_inset Formula $\GVWg$
\end_inset

-максимальному элементу 
\begin_inset Formula $r$
\end_inset

 среди указанных в условии цикла
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Lemma
Все пары из 
\begin_inset Formula $\mathbb{T}_{0}\times P$
\end_inset

 в алгоритме -- элементы 
\begin_inset Formula $H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
Элементы, формируемые до начала главного цикла являются рассмотренными выше
 примерами тривиальных отмеченных многочленов.
 Все остальные отмеченные многочлены в алгоритме формируются или умножением
 на 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

 или редукцией с сохранением сигнатуры, поэтому они корректны и лежат в
 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Standard
Условия циклов, расширяющих 
\begin_inset Formula $B$
\end_inset

, таковы, что в
\series bold
 
\series default

\begin_inset Formula $B$
\end_inset

 нет ни нулевых сигнатур, ни нулевых старших мономов.
 Поэтому 
\begin_inset Formula $\sigma$
\end_inset

 никогда не обращается в 0 и нулевые сигнатуры в 
\begin_inset Formula $R$
\end_inset

 лишь у элементов 
\begin_inset Formula $(0,g_{1}),(0,g_{2}),...,(0,g_{n}).$
\end_inset

 Нулевой старший моном может быть у любого многочлена, добавляемого в 
\begin_inset Formula $R$
\end_inset

, а нулевых многочленов с одновременно нулевой сигнатурой в 
\begin_inset Formula $R$
\end_inset

 нет.
\end_layout

\begin_layout Section
Остановка алгоритма
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:exist-reductor"

\end_inset

В любой момент работы алгоритма любой отмеченный многочлен из 
\begin_inset Formula $B$
\end_inset

 может быть редуцирован с сохранением сигнатуры по некоторому элементу 
\begin_inset Formula $R.$
\end_inset


\end_layout

\begin_layout Standard
Отмеченные многочлены добавляются в 
\begin_inset Formula $B$
\end_inset

 таким образом, чтоб иметь хотя бы один подходящий редуктор.
 При добавлении в первом цикле 
\series bold
for
\series default
 редуктором является 
\begin_inset Formula $(\sigma,p)\in R$
\end_inset

, во втором 
\begin_inset Formula $r\in R$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-small"

\end_inset

До редукции многочлена 
\begin_inset Formula $p'$
\end_inset

, то есть на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-before-reduce"

\end_inset

 любой итерации алгоритма, сигнатуры элементов 
\begin_inset Formula $\left\{ r\in R|r\GVWl(\sigma,p')\right\} $
\end_inset

 не делят 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Standard
На первой итерации алгоритма это выполняется, поскольку 
\begin_inset Formula $\sigma=1$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

 не содержит элементы с сигнатурами, делящими 1.
 На последующих итерациях это выполнено, поскольку если бы в 
\begin_inset Formula $R$
\end_inset

 существовали такие элементы, то 
\begin_inset Formula $\left(\sigma,p'\right)$
\end_inset

 был бы убран из 
\begin_inset Formula $B$
\end_inset

 в предыдущей итерации на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-big"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, старшие мономы элементов 
\begin_inset Formula $\left\{ r\in R|r\GVWg(\sigma,p)\right\} $
\end_inset

 не делят 
\begin_inset Formula $\HM(p)$
\end_inset

.
\end_layout

\begin_layout Standard
Вытекает из того, что цикл в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "ReduceCheckingSignatures:"

\end_inset

 останавливается по достижении 
\begin_inset Formula $p$
\end_inset

, для которого такие элементы в 
\begin_inset Formula $R$
\end_inset

 не существуют.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:adds-really-new"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, элементы 
\begin_inset Formula $R$
\end_inset

 не могут одновременно иметь старшие мономы, делящие 
\begin_inset Formula $\HM(p)$
\end_inset

 и сигнатуры, делящие 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Standard
В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor"

\end_inset

 будет произведена хотя бы одна редукция 
\begin_inset Formula $p'$
\end_inset

, поэтому 
\begin_inset Formula $(\sigma,p')\GVWg(\sigma,p)$
\end_inset

.
 Отсюда по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:greater-or-smaller"

\end_inset

 для 
\begin_inset Formula $\forall r\in R$
\end_inset

 имеем 
\begin_inset Formula $r\GVWg(\sigma,p)$
\end_inset

 или 
\begin_inset Formula $r\GVWl(\sigma,p')$
\end_inset

.
 Выполнение одного из неравенств позволяет применить одну из лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-small"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

.
\end_layout

\begin_layout Theorem
Описанный алгоритм останавливается на любых входных данных
\end_layout

\begin_layout Standard
Для доказательства остановки нужно показать, что все циклы 
\series bold
do
\series default
 выполняются лишь конечное число раз.
 В 
\begin_inset CommandInset ref
LatexCommand nameref
reference "ReduceCheckingSignatures:"

\end_inset

 при ненулевых 
\begin_inset Formula $p$
\end_inset

 на каждой итерации 
\begin_inset Formula $\HM(p)$
\end_inset

 уменьшается относительно 
\begin_inset Formula $\prec_{0}$
\end_inset

, что возможно лишь конечное число раз.
 При обнулении 
\begin_inset Formula $p$
\end_inset

 он завершится в силу 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $(\sigma,0)$
\end_inset

.
\end_layout

\begin_layout Standard
На каждом шаге основного цикла пополняется множество 
\begin_inset Formula $R\subset\mathbb{T}_{0}\times P$
\end_inset

.
 Оно может быть разбито как 
\begin_inset Formula $R_{*0}\cup R_{0*}\cup R_{**},$
\end_inset

 где 
\begin_inset Formula $R_{*0}\subset\mathbb{T}\times\left\{ 0\right\} ,R_{0*}\subset\left\{ 0\right\} \times P\setminus\left\{ 0\right\} ,R_{**}\subset\mathbb{T}\times P\setminus\left\{ 0\right\} $
\end_inset

.
 
\begin_inset Formula $R_{0*}$
\end_inset

 не пополняется в силу 
\begin_inset Formula $\sigma\neq0$
\end_inset

.
 Для остальных рассмотрим идеалы моноидов: 
\begin_inset Formula $L_{*0}=\left(\left\{ \sigma|(\sigma,0)\in R_{*0}\right\} \right)\subset\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $L_{**}=\left(\left\{ (\sigma,t)|\exists(\sigma,p)\in R_{**},t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$
\end_inset

.
 В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new"

\end_inset

 добавляемые элементы расширяют на каждом шаге 
\begin_inset Formula $L_{*0}$
\end_inset

 или 
\begin_inset Formula $L_{**}$
\end_inset

, что по лемме Диксона может происходить лишь конечное число раз.
\end_layout

\begin_layout Section
Корректность
\end_layout

\begin_layout Definition

\emph on
S-представлением
\emph default
 
\begin_inset Formula $h\in H$
\end_inset

 относительно множества 
\begin_inset Formula $\left\{ r_{i}\right\} \subset H$
\end_inset

 будем называть выражение 
\begin_inset Formula $h=\sum_{j}K_{j}t_{j}r_{i_{j}},$
\end_inset

 
\begin_inset Formula $K_{j}\in k,t_{j}\in\mathbb{T},i_{j}\in\mathbb{N}$
\end_inset

, такое что 
\begin_inset Formula $\forall j\HM(h)\succcurlyeq_{0}\HM(t_{j}r_{i_{j}}),\SIG(h)\succcurlyeq_{0}\SIG(t_{j}r_{i_{j}})$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее определение расширяет понятие S-базиса из работы 
\begin_inset CommandInset citation
LatexCommand citet
key "Arri:2011:FCR:2007509.2007761"

\end_inset

:
\end_layout

\begin_layout Definition
Множество отмеченных многочленов называется
\emph on
 
\begin_inset Formula $\SIG_{\sigma}$
\end_inset

-базисом
\emph default
, если относительно него любой допустимый отмеченный многочлен сигнатуры
 
\begin_inset Formula $\prec_{0}\sigma$
\end_inset

 имеет S-представление.
 Если S-представление имеет допустимый многочлен любой сигнатуры, то множество
 называется просто 
\emph on

\begin_inset Formula $\SIG$
\end_inset

-базисом.
\end_layout

\begin_layout Lemma
Если 
\begin_inset Formula $R=\left\{ r_{i}\right\} $
\end_inset

 -- S-базис, то 
\begin_inset Formula $R$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

.
\end_layout

\begin_layout Standard
Вытекает из того что для 
\begin_inset Formula $p\in I$
\end_inset

 можно взять некоторый допустимый 
\begin_inset Formula $h=\left(\sigma,p\right)$
\end_inset

 в S-представлении которого найдётся 
\begin_inset Formula $r_{i_{j}}$
\end_inset

, такой что 
\begin_inset Formula $\HM(p)=t_{j}\HM(r_{i_{j}})$
\end_inset

.
\end_layout

\begin_layout Standard
Для доказательства корректности алгоритма будем доказывать следующую теорему,
 из которой будет следовать корректность ответа в момент остановки алгоритма,
 поскольку при 
\begin_inset Formula $B=\emptyset$
\end_inset

 её инвариант станет выполняться для всех многочленов.
\end_layout

\begin_layout Theorem
На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен следующий инвариант: любой допустимый отмеченный многочлен, сигнатура
 которого 
\begin_inset Formula $\prec$
\end_inset

 чем сигнатуры всех элементов 
\begin_inset Formula $B$
\end_inset

 имеет S-представление относительно 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
Предположим, что утверждение теоремы неверно на определённой итерации алгоритма.
 Зафиксируем множества 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 на момент после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 этой итерации, и все S-представления будем рассматривать относительно этого
 
\begin_inset Formula $R$
\end_inset

.
 Пусть 
\begin_inset Formula $V$
\end_inset

 -- множество допустимых многочленов, для которых не выполняется инвариант,
 а 
\begin_inset Formula $V_{0}=\left\{ v\in V|\SIG(v)=\sigma_{0}\right\} $
\end_inset

 -- подмножество с минимальной сигнатурой.
 Все элементы 
\begin_inset Formula $I_{0}$
\end_inset

 имеют S-представления относительно 
\begin_inset Formula $\{(0,g_{1}),(0,g_{2}),...,(0,g_{n})\}\subset R$
\end_inset

, поэтому 
\begin_inset Formula $\sigma_{0}\neq0$
\end_inset

.
 Выберем 
\begin_inset Formula $v_{0}=(\sigma_{0},q_{0})\in V_{0}$
\end_inset

 -- многочлен с наименьшим старшим мономом.
 Он не может быть редуцирован с сохранением сигнатуры относительно 
\begin_inset Formula $R$
\end_inset

, поскольку иначе результат его редукции 
\begin_inset Formula $v_{1}$
\end_inset

 являлся бы элементом 
\begin_inset Formula $V_{0}$
\end_inset

 с 
\begin_inset Formula $\HM(v_{1})\prec\HM(v_{0})$
\end_inset

.
\end_layout

\begin_layout Standard
Рассмотрим множество 
\begin_inset Formula $\left\{ r\in R|\SIG(r)|\sigma_{0}\right\} $
\end_inset

.
 Поскольку 
\begin_inset Formula $\sigma_{0}\neq0$
\end_inset

, оно содержит добавленный на первой итерации элемент 
\begin_inset Formula $r$
\end_inset

 с 
\begin_inset Formula $\SIG(r)=1$
\end_inset

 и, значит, непусто.
 Рассмотрим его 
\begin_inset Formula $\GVWl$
\end_inset

-минимальный элемент 
\begin_inset Formula $r_{0}$
\end_inset

 и обозначим 
\begin_inset Formula $t_{0}=\frac{\sigma_{0}}{\SIG(r_{0})}$
\end_inset

.
 Предположим, что отмеченный многочлен 
\begin_inset Formula $t_{0}r_{0}=\left(\sigma_{0},t_{0}p_{0}\right)$
\end_inset

 может быть редуцирован с сохранением сигнатуры относительно некоторого
 
\begin_inset Formula $r_{1}\in R$
\end_inset

.
 Отсюда следует, что 
\begin_inset Formula $r_{1}\GVWg r_{0}$
\end_inset

, а также что они не нулевые.
 Значит на той же итерации, когда в 
\begin_inset Formula $R$
\end_inset

 был добавлен последний из 
\begin_inset Formula $\{r_{0},r_{1}\}$
\end_inset

, в множество 
\begin_inset Formula $B$
\end_inset

 был добавлен многочлен 
\begin_inset Formula $t'r_{0}$
\end_inset

, где 
\begin_inset Formula $t'=\frac{\LCM(\HM(r_{1}),\HM(r_{0}))}{\HM(r_{0})}$
\end_inset

, причём 
\begin_inset Formula $t'|t_{0}$
\end_inset

.
 Отсюда 
\begin_inset Formula $\SIG(t'r_{0})|\SIG(t_{0}r_{0})=\sigma_{0}\Rightarrow\SIG(t'r_{0})\preccurlyeq\sigma_{0}$
\end_inset

.
 Поскольку 
\begin_inset Formula $\sigma_{0}$
\end_inset

 -- сигнатура 
\begin_inset Formula $v_{0}$
\end_inset

, для которого не выполняется инвариант, она 
\begin_inset Formula $\prec$
\end_inset

 чем сигнатуры элементов 
\begin_inset Formula $B$
\end_inset

 -- то есть 
\begin_inset Formula $t'r_{0}$
\end_inset

 был выкинут на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 одной из итераций, что влечёт существование 
\begin_inset Formula $r_{2}\in R,r_{2}\GVWl t'r_{0},\SIG(r_{2})|\SIG(t'r_{0})$
\end_inset

.
 Это невозможно, поскольку влечёт 
\begin_inset Formula $r_{2}\GVWl r_{0},\SIG(r_{2})|\SIG(t_{0}r_{0})=\sigma_{0}$
\end_inset

, что противоречит 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $r_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Таким образом показано, что 
\begin_inset Formula $t_{0}r_{0}=\left(\sigma_{0},t_{0}p_{0}\right)$
\end_inset

 и 
\begin_inset Formula $v_{0}=(\sigma_{0},q_{0})$
\end_inset

 не могут быть редуцированы относительно 
\begin_inset Formula $R$
\end_inset

 с сохранением сигнатуры, при этом первый из них имеет тривиальное S-представлен
ие 
\begin_inset Formula $t_{0}r_{0}$
\end_inset

, а второй не имеет S-представления.
 Из допустимости следует, что их разность 
\begin_inset Formula $w=\left(\sigma_{1},q_{0}-Kt_{0}p_{0}\right)$
\end_inset

 с некоторым коэффициентом 
\begin_inset Formula $K\in k$
\end_inset

 есть допустимый многочлен сигнатуры 
\begin_inset Formula $\sigma_{1}\prec\sigma_{0}$
\end_inset

.
 
\begin_inset Formula $w\not\in V$
\end_inset

 в силу малости сигнатуры и имеет S-представление 
\begin_inset Formula $w=\sum_{j}K_{j}t_{j}r_{i_{j}}.$
\end_inset

 Значит 
\begin_inset Formula $\exists j|\HM(t_{j}r_{i_{j}})=\HM(w),\SIG(t_{j}r_{i_{j}})\preccurlyeq\SIG(w)=\sigma_{1}\prec\sigma_{0}$
\end_inset

.
 Если бы 
\begin_inset Formula $\HM(w)\in\{\HM(v_{0}),\HM(t_{0}r_{0})\}$
\end_inset

, то 
\begin_inset Formula $r_{i_{j}}$
\end_inset

 был бы сохраняющим сигнатуру редуктором для 
\begin_inset Formula $v_{0}$
\end_inset

 или 
\begin_inset Formula $t_{0}r_{0}$
\end_inset

, что невозможно.
 Значит старшие мономы сокращаются при вычитании, то есть 
\begin_inset Formula $\HM(v_{0})=\HM(t_{0}r_{0})$
\end_inset

.
 Отсюда выводим S-представление: 
\begin_inset Formula $v_{0}=Kt_{0}r_{0}+\sum_{j}K_{j}Kt_{j}r_{i_{j}}.$
\end_inset

 Противоречие.
\end_layout

\begin_layout Subsection
Связь с аналогами
\end_layout

\begin_layout Standard
Представленный алгоритм связан с двумя уже известными алгоритмами, основанных
 на сигнатурах -- алгоритм G2V из работы 
\begin_inset CommandInset citation
LatexCommand citet
key "Gao:2010:NIA:1837934.1837944"

\end_inset

 и версию F5, опубликованную в работе 
\begin_inset CommandInset citation
LatexCommand citet
key "Arri:2011:FCR:2007509.2007761"

\end_inset

.
 Оба они в определённом смысле являются модификациями простого F5, впервые
 представленного в работе 
\begin_inset CommandInset citation
LatexCommand citet
key "Faugere:2002:NEA:780506.780516"

\end_inset

, причём модификации направлены на сокращение числа редукций многочленов,
 занимающих большую часть времени в процессе вычисления базисов Грёбнера.
 Первый из них отличается от немодифицированной версии тем, что не использует
 явного вычисления S-полиномов до проведения редукции и вводит специальный
 критерий 
\begin_inset Quotes fld
\end_inset

super-topreducible
\begin_inset Quotes frd
\end_inset

 для отбрасывания некоторых многочленов после их редукции.
 Второй применяет расширенный критерий, отбрасывая до редукции те из посчитанных
 S-полиномов, которые не смогут удовлетворять критерию 
\begin_inset Quotes fld
\end_inset

primitve S-irreducble
\begin_inset Quotes frd
\end_inset

 после редукции.
 Эти методики позволяют ускорить работу алгоритма, однако в обоих случаях
 в определённый момент отбрасывается многочлен, полученный в процессе предыдущих
 вычислений путём редукции или создания S-полинома.
\end_layout

\begin_layout Standard
Практически во всех алгоритмах, основанных на сигнатурах, в том числе в
 исходном алгоритме F5 применяется и более эффективный тип критериев: критерии
 отбрасывания S-пар, не требующие вычислений с многочленами для своей проверки
 -- их отличия в различных алгоритмах подробно разобраны в работе 
\begin_inset CommandInset citation
LatexCommand citet
key "Eder:2011:SAC:1993886.1993906"

\end_inset

.
 Однако вопрос об их сравнительной эффективности остаётся неясным как с
 теоретической, так и с эмпирической точек зрения -- на различных примерах
 большее или меньшее преимущество могут иметь различные подходы.
\end_layout

\begin_layout Standard
В алгоритме SimpleSignatureGroebner используется подход, который можно интерпрет
ировать как объединение всего вышеуказанного: S-полиномы не вычисляются
 явно и их отбрасывание осуществляется на основе критерия, записываемого
 в точности как критерий второго алгоритма.
 При этом для проверки на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 элемента 
\begin_inset Formula $B$
\end_inset

 достаточно знать лишь его сигнатуру и старший моном.
 Поскольку каждый элемент 
\begin_inset Formula $B$
\end_inset

 получается как домноженный на моном 
\begin_inset Formula $m$
\end_inset

 элемент 
\begin_inset Formula $r\in R$
\end_inset

 их можно хранить в виде пары 
\begin_inset Formula $\left(m,r\right)$
\end_inset

, не выполняя без необходимости операции домножения всего многочлена на
 моном.Таким образом, для отброшенных элементов 
\begin_inset Formula $B$
\end_inset

 не производится никаких операций, сложность которых пропорциональна длине
 многочлена.
 Заметим, что применяемое во втором алгоритме вычисление старшего монома
 S-пары в общем случае напротив имеет именно такую сложность.
 Таким образом, возможна реализация алгоритма SimpleSignatureGroebner, в
 которой все операции над многолченами производятся лишь для многочленов,
 попадающих в результирующее множество.
 Результирующее множество не является минимальным базисом Грёбнера, но при
 этом в определённом смысле минимально.
 Это минимальное множество, удовлетворяющее определению S-базиса.
\end_layout

\begin_layout Standard
Отсюда можно сделать вывод о некоторой полноте критериев отбрасывания: не
 может существовать критерия, который бы позволил убрать какие-либо операции
 редукции многочленов из алгоритма не добавив новых редукций и не лишив
 результат свойства быть базисом S-представлений.
 Из доказательств корректности многих алгоритмов, основанных на сигнатурах
 следует что их результат содержит такое множество, поэтому представленный
 алгоритм является в указанном смысле оптимальным алгоритмом, находящим
 минимальный базис S-представлений для последовательности идеалов, расширяемых
 одним многочленом на каждом шаге.
\end_layout

\begin_layout Standard
Эта оптимальность не глобальна -- могут существовать более эффективные модификац
ии алгоритма, которые не просто убирают вычисления, а заменяют одни вычисления
 над полиномами другими.
 К примеру, вопрос наиболее эффективного способа выбора редуктора в процедуре
 Редуцировать_с_учётом_сигнатур является открытым.
 Представленный способ выбора, основанный на 
\begin_inset Formula $\GVWl$
\end_inset

-сравнении наиболее близок к способу выбора, применявшегося в оригинальном
 алгоритме F5.
\end_layout

\begin_layout Standard
Алгоритм был реализован на С++ с использованием функций ядра программного
 комплекса Singular 3-1-4 и открытых наработок Christian Eder по реализации
 F5-подобных алгоритмов на этом ядре.
 Исходный код реализации содержится в функции ssg файла, доступного по адресу
 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc"

\end_inset


\end_layout

\begin_layout Standard
Сравнение реализации с другими алгоритмами вычисления базисов Грёбнера,
 реализованных Christian Eder подтвердили следующие теоретические соображения:
\end_layout

\begin_layout Itemize
Алгоритм SimpleSignatureGroebner корректно вычисляет базис Грёбнера
\end_layout

\begin_layout Itemize
Возвращаемое множество содержит не большее число многочленов, чем множество
 возвращаемое другими инкрементальными алгоритмами, про которые известно,
 что они возвращают S-представление
\end_layout

\begin_layout Itemize
Время работы алгоритма оказывается несколько меньше, чем у других инкрементальны
х алгоритмов, основанных на сигнатурах.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "f5_references"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
