#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\begin_local_layout

\end_local_layout
\language russian
\language_package default
\inputencoding cp1251
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex8
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWl}{<_{\text{H}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWg}{>_{\text{\textnormal{H}}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\eqdef}{\overset{\mathrm{_{def}}}{=}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\equivdef}{\overset{\mathrm{_{def}}}{\Leftrightarrow}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Sig}{\mathcal{S}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\HM}{\mathrm{HM}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\HC}{\mathrm{HC}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\LCM}{\mathrm{LCM}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\totaldeg}{\mathrm{deg}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\poly}{\mathrm{poly}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\sigidx}{\mathrm{index}}
\end_inset


\end_layout

\begin_layout Title
Алгоритмы вычисления Базисов Грёбнера, основанные на сигнатурах
\end_layout

\begin_layout Author
Василий Галкин
\end_layout

\begin_layout Address
МГУ
\end_layout

\begin_layout Address
galkin-vv@ya.ru
\end_layout

\begin_layout Abstract
Основное направление данной работы -- построение эффективного способа применения
 алгоритмов, основанных на сигнатурах, для решения полиномиальных уравнений.
 В первой части показана остановка алгоритм F5, предложенного Фожером, и
 описан его вариант, значительно упрощающий реализацию и теоретическое обоснован
ие.
 Во второй части показано, как данная вариация может быть модифицирована
 для эффективного решения полиномиальных систем уравнений в интервальной
 арифметике путём ввода новых переменных и дополнительных вычислений над
 конечными полями.
\end_layout

\begin_layout Part
Вычисление базисов Грёбнера
\end_layout

\begin_layout Standard
Для работы с базисами Грёбнера необходимо договориться об обозначениях,
 которые будут использоваться на протяжении всего текста:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{K}$
\end_inset

 -- некоторое поле
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

 -- абстрактное множество переменных
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{T}$
\end_inset

 -- множество мономов, образуемых этими переменными.
 Является коммутативным моноидом по операции умножения мономов
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{T}_{0}=\mathbb{T}\cup\left\{ 0\right\} $
\end_inset

 -- формально расширенное нулём множество мономов.
 Операция умножения расширяется как 
\begin_inset Formula $\forall t\in\mathbb{T}_{0}\, t\cdot0=0$
\end_inset

.
 Является коммутативной полугруппой по этой операции.
 Понятие делимости в 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 стандартно: 
\begin_inset Formula $t_{1}|t_{2}\eqdef\exists t_{3}\, t_{1}\cdot t_{3}=t_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}$
\end_inset

 -- кольцо многочленов 
\begin_inset Formula $\mathcal{K}[x_{1},\dots,x_{n}]$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\totaldeg(t)\in\mathbb{Z}$
\end_inset

 -- полная степень монома 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset


\end_layout

\begin_layout Definition
Полный порядок 
\begin_inset Formula $\prec$
\end_inset

 на 
\begin_inset Formula $\mathbb{T}$
\end_inset

 называется 
\emph on
мономиальным
\emph default
, если он делает 
\begin_inset Formula $\mathbb{T}$
\end_inset

 вполне упорядоченным, а также 
\begin_inset Formula $\forall t_{1},t_{2},t_{3}\in\mathbb{T}$
\end_inset

 выполняется:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
t_{1}\prec t_{2}\Longrightarrow t_{1}t_{3}\prec t_{2}t_{3}
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
1\preccurlyeq t_{1}
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\prec$
\end_inset

 -- зафиксированный мономиальный порядок на 
\begin_inset Formula $\mathbb{T}$
\end_inset

.
 Минимальным элементом является 
\begin_inset Formula $1\in\mathbb{T}$
\end_inset

, то есть пустое произведение
\end_layout

\begin_layout Itemize
\begin_inset Formula $\prec_{0}$
\end_inset

 -- порядок 
\begin_inset Formula $\prec$
\end_inset

, продолженный на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 заданием 
\begin_inset Formula $1\succ_{0}0$
\end_inset

.
 Легко показать, что он делает 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 вполне упорядоченным
\end_layout

\begin_layout Itemize
\begin_inset Formula $\HM(p)\in\mathbb{T}_{0}$
\end_inset

 -- старший моном многочлена, определён для 
\begin_inset Formula $\forall p\in\mathcal{P}$
\end_inset

; при 
\begin_inset Formula $p\neq0$
\end_inset

 равен старшему по 
\begin_inset Formula $\prec$
\end_inset

 моному, а для 
\begin_inset Formula $p=0$
\end_inset

 определён как 
\begin_inset Formula $\HM(0)=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\HC(p)\in\mathcal{K}$
\end_inset

 -- старший коэффициент многочлена, определён для 
\begin_inset Formula $\forall p\in\mathcal{P}$
\end_inset

; при 
\begin_inset Formula $p\neq0$
\end_inset

 равен коэффициенту при старшем по 
\begin_inset Formula $\prec$
\end_inset

 моному, а для 
\begin_inset Formula $p=0$
\end_inset

 определён как 
\begin_inset Formula $\HC(0)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LCM(t_{1},t_{2})\in\mathbb{T}$
\end_inset

 -- наименьшее общее кратное мономов 
\begin_inset Formula $t_{1},t_{2}\in\mathbb{T}$
\end_inset

.
 
\end_layout

\begin_layout Definition
Ненулевой многочлен 
\begin_inset Formula $g$
\end_inset

 
\emph on
редуцирует
\emph default
 ненулевой многочлен 
\begin_inset Formula $f$
\end_inset

, если 
\begin_inset Formula $\HM(g)|\HM(f)$
\end_inset

.
 
\emph on
Результатом редукции
\emph default
 называется многочлен 
\begin_inset Formula $h=f-\frac{\HC(f)\HM(f)}{\HC(g)\HM(g)}g$
\end_inset

.
 Он может быть нулевой и для него выполняется 
\begin_inset Formula $\HM(h)\prec_{0}\HM(f)$
\end_inset

.
 Конечная или бесконечная последовательность 
\begin_inset Formula $\left\{ f,f_{1},f_{2},...\right\} $
\end_inset

 называется 
\emph on
последовательностью редукций 
\emph default
по элементам 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 многочлена 
\begin_inset Formula $f$
\end_inset

, если каждый следующий элемент есть результат редукции предыдущего по некотором
у многочлену из 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
Определение редукции зависит от порядка.
 На его основе дадим самое простое определение базиса Грёбнера:
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gb-def-1"

\end_inset

Множество 
\begin_inset Formula $G\subset I$
\end_inset

 называется 
\emph on
базисом Грёбнера
\emph default
 идеала 
\begin_inset Formula $I$
\end_inset

 кольца 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для порядка 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall f\in I,f\neq0\exists g\in G$
\end_inset

, редуцирующий 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Lemma
Если множество 
\begin_inset Formula $G\subset I$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 есть конечная последовательность редукций по элементам 
\begin_inset Formula $G$
\end_inset

, начинающаяся с 
\begin_inset Formula $f$
\end_inset

 и заканчивающаяся нулём.
\end_layout

\begin_layout Proof
Она может быть получена последовательным проведением редукций до тех пор,
 пока не будет получен нулевой многочлен.
 Конечность этой операции гарантируется тем, что каждая редукция уменьшает
 
\begin_inset Formula $\HM$
\end_inset

 по 
\begin_inset Formula $\prec_{0}$
\end_inset

, а множество 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 вполне упорядочено.
\end_layout

\begin_layout Standard
Для алгоритмов вычисления базиса Грёбнера будет полезна некоторая переформулиров
ка этого определения, для которой вводятся понятия представлений отчасти
 заимствованные из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 Представления используются для описания способов, которыми многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан как комбинация многочленов из множества 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Definition
Для фиксированного множества 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 назовём 
\emph on
представлением над 
\begin_inset Formula $G$
\end_inset

 
\emph default
многочлена 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 любую соответствующую верному равенству в 
\begin_inset Formula $\mathcal{P}$
\end_inset

 запись вида
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot g_{i_{k}},\; g_{i_{k}}\in G
\]

\end_inset

с коэффициентами 
\begin_inset Formula $m_{k}=c_{k}t_{k}\in\mathcal{K}\times\mathbb{T}$
\end_inset

, в которой все пары 
\begin_inset Formula $\left(t_{k},g_{i_{k}}\right)$
\end_inset

 различны.
 Символические произведения 
\begin_inset Formula $m_{k}\cdot g_{i_{k}}$
\end_inset

 называются 
\emph on
элементами
\emph default
 представления.
 Если рассмотреть это символическое произведение как умножение многочленов,
 то мы получим многочлен 
\begin_inset Formula $m_{k}g_{i_{k}}$
\end_inset

, соответствующий элементу представления.
 Тогда 
\begin_inset Formula $p$
\end_inset

 оказывается равным сумме отмеченных многочленов, соответствующих элементам
 его представления.
 Два представления равны, если наборы их элементов совпадают как множества.
 Поскольку правая часть представления лежит в идеале 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\left(G\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang russian
, представление может существовать лишь для 
\begin_inset Formula $p\in\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Понятие представления не зависит от порядка 
\begin_inset Formula $\prec$
\end_inset

.
 Для базисов Грёбнера нужна следующая разновидность представлений, определение
 которой уже зависит от порядка:
\end_layout

\begin_layout Definition
Представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

 называется 
\emph on
степенным
\emph default
, если 
\begin_inset Formula $\forall k\,\HM(m_{k}g_{i_{k}})\preccurlyeq\HM(p)$
\end_inset

.
\end_layout

\begin_layout Standard
Дадим несколько примеров представлений над множеством 
\begin_inset Formula $G=\{y,y^{2},x^{2}+y\}\subset\mathbb{R}[x,y]$
\end_inset

 с лексикографическим порядком, заданным 
\begin_inset Formula $x\succ y$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $y=1\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}=y\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}=y\cdot(x^{2}+y)-x^{2}\cdot y$
\end_inset

 -- представление, не являющееся степенным
\end_layout

\begin_layout Itemize
\begin_inset Formula $0=1\cdot y^{2}-y\cdot y$
\end_inset

 -- представление, не являющееся степенным
\end_layout

\begin_layout Itemize
\begin_inset Formula $0=0$
\end_inset

 (сумма нуля элементов) -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}=1\cdot(x^{2}+y)-1\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}y=y\cdot y+y\cdot(x^{2}+y)-2y\cdot y$
\end_inset

 -- не является представлением, так как первый и последний элементы отличаются
 лишь коэффициентом
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}y+y^{2}=y\cdot y+y\cdot(x^{2}+y)-1\cdot y^{2}$
\end_inset

 -- степенное представление, так как первый и последний элементы отличаются
 как пары, хотя и равны как многочлены.
\end_layout

\begin_layout Standard
Теперь можно сформулировать эквивалентное определение для базиса Грёбнера:
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gb-def-2"

\end_inset

Множество 
\begin_inset Formula $G\subset I$
\end_inset

 называется 
\emph on
базисом Грёбнера
\emph default
 идеала 
\begin_inset Formula $I$
\end_inset

 кольца 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для порядка 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall f\in I$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Theorem
Определения 
\begin_inset CommandInset ref
LatexCommand ref
reference "gb-def-1"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "gb-def-2"

\end_inset

 эквивалентны
\end_layout

\begin_layout Proof
Если множество 
\begin_inset Formula $G$
\end_inset

 удовлетворяет второму определению, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 один из элементов степенного представления может быть взят в качестве редуцирую
щего.
\end_layout

\begin_layout Proof
Если множество 
\begin_inset Formula $G$
\end_inset

 удовлетворяет первому определению, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 степенное представление может быть получено как последовательность вычитаемых
 элементов в последовательности редукций 
\begin_inset Formula $f$
\end_inset

 к нулю по элементам 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
При зафиксированных кольце многочленов и порядке на мономах для постановки
 задачи вычисления базисов Грёбнера необходимо задать идеал 
\begin_inset Formula $I\subset\mathcal{P}$
\end_inset

.
 Все алгоритмы, описанные в этой работе подразумевают, что идеал задаётся
 конечным набором своих порождающих: 
\begin_inset Formula $I=\left(F\right)=\left(f_{1},\ldots,f_{m}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Все алгоритмы вычисления базиса Грёбнера по заданным таким образом входным
 данным могут быть разделены на 2 больших группы: инкрементальные и одноэтапные.
 Инкрементальные алгоритмы состоят из 
\begin_inset Formula $m-1$
\end_inset

 шагов, причём 
\begin_inset Formula $i$
\end_inset

-й шаг строит базис Грёбнера 
\begin_inset Formula $G_{i+1}$
\end_inset

 идеала 
\begin_inset Formula $\left(f_{1},\ldots,f_{i+1}\right)$
\end_inset

, принимая на вход многочлен 
\begin_inset Formula $f_{i+1}$
\end_inset

 и набор многочленов, составляющих найденный ранее базис 
\begin_inset Formula $G_{i}$
\end_inset

.
 При этом 
\begin_inset Formula $G_{1}$
\end_inset

 известно сразу, поскольку равно 
\begin_inset Formula $\left\{ f_{1}\right\} $
\end_inset

, а последний найденный базис 
\begin_inset Formula $G_{m}$
\end_inset

 является искомым базисом 
\begin_inset Formula $I$
\end_inset

.
 Таким образом, чтоб задать инкрементальный алгоритм нужно задать лишь его
 шаг, находящий конечное множество 
\begin_inset Formula $G_{i+1}$
\end_inset

 по заданным 
\begin_inset Formula $f_{i+1}$
\end_inset

 и множеству 
\begin_inset Formula $G_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Одноэтапные алгоритмы принимают на вход сразу все многочлены 
\begin_inset Formula $f_{1},\ldots,f_{m}$
\end_inset

 и возвращают искомый базис Грёбнера, и не допускают естественного разбиения
 на шаги, аналогичные инкрементальным алгоритмам.
 Они могут быть сделаны инкрементальными 
\begin_inset Quotes fld
\end_inset

искусственно
\begin_inset Quotes frd
\end_inset

 путём использования одноэтапного алгоритма в роли шага для инкрементального,
 подавая ему на вход множество 
\begin_inset Formula $G_{i}\cup f_{i+1}$
\end_inset

.
\end_layout

\begin_layout Section
Алгоритм Бухбергера
\end_layout

\begin_layout Standard
Простейшим алгоритмом вычисления базиса Грёбнера является алгоритм Бухбергера.
 Мы не будем подробно останавливаться на нём, однако дадим некоторые теоретическ
ие сведения, которые будут использоваться и в других алгоритмах, и опишем
 наиболее простую его версию без каких-либо оптимизаций.
\end_layout

\begin_layout Definition

\emph on
S-парой
\emph default
 ненулевых многочленов 
\begin_inset Formula $g_{1}$
\end_inset

 и 
\begin_inset Formula $g_{2}$
\end_inset

 называется пара произведений:
\begin_inset Formula 
\[
\left(\frac{\HM(g_{2})\HC(g_{2})}{\LCM(\HM(g_{1}),\HM(g_{2}))}\cdot g_{1};\frac{\HM(g_{1})\HC(g_{1})}{\LCM(\HM(g_{1}),\HM(g_{2}))}\cdot g_{2}\right).
\]

\end_inset

Каждое из произведений называется 
\emph on
частью S-пары
\emph default
.
 Части S-пары могут рассматриваться как символические произведения монома
 на многочлен, или как многочлены, равные этим произведениям.
 При последней трактовке у частей S-пары оказывается одинаковый старший
 моном, называемый 
\emph on
сокращаемым мономом S-пары
\emph default
, и одинаковый старший коэффициент.
 Поэтому при вычитании второй части S-пары из первой происходит сокращение
 старших мономов.
 Получаемая разность называется 
\emph on
S-многочленом
\emph default
, соответствующим S-паре, или просто S-многочленом 
\begin_inset Formula $g_{1}$
\end_inset

 и 
\begin_inset Formula $g_{2}$
\end_inset

.
\end_layout

\begin_layout Theorem
Пусть задано конечное множество ненулевых многочленов 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

, и известно что любой S-многочлен элементов 
\begin_inset Formula $G$
\end_inset

 имеет степенное представление 
\begin_inset Formula $G$
\end_inset

.
 Тогда любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

, и таким образом 
\begin_inset Formula $G$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Эта теорема является главной теоремой, показывающей корректность алгоритма
 Бухбергера, однако вместо неё будет доказана более общая версия, применимая
 далее для алгоритмов, основанных на сигнатурах.
 Следующее определение формулируется для любых объектов, с которыми можно
 проводить операции сравнения на равенство, умножения на моном и взятия
 старшего монома 
\begin_inset Formula $\HM$
\end_inset

.
 При всех использованиях этого понятия таким объектом будет являться многочлен
 из 
\begin_inset Formula $\mathcal{P}$
\end_inset

, возможно с некоторыми дополнительно ассоциированными с ним данными, поэтому
 в тексте определения мы будем использовать термин 
\begin_inset Quotes fld
\end_inset

обобщённый многочлен
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Definition
Условием на редукцию обобщённого многочлена 
\begin_inset Formula $f$
\end_inset

 по 
\begin_inset Formula $g$
\end_inset

 называется
\end_layout

\begin_layout Standard
[определения S-пар, простейший вариант]
\end_layout

\begin_layout Section
Алгоритмы, основанные на сигнатурах
\end_layout

\begin_layout Standard
[Определения сигнатур, правил редукции, S-представлений]
\end_layout

\begin_layout Subsection
Алгоритм F5 в формулировке Фожера
\end_layout

\begin_layout Standard
[псевдокод в форме Фожера]
\end_layout

\begin_layout Subsection
Доказательство остановки
\end_layout

\begin_layout Subsubsection
Введение
\end_layout

\begin_layout Standard
Алгоритм Фожера F5 является эффективным алгоритмом вычисления базисов Грёбнера,
 но обладает рядом проблем, связанных с его обоснованием.
 Корректность его работы при условии остановки показана в первоисточнике
 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 и в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "GermanF5Proof_ru,F5InBBStyle,NewF5Proof"

\end_inset

, предложивших другие способы её доказательства.
 Но остановка алгоритма, как в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, так и в детальных исследованиях 
\begin_inset CommandInset citation
LatexCommand cite
key "F5-revisited"

\end_inset

, показана только для случая отсутствия редукций к нулю, что с практической
 точки зрения означает доказательство для тех случаев, когда входное множество
 многочленов представлено регулярной последовательностью.
 Но для большинства входных последовательностей их регулярность неизвестна,
 и доказанного факта оказывается недостаточно для утверждения остановки
 реализации алгоритма на конкретных входных данных.
 Один из подходов к решению проблемы -- добавление в алгоритм дополнительных
 проверок и критериев, гарантирующих остановку алгоритма.
 Этот подход даёт строгое доказательство остановки, однако получаемый результат
 есть доказательство остановки модифицированной версии F5, содержащей дополнител
ьные проверки, которая в силу этого может быть более сложна в реализации
 или иметь большее время работы на некоторых входных данных.
 Этот подход применяется в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG,Hashemi-ExtF5,ZobninGeneralization_ru"

\end_inset

.
\end_layout

\begin_layout Standard
Другой подход состоит в доказательстве остановки семейства алгоритмов, основанны
х на идеях F5, с последующей попыткой переформулировать F5 таким образом,
 чтобы он являлся представителем этого семейства.
 Основная проблема этого подхода появляется в процессе переформулировки:
 описание F5 в других терминах может привести к незаметному внесению различий
 в поведение алгоритма, которые трудно заметить, но которые требуют дополнительн
ых рассуждений для доказательства эквивалентности с F5.
 К примеру, 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

 доказывает остановку алгоритма F5GEN, который отличается от исходного F5
 отсутствием проверки критериев при выборе редуктора.
 Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 даёт доказательство остановки алгоритма TRB-F5, который, как удалось осознать
 автору в процессе плодотворных дискуссий с Джоном Перри, имеет два существенных
 отличия от F5.
 Первое отличие -- другая схема построения правил, приводящая в конце концов
 к тому, что в процессе выполнения TRB-F5 правила в массивах 
\begin_inset Formula $Rule$
\end_inset

 оказываются отсортированными по возрастанию сигнатуры.
 Второе отличие -- отсутствие в TRB-F5 применения оператора нормальной формы
 
\begin_inset Formula $\varphi$
\end_inset

 перед редукцией, что приводит к эффекту противоположному отличиям F5 от
 F5GEN: алгоритм TRB-F5 при выборе редуктора проверяет критерии для элементов
 с 
\begin_inset ERT
status open

\begin_layout Plain Layout

б
\backslash
'{о}льшими
\end_layout

\end_inset

 индексами, которые в F5 используются неявно в операторе нормальной формы
 и за счёт этого не подвергаются проверки критериев.
 Предположительно, эти алгоритмы могут быть изменены таким образом, чтобы
 в точности повторять поведение алгоритма F5, а доказательство остановки
 может быть перенесено на изменённые версии.
 Однако подход с алгоритмами, эквивалентными F5 имеет недостаток: он усложняет
 понимание того, как теоремы, используемые для доказательства остановки
 отражают поведение исходного алгоритма F5.
\end_layout

\begin_layout Standard
Подход к доказательству остановки, предлагаемый в данной работе, применяется
 к F5 без каких-либо модификаций.
 Первый шаг доказательства основан на предлагаемой ниже идее цепей S-пар.
 Второй шаг основывается на методе, использованном в теореме 21 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 для доказательства корректности алгоритма F5C: представление S-многочлена
 в виде суммы домноженных многочленов из множества, вычисленного F5C может
 быть модифицировано последовательностью замен S-пар и их отброшенных частей,
 и за конечное число таких шагов приведено к состоянию, когда выполняются
 определённые 
\begin_inset Quotes fld
\end_inset

хорошие
\begin_inset Quotes frd
\end_inset

 свойства.
\end_layout

\begin_layout Standard
Вторая часть этой статьи показывает, что предусловия этого метода могут
 быть ослаблены для его применения к множеству на любом промежуточном шаге
 вычислений F5, и что получаемые следствия могут быть усилены для их использован
ия в доказательстве остановки.
 Работа оформлена как альтернативное доказательство остановки для алгоритма,
 описанного в статье 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, доступной на сайте её автора, поэтому читатель предполагается хорошо знакомым
 с ней.
 Большинство используемой терминологии, включая названия этапов алгоритма,
 взято оттуда.
\end_layout

\begin_layout Subsubsection
Потенциально бесконечные циклы в F5
\end_layout

\begin_layout Paragraph
Процедура 
\family typewriter
AlgorithmF5
\family default
: увеличение 
\begin_inset Formula $d$
\end_inset


\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "iterations-d_grow"

\end_inset

Если при некоторых входных данных цикл 
\series bold
while
\series default
 внутри процедуры 
\family typewriter
AlgorithmF5
\family default
 выполняется бесконечное число раз, то значение 
\begin_inset Formula $d$
\end_inset

 неограниченно возрастает.
\end_layout

\begin_layout Proof
Предположим существование последовательности многочленов 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 в кольце 
\begin_inset Formula $\mathcal{K}[x_{1},\ldots,x_{n}]$
\end_inset

 для которой алгоритм F5 не завершается.
 Без ограничение общности будем считать что это самая короткая последовательност
ь такого рода -- алгоритм завершается на более короткой последовательности
 
\begin_inset Formula $\left\{ f_{2},\ldots,f_{m}\right\} $
\end_inset

.
 Это означает, что не завершается последняя итерация цикла внутри 
\family typewriter
incrementalF5
\family default
, то есть не завершается последний вызов процедуры 
\family typewriter
AlgorithmF5
\family default
.
 Для исследования данной ситуации необходимо понять, как ведёт себя значение
 полной степени 
\begin_inset Formula $d$
\end_inset

 в процессе выполнения цикла внутри процедуры 
\family typewriter
AlgorithmF5
\family default
.
 Обозначим за 
\begin_inset Formula $d_{j}$
\end_inset

 значение 
\begin_inset Formula $d$
\end_inset

 на 
\begin_inset Formula $j$
\end_inset

-ой итерации цикла и положим 
\begin_inset Formula $d_{0}=-1$
\end_inset

.
 Простейшее свойство 
\begin_inset Formula $d_{j}$
\end_inset

 -- неубывание: 
\begin_inset Formula $d_{j}\geqslant d_{j-1}$
\end_inset

.
 Оно выполняется, поскольку на 
\begin_inset Formula $j-1$
\end_inset

-ой итерации все многочлены в 
\begin_inset Formula $R_{d}$
\end_inset

 имеют степень 
\begin_inset Formula $d_{j-1}$
\end_inset

, и поэтому все вновь создаваемые критические пары имеют степень не менее
 
\begin_inset Formula $d_{j-1}$
\end_inset

.
 Предположим теперь, что 
\begin_inset Formula $j$
\end_inset

 фиксированный номер некоторой итерации.
 В начале итерации 
\begin_inset Formula $j$
\end_inset

 все критические пары степени 
\begin_inset Formula $d_{j}$
\end_inset

 извлекаются из 
\begin_inset Formula $P$
\end_inset

.
 После вызова процедуры 
\family typewriter
Reduction
\family default
 в 
\begin_inset Formula $P$
\end_inset

 добавляются некоторые новые критические пары в цикле, итерирующем по 
\begin_inset Formula $R_{d}$
\end_inset

.
 Существует возможность что некоторые из них будут иметь полную степень
 равную 
\begin_inset Formula $d_{j}$
\end_inset

.
 Нижеследующие рассуждения призваны показать, что все критические пары такой
 полной степени будут отброшены на следующей итерации алгоритма и ни одна
 из них не породит S-многочлен.
\end_layout

\begin_layout Proof
Для каждой из критических пар 
\begin_inset Formula $[t,u_{1},r_{1},u_{2,}r_{2}]$
\end_inset

 порождённых на итерации 
\begin_inset Formula $j$
\end_inset

 как минимум один из многочленов пары принадлежит 
\begin_inset Formula $R_{d}$
\end_inset

 и не более чем один многочлен из пары мог принадлежать 
\begin_inset Formula $G_{i}$
\end_inset

 на момент начала итерации.
 Все многочлены 
\begin_inset Formula $R_{d}$
\end_inset

 генерируются процедурой 
\family typewriter
Reduction
\family default
 путём добавления по одному многочлену к множеству 
\begin_inset Formula $Done$
\end_inset

.
 Поэтому, среди одного или двух многочленов критической пары, принадлежащих
 
\begin_inset Formula $R_{d}$
\end_inset

, мы можем выбрать многочлен 
\begin_inset Formula $r_{k}$
\end_inset

 добавленный в 
\begin_inset Formula $Done$
\end_inset

 позже.
 Тогда про другой многочлен S-пары 
\begin_inset Formula $r_{3-k}$
\end_inset

 можно утверждать, что он уже присутствовал в 
\begin_inset Formula $G\cup Done$
\end_inset

 к моменту добавления 
\begin_inset Formula $r_{k}$
\end_inset

 в 
\begin_inset Formula $Done$
\end_inset

.
 Поэтому процедура 
\family typewriter
TopReduction
\family default
 пыталась редуцировать 
\begin_inset Formula $r_{k}$
\end_inset

 по 
\begin_inset Formula $r_{3-k}$
\end_inset

, но не сделала этого, поскольку в функции 
\family typewriter
IsReducible
\family default
 одна из проверок (a) - (d) запретила это.
\end_layout

\begin_layout Proof
При этом для критических пар с полной степенью равной 
\begin_inset Formula $d_{j}$
\end_inset

 мы имеем 
\begin_inset Formula $u_{k}=1$
\end_inset

, поскольку полная степень критической пары равна полной степени её челна
 
\begin_inset Formula $r_{k}$
\end_inset

.
 Это означает, что значение 
\begin_inset Formula $u_{3-k}$
\end_inset

 равно 
\begin_inset Formula $\frac{\HM(r_{k})}{\HM(r_{3-k})}$
\end_inset

, поэтому в 
\family typewriter
IsReducible
\family default
 правило (a) разрешает редукцию 
\begin_inset Formula $r_{k}$
\end_inset

 по 
\begin_inset Formula $r_{3-k}$
\end_inset

.
 Получается, что только правила (b) - (d) могли запретить редукцию.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом (b).
 Это означает, что в 
\begin_inset Formula $G_{i+1}$
\end_inset

 существует многочлен, редуцирующий 
\begin_inset Formula $u_{3-k}\Sig(r_{3-k})$
\end_inset

.
 Для нашего случая отсюда следовало бы, что в функции 
\family typewriter
CritPair
\family default
 эквивалентная проверка 
\begin_inset Formula $\varphi(u_{3-k}\Sig(r_{3-k}))=u_{3-k}\Sig(r_{3-k})$
\end_inset

 запретила бы создание критической пары.
 Получается, что правило (b) также не могло запретить редукцию.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом (c).
 Это означает существование перезаписи для домноженного редуктора.
 В нашем случае это значит, что 
\family typewriter
Rewritten?
\family default

\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 показала наличие перезаписи в процессе выполнения 
\family typewriter
TopReduction
\family default
, и будет продолжать возвращать значение 
\begin_inset Quotes fld
\end_inset

Истина
\begin_inset Quotes frd
\end_inset

 на всех последующих этапах алгоритма, поскольку перезаписывающие многочлены
 не могут исчезнуть.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом (d).
 Псевдокод в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 несколько неясен в этом месте, но исходный код процедуры 
\family typewriter
FindReductor
\family default
, приложенный к 
\begin_inset CommandInset citation
LatexCommand cite
key "F5-revisited"

\end_inset

 достаточно ясен и утверждает, что редуктор отбрасывается, если одновременно
 моном и индекс сигнатуры совпадают для редуктора и редуцируемого многочлена
 (в коде 
\family typewriter
r[k0][1]
\family default
 -- моном сигнатуры, а 
\family typewriter
r[k0][2]
\family default
 -- её индекс):
\end_layout

\begin_layout Proof
\begin_inset listings
lstparams "basicstyle={\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (ut eq r[k0][1]) and (r[j][2] eq r[k0][2]) then
\end_layout

\begin_layout Plain Layout

	// discard reductor by criterion (d)
\end_layout

\begin_layout Plain Layout

	continue;
\end_layout

\begin_layout Plain Layout

end if;
\end_layout

\end_inset

В нашем случае это обозначает, что сигнатуры 
\begin_inset Formula $r_{k}$
\end_inset

 и 
\begin_inset Formula $u_{3-k}r_{3-k}$
\end_inset

 равны.
 Значит вызов 
\family typewriter
Rewritten?
\family default

\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 будет возвращать 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

 после добавления правила, соответствующего 
\begin_inset Formula $r_{k}$
\end_inset

, поскольку 
\begin_inset Formula $u_{3-k}\cdot r_{3-k}$
\end_inset

 перезаписывается 
\begin_inset Formula $1\cdot r_{k}$
\end_inset

.
 Получается, что как и в случае с правилом (c), 
\family typewriter
Rewritten?
\family default

\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 возвращает 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

 при выполнении 
\family typewriter
TopReduction
\family default
 и позже.
\end_layout

\begin_layout Proof
Теперь рассмотрим функцию 
\family typewriter
Spol
\family default
, выполняемую для некоторой S-пары полной степени 
\begin_inset Formula $d_{j}$
\end_inset

, сгенерированной на итерации 
\begin_inset Formula $j$
\end_inset

.
 Она выполняется внутри 
\begin_inset Formula $j+1$
\end_inset

 итерации цикла в 
\family typewriter
AlgorithmF5
\family default
, то есть уже после того, как закончилось выполнение 
\family typewriter
TopReduction
\family default
 для 
\begin_inset Formula $r_{k}$
\end_inset

.
 Поэтому для случаев (c) и (d) вызов 
\family typewriter
Rewritten?
\family default

\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 внутри 
\family typewriter
Spol
\family default
 вернёт 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

.
 Значит на итерации 
\begin_inset Formula $j+1$
\end_inset

 ни одна из S-пар полной степени 
\begin_inset Formula $d_{j}$
\end_inset

 не добавит многочлена в 
\begin_inset Formula $F$
\end_inset

.
\end_layout

\begin_layout Proof
Итого, получено: 
\end_layout

\begin_deeper
\begin_layout Itemize
первая возможность относительного расположения 
\begin_inset Formula $d_{j+1}$
\end_inset

 и 
\begin_inset Formula $d_{j}$
\end_inset

 -- их равенство: 
\begin_inset Formula $d_{j+1}=d_{j}$
\end_inset

.
 В этом случае 
\begin_inset Formula $F$
\end_inset

 оказывается пустым на итерации 
\begin_inset Formula $j+1$
\end_inset

, и, таким образом, 
\begin_inset Formula $P$
\end_inset

 не содержит ни одной пары с полной степенью 
\begin_inset Formula $d_{j}$
\end_inset

 после того как итерация 
\begin_inset Formula $j+1$
\end_inset

 завершится.
 Значит 
\begin_inset Formula $d_{j+2}>d_{j+1}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Другая возможность относительного расположения -- строгое возрастание 
\begin_inset Formula $d_{j+1}>d_{j}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Вместе эти факты дают 
\begin_inset Formula $\forall j\,\, d_{j+2}>d_{j}$
\end_inset

, что доказывает утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterations-d_grow"

\end_inset

.
\end_layout

\begin_layout Paragraph
Процедура 
\family typewriter
Reduction
\family default
: конечность 
\begin_inset Formula $ToDo$
\end_inset


\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "Every_cycle_iteration_finish"

\end_inset

Каждая итерация цикла внутри процедуры 
\family typewriter
AlgorithmF5
\family default
 останавливается, в частности останавливаются все вызовы процедуры 
\family typewriter
Reduction
\family default
.
\end_layout

\begin_layout Proof
Факт остановки известен для вызовов 
\family typewriter
AlgorithmF5
\family default
, соответствующих многочленам 
\begin_inset Formula $f_{2},\dots,f_{m}$
\end_inset

, поэтому будет рассматриваться лишь один оставшийся вызов 
\family typewriter
AlgorithmF5
\family default
, обрабатывающий первый элемент входного набора многочленов 
\begin_inset Formula $f_{1}$
\end_inset

.
 Вначале покажем несколько общих утверждений о многочленах в множествах
 
\begin_inset Formula $ToDo$
\end_inset

 и 
\begin_inset Formula $Rule$
\end_inset

 в процессе 
\begin_inset Formula $j$
\end_inset

-ой итераций цикла внутри этого вызова 
\family typewriter
AlgorithmF5
\family default
.
 Старшая по сигнатуре часть S-пары всех критических пар, добавляемых функцией
 
\family typewriter
CritPair
\family default
 вначале выполнения 
\family typewriter
AlgorithmF5
\family default
, обладает индексом сигнатуры, равным 
\begin_inset Formula $1$
\end_inset

.
 Все прочие критические пары порождаются с индексом сигнатуры, соответствующим
 некоторому отмеченному многочлену, перемещённому из множества 
\begin_inset Formula $ToDo$
\end_inset

 в множество 
\begin_inset Formula $Done$
\end_inset

.
 В свою очередь все элементы 
\begin_inset Formula $ToDo$
\end_inset

 создаются или на основе критических пар или внутри процедуры 
\family typewriter
TopReduction
\family default
.
 Многочлены, генерируемые 
\family typewriter
TopReduction
\family default
 имеют сигнатуру, превышающую сигнатуру многочлена, который редуцирует данный
 вызов процедуры, и который является элементом 
\begin_inset Formula $ToDo$
\end_inset

.
 Поэтому многочлен или критическая пара с индексом сигнатуры, отличным от
 1 не могут появиться в рассматриваемом вызове 
\family typewriter
AlgorithmF5
\family default
.
 С другой стороны, все многочлены в 
\begin_inset Formula $ToDo$
\end_inset

 имеют одну и ту же полную степень 
\begin_inset Formula $d_{j}$
\end_inset

.
 Вместе с единичностью индексов это позволяет заключить, что полная степень
 мономов сигнатур равна 
\begin_inset Formula $d_{j}-\totaldeg(f_{1})$
\end_inset

 для всех элементов 
\begin_inset Formula $ToDo$
\end_inset

.
\end_layout

\begin_layout Proof
Каждое добавление элемента в массив 
\begin_inset Formula $Rule$
\end_inset

 соответствует добавлению в множество 
\begin_inset Formula $ToDo$
\end_inset

.
 Поэтому, элементы добавляемые в 
\begin_inset Formula $Rule$
\end_inset

 на итерации 
\begin_inset Formula $j$
\end_inset

 имеют полную степень равную 
\begin_inset Formula $d_{j}$
\end_inset

.
 Вспоминая неубывание 
\begin_inset Formula $d_{j}$
\end_inset

 получаем, что на 
\begin_inset Formula $j$
\end_inset

-ой итерации все элементы 
\begin_inset Formula $Rule$
\end_inset

 с индексом сигнатуры 1 имеют полную степень 
\begin_inset Formula $\leqslant d_{j}$
\end_inset

 и полную степень монома сигнатуры 
\begin_inset Formula $\leqslant d_{j}-\totaldeg(f_{1})$
\end_inset

.
 Также это даёт информацию о порядке элементов 
\begin_inset Formula $Rule$
\end_inset

 с сигнатурой 1: их полная степень не убывает.
\end_layout

\begin_deeper
\begin_layout Definition
Редукция отмеченного многочлена 
\begin_inset Formula $r_{k}$
\end_inset

 по отмеченному многочлену 
\begin_inset Formula $r_{m}$
\end_inset

 называется
\emph on
 сигнатурной редукцией,
\emph default
 если 
\begin_inset Formula $\Sig(r_{k})\succ t\cdot\Sig(r_{m})$
\end_inset

, где 
\begin_inset Formula $t=\frac{\HM(r_{k})}{\HM(r_{m})}$
\end_inset

 -- моном, на который умножается редуктор.
 Редуктор, соответствующий такой редукции называется 
\emph on
сигнатурным редуктором
\emph default
.
 
\end_layout

\end_deeper
\begin_layout Proof
Алгоритм производит только сигнатурные редукции: процедура 
\family typewriter
TopReduction
\family default
 производит редукцию по неотброшенному редуктору, если он сигнатурный, и
 добавляет элемент в 
\begin_inset Formula $ToDo$
\end_inset

 в противном случае.
 Элементы 
\begin_inset Formula $ToDo$
\end_inset

 обрабатываются в порядке возрастания сигнатур, поэтому ни один из элементов
 
\begin_inset Formula $G\cup Done$
\end_inset

 не может иметь сигнатуры, превышающей сигнатуру многочлена 
\begin_inset Formula $r_{k}$
\end_inset

, редуцируемого в 
\family typewriter
TopReduction
\family default
.
 Рассмотрим неотброшенный проверками редуктор 
\begin_inset Formula $r_{m}$
\end_inset

.
 Если он имеет полную степень 
\begin_inset Formula $\totaldeg(r_{m})=\totaldeg(r_{k})$
\end_inset

, мы получаем свойства 
\begin_inset Formula $t=1$
\end_inset

 и 
\begin_inset Formula $\Sig(r_{k})\succ\Sig(r_{m})$
\end_inset

, гарантирующие что редукция по нему будет сигнатурной.
 Случай 
\begin_inset Formula $\Sig(r_{k})=\Sig(r_{m})$
\end_inset

 невозможен, поскольку такие редукторы отбрасываются в правиле (d) процедуры
 
\family typewriter
IsReducible
\family default
.
 Таким образом, ситуация 
\begin_inset Formula $\Sig(r_{k})\prec t\cdot\Sig(r_{m})$
\end_inset

 возможна только при 
\begin_inset Formula $\totaldeg(r_{m})<\totaldeg(r_{k})$
\end_inset

 и все добавления в 
\begin_inset Formula $ToDo$
\end_inset

 в процессе 
\family typewriter
TopReduction
\family default
 соответствуют этому случаю.
 Моном сигнатуры многочлена, добавляемого таким образом, равен 
\begin_inset Formula $t\cdot\Sig(r_{m})$
\end_inset

 и тот факт что 
\begin_inset Formula $r_{m}$
\end_inset

 не был отброшен проверкой правила 
\family typewriter
Rewritten?
\family default
 внутри 
\family typewriter
IsReducible
\family default
 гарантирует, что ни одного многочлена с сигнатурой 
\begin_inset Formula $t\Sig(r_{m})$
\end_inset

 не было порождено, потому что иначе такой многочлен имел бы связанное с
 ним правило в 
\begin_inset Formula $Rule$
\end_inset

 с большей полной степенью, чем правило, соответствующее 
\begin_inset Formula $r_{m}$
\end_inset

, и 
\begin_inset Formula $r_{m}$
\end_inset

 был бы отброшен в 
\family typewriter
IsReducible
\family default
.
 
\end_layout

\begin_layout Proof
Мы хотим показать, что единственная возможность отсутствия остановки алгоритма
 соответствует случая неограниченного возрастания 
\begin_inset Formula $d_{j}$
\end_inset

.
 Мы показали, что отсутствие остановки алгоритма происходит в случае, когда
 не завершается вызов 
\family typewriter
AlgorithmF5
\family default
, и что он не может зациклиться обрабатывая бесконечное число итераций итерации
 с одним и тем же значением 
\begin_inset Formula $d$
\end_inset

.
 Остаются два варианта: неограниченное возрастание 
\begin_inset Formula $d$
\end_inset

 и зацикливание внутри одной из итераций с фиксированным значением.
 Далее показано, что такое зацикливание невозможно.
 Процедура 
\family typewriter
AlgorithmF5
\family default
 содержит 3 цикла помимо главного:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
for
\series default
-цикл внутри 
\family typewriter
Spol
\family default
 завершается, поскольку число его итераций ограничено числом критических
 пар к моменту начала выполнения цикла;
\end_layout

\begin_layout Itemize

\series bold
for
\series default
-цикл внутри 
\family typewriter
AlgorithmF5
\family default
 проходит по элементам 
\begin_inset Formula $R_{d}$
\end_inset

 и также завершается, поскольку число элементов 
\begin_inset Formula $R_{d}$
\end_inset

 зафиксировано к моменту начала выполнения цикла;
\end_layout

\begin_layout Itemize
наиболее сложный случай соответствует 
\series bold
while
\series default
-циклу внутри 
\family typewriter
процедуры Reduction
\family default
, который выполняется до тех пор, пока множество 
\begin_inset Formula $ToDo$
\end_inset

 не станет пустым.
 Множество 
\begin_inset Formula $ToDo$
\end_inset

 изначально заполняется процедурой 
\family typewriter
Spol
\family default
 и потом дополняется новыми элементами в процессе выполнения 
\family typewriter
TopReduction
\family default
.
 Процедура 
\family typewriter
Spol
\family default
 порождает конечное число элементов, поскольку она завершается, а все элементы
 добавляемые 
\family typewriter
TopReduction
\family default
 имеют различные сигнатуры индекса 1, поэтому их число ограничено числом
 различных сигнатур полной степени 
\begin_inset Formula $d_{j}-\totaldeg(f_{1})$
\end_inset

, поэтому в 
\begin_inset Formula $ToDo$
\end_inset

 добавляется лишь конечное число элементов.
 Теперь мы покажем, что все типы шагов, происходящих внутри 
\family typewriter
Reduction
\family default
 могут быть выполнены лишь конечное число раз:
\end_layout

\begin_deeper
\begin_layout Itemize
шаг, на котором 
\family typewriter
IsReducible
\family default
 возвращает пустое множество, соответствует переносу элемента множества
 
\begin_inset Formula $ToDo$
\end_inset

 в 
\begin_inset Formula $Done$
\end_inset

 и число таких шагов ограничено числом элементов, добавляемых в 
\begin_inset Formula $ToDo$
\end_inset


\end_layout

\begin_layout Itemize
шаг, на котором 
\family typewriter
IsReducible
\family default
 возвращает не сигнатурный редуктор, соответствует добавлению нового элемента
 в 
\begin_inset Formula $ToDo$
\end_inset

 и число таких шагов ограничено числом возможных добавлений
\end_layout

\begin_layout Itemize
шаг, на котором 
\family typewriter
IsReducible
\family default
 возвращает сигнатурный редуктор, соответствует редукции одного из элементов
 
\begin_inset Formula $ToDo$
\end_inset

.
 Это может произойти лишь конечное число раз, поскольку в 
\begin_inset Formula $ToDo$
\end_inset

 добавляется конечное число многочленов и не может существовать бесконечной
 цепочки редукций для одного многочлена, поскольку в процессе редукции его
 старший моном 
\begin_inset Formula $\HM$
\end_inset

 строго 
\begin_inset Formula $\prec$
\end_inset

-убывает, а множество мономов вполне упорядочено по 
\begin_inset Formula $\prec$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Мы получили, что все циклы внутри процедуры 
\family typewriter
AlgorithmF5
\family default
, кроме главного, завершаются, что доказывает утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "Every_cycle_iteration_finish"

\end_inset

.
\end_layout

\begin_layout Standard
Отсюда получается следующий факт о поведении алгоритма в ситуации, когда
 он не завершается:
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "d-does-grow"

\end_inset

Если алгоритм не завершается на некоторых входных данных, то значение 
\begin_inset Formula $d$
\end_inset

 неограниченно возрастает в процессе итераций.
\end_layout

\begin_layout Proof
Следует из комбинирования утверждений 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterations-d_grow"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "Every_cycle_iteration_finish"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Цепи S-пар
\end_layout

\begin_layout Standard
Утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "d-does-grow"

\end_inset

 показывает, что в случае отсутствия остановки работа алгоритма приводит
 к появлению бесконечной последовательности ненулевых отмеченных многочленов
 с неограниченно возрастающей полной степенью, добавляемых в 
\begin_inset Formula $G_{i}$
\end_inset

.
 То есть, в этом случае алгоритм порождает бесконечную последовательность
 отмеченных многочленов 
\begin_inset Formula $\left\{ r_{1},r_{2},\ldots,r_{m},\ldots,r_{l},\ldots\right\} $
\end_inset

, в которой 
\begin_inset Formula $r_{1},\ldots,r_{m}$
\end_inset

 соответствуют 
\begin_inset Formula $m$
\end_inset

 исходным многочленам, а остальные были получены в процедурах 
\family typewriter
Spol
\family default
 и 
\family typewriter
TopReduction
\family default
.
 В обоих случаях новый элемент 
\begin_inset Formula $r_{l}$
\end_inset

 порождается как S-многочлен двух уже ранее добавленных в последовательность
 многочленов.
 Будем обозначать за 
\begin_inset Formula $l^{*}$
\end_inset

 и 
\begin_inset Formula $l_{*}$
\end_inset

 позиции многочленов, использовавшихся для генерации 
\begin_inset Formula $l$
\end_inset

-го многочлена последовательности и за 
\begin_inset Formula $\overline{u_{l}}$
\end_inset

, 
\begin_inset Formula $\underline{u_{l}}$
\end_inset

 мономы, на которые они умножались.
 При этом 
\begin_inset Formula $l^{*}$
\end_inset

 соответствует части с большей сигнатурой: 
\begin_inset Formula $\poly(r_{l})=\overline{u_{l}}\poly(r_{l^{*}})-\underline{u_{l}}\poly(r_{l_{*}})$
\end_inset

 и 
\begin_inset Formula $\Sig(r_{l})=\overline{u_{l}}\Sig(r_{l^{*}})\succ\underline{u_{l}}\Sig(r_{l_{*}})$
\end_inset

.
 Значение 
\begin_inset Formula $\poly(r_{l})$
\end_inset

 может меняться в процедуре 
\family typewriter
TopReduction
\family default
 на многочлен с меньшим 
\begin_inset Formula $\HM$
\end_inset

, но 
\begin_inset Formula $\Sig(r_{l})$
\end_inset

 нигде далее не меняется после добавления многочлена в последовательность.
 Далее, будем пытаться найти бесконечную подпоследовательность 
\begin_inset Formula $\left\{ r_{k_{1}},r_{k_{2}},\ldots,r_{k_{n}},\ldots\right\} $
\end_inset

 в этой последовательности, обладающую свойством, что 
\begin_inset Formula $r_{k_{n}}$
\end_inset

 является S-многочленом 
\begin_inset Formula $r_{k_{n-1}}=r_{k_{n}^{*}}$
\end_inset

 и некоторого другого многочлена меньшей сигнатуры.
 То есть 
\begin_inset Formula $\Sig(r_{k_{n}})=\overline{u_{k_{n}}}\Sig(r_{k_{n-1}})$
\end_inset

, откуда вытекает делимость: 
\begin_inset Formula 
\begin{equation}
\Sig(r_{k_{n-1}})|\Sig(r_{k_{n}}).\label{eq:s-pair-chain-def}
\end{equation}

\end_inset


\end_layout

\begin_layout Definition
Конечную или бесконечную последовательность, соседние элементы которой удовлетво
ряют свойству 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:s-pair-chain-def"

\end_inset

 будем называть 
\emph on
цепью S-пар
\emph default
.
\end_layout

\begin_layout Standard
Каждый порождаемый многочлен 
\begin_inset Formula $r_{l}$
\end_inset

 имеет конечную цепь S-пар, оканчивающуюся этим многочленом.
 Эта цепь может быть последовательно построена, начиная с последнего элемента
\begin_inset Formula $r_{l}$
\end_inset

, если на каждом шаге переходить от текущего многочлена 
\begin_inset Formula $r_{n}$
\end_inset

 к многочлену 
\begin_inset Formula $r_{n^{*}}$
\end_inset

, который использовался при генерации 
\begin_inset Formula $r_{n}$
\end_inset

 как S-многочлена.
 Результирующая цепь S-пар имеет вид 
\begin_inset Formula $\{r_{q},\ldots,r_{l^{**}},r_{l^{*}},r_{l}\}$
\end_inset

, где все многочлены имеют одинаковый индекс сигнатуры 
\begin_inset Formula $q=\sigidx(r_{l})$
\end_inset

 и первый элемент является входным многочленом этого индекса.
\end_layout

\begin_layout Standard
Первое свойство цепей S-пар основано на критерии перезаписи и заключается
 в следующей теореме.
\end_layout

\begin_layout Theorem
Любой отмеченный многочлен может являться начальным элементом лишь конечного
 числа различных цепей S-пар длины 2.
\end_layout

\begin_layout Proof
Алгоритм 
\family typewriter
AlgorithmF5
\family default
 считает S-многочлены в двух местах: процедуре 
\family typewriter
SPol
\family default
 и процедуре 
\family typewriter
TopReduction
\family default
.
 Важно заметить, что в обоих случаях проверка 
\family typewriter
Rewritten?
\family default
 для части S-многочлена с большей сигнатурой выполняется непосредственно
 перед созданием S-многочлена.
 В первом случае такая проверка производится в самой 
\family typewriter
SPol
\family default
, а в 
\family typewriter
TopReduction
\family default
 проверка присутствует в вызове 
\family typewriter
IsReducible
\family default
.
 И в обоих случаях получаемый S-многочлен немедленно добавляется в список
 
\begin_inset Formula $Rule$
\end_inset

 последним элементом.
 Поэтому, в момент построения S-многочлена с сигнатурой 
\begin_inset Formula $s$
\end_inset

 можно утверждать, что старшая часть S-пары соответствует последнему из
 правил с сигнатурой, делящей 
\begin_inset Formula $s$
\end_inset

 -- она даже может быть найдена исходя лишь из списка 
\begin_inset Formula $Rule$
\end_inset

 и сигнатуры 
\begin_inset Formula $s$
\end_inset

 без знания какой-либо ещё информации об алгоритме.
\end_layout

\begin_layout Proof
Рассмотрим произвольный отмеченный многочлен 
\begin_inset Formula $r_{L}$
\end_inset

 с сигнатурой 
\begin_inset Formula $\Sig(r_{L})=s$
\end_inset

 и упорядоченное по порядку добавления подмножество 
\begin_inset Formula $\{r_{l_{1}},\ldots,r_{l_{i}},\ldots\}$
\end_inset

 отмеченных многочленов с сигнатурами удовлетворяющими условию 
\begin_inset Formula $\Sig(r_{l_{i}})=v_{i}\Sig(r_{L})$
\end_inset

.
 С точки зрения делимости любая из потенциально бесконечного числа пар 
\begin_inset Formula $\{r_{L},r_{l_{i}}\}$
\end_inset

 может быть цепью S-пар длины 2.
 Но идеал 
\begin_inset Formula $\left(v_{1},\ldots,v_{i},\ldots\right)$
\end_inset

 в 
\begin_inset Formula $\mathbb{T}$
\end_inset

 является конечно порождённым по лемме Диксона, поэтому после некоторого
 шага 
\begin_inset Formula $i_{0}$
\end_inset

 будет выполняться 
\begin_inset Formula $\forall i>i_{0}\,\exists j\leqslant i_{0}$
\end_inset

 такое что 
\begin_inset Formula $v_{j}|v_{i}$
\end_inset

.
 Поэтому при 
\begin_inset Formula $\forall i>i_{0}$
\end_inset

 последовательность 
\begin_inset Formula $\{r_{L},r_{l_{i}}\}$
\end_inset

 не может являться цепью S-пар, поскольку 
\begin_inset Formula $\Sig(r_{L})\cdot v_{i}$
\end_inset

 перезаписывается 
\begin_inset Formula $\Sig(r_{l_{j}})\cdot\frac{v_{i}}{v_{j}}$
\end_inset

 и существует не более чем 
\begin_inset Formula $i_{0}$
\end_inset

 цепей S-пар длины 2, начинающихся с многочлена 
\begin_inset Formula $r_{L}$
\end_inset

.
\end_layout

\begin_layout Definition
Конечное множество концов цепей S-пар длины 2, начинающихся с 
\begin_inset Formula $r_{L}$
\end_inset

 будет называться 
\emph on
множеством S-порождённых
\emph default
 
\begin_inset Formula $r_{L}$
\end_inset

.
\end_layout

\begin_layout Theorem
Если алгоритм не останавливается на некоторых входных данных, то он порождает
 бесконечную цепь S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

.
\end_layout

\begin_layout Proof
Поскольку при работе с понятием бесконечности требуется некоторая строгость,
 дадим следующее определение.
\end_layout

\begin_deeper
\begin_layout Definition
Отмеченный многочлен 
\begin_inset Formula $r_{l}$
\end_inset

 называется 
\emph on
генератором цепи S-пар
\emph default
, если существует бесконечное множество различных конечных цепей S-пар,
 начинающихся с 
\begin_inset Formula $r_{l}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Если алгоритм не останавливается, то многочлен входного множества 
\begin_inset Formula $r_{1}=(1\mathbf{F}_{1},f_{1})$
\end_inset

 является генератором цепи S-пар, поскольку каждый многочлен 
\begin_inset Formula $r_{l}$
\end_inset

, порождаемый в последнем не завершающемся вызове 
\family typewriter
AlgorithmF5
\family default
 имеет индекс сигнатуры 1 и является концом цепи S-пар
\begin_inset Formula $\{r_{1},\ldots,r_{l^{**}},r_{l^{*}},r_{l}\}$
\end_inset

.
\end_layout

\begin_layout Proof
Теперь предположим, что про некоторый отмеченный многочлен 
\begin_inset Formula $r_{l}$
\end_inset

 известно, что он является генератором цепи S-пар.
 Один из конечного множества S-порождённых 
\begin_inset Formula $r_{l}$
\end_inset

 также должен являться генератором цепи S-пар, поскольку в противном случае
 число различных цепей, исходящих из 
\begin_inset Formula $r_{l}$
\end_inset

, было бы ограничено конечной суммой конечных количеств цепей, выходящих
 из S-порождённых плюс конечным количеством цепей длины 2, выходящих из
 
\begin_inset Formula $r_{l}$
\end_inset

.
 Поэтому, если отмеченный многочлен 
\begin_inset Formula $r_{l}$
\end_inset

 является генератором цепи S-пар, среди его S-порождённых всегда может быть
 выбран другой генератор цепи S-пар.
 Таким образом может быть построена бесконечная цепь S-пар, начинающаяся
 
\begin_inset Formula $r_{1}$
\end_inset

 и состоящая из генераторов, что доказывает теорему.
\end_layout

\begin_layout Standard
Для следующей теоремы необходимо ввести порядок на частных, образованных
 мономами, путём транзитивного расширения порядка на мономах: 
\begin_inset Formula $\frac{m_{1}}{m_{2}}\succ_{q}\frac{m_{3}}{m_{4}}\Leftrightarrow m_{1}m_{4}\succ m_{3}m_{2}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:f_g_3_props"

\end_inset

Если алгоритм не останавливается на некоторых входных данных, то после некоторог
о конечного шага множество 
\begin_inset Formula $G$
\end_inset

 содержит пару отмеченных многочленов 
\begin_inset Formula $f',f$
\end_inset

, причём 
\begin_inset Formula $f$
\end_inset

 сгенерирован после 
\begin_inset Formula $f'$
\end_inset

 и выполняются следующие 3 свойства:
\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\HM(f')|\HM(f),
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\frac{\HM(f')}{\Sig(f')}\succ_{q}\frac{\HM(f)}{\Sig(f)},
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\Sig(f')|\Sig(f).
\]

\end_inset


\end_layout

\begin_layout Proof
При работе с цепями S-пар является важным тот факт, что многочлен никогда
 не редуцируется дальше, после того как он был использован для создания
 S-пары в качестве старшей по сигнатуре части.
 Факт выполняется, поскольку все многочлены, которые ещё могут быть подвергнуты
 редукции находятся в множестве 
\begin_inset Formula $ToDo$
\end_inset

, а все многочлены, используемые как старшая часть S-пары, находятся в 
\begin_inset Formula $G$
\end_inset

 или в 
\begin_inset Formula $Done$
\end_inset

.
 Поэтому многочлен 
\begin_inset Formula $h_{n}$
\end_inset

, предшествующий многочлену 
\begin_inset Formula $h_{n+1}$
\end_inset

 в цепи S-пар, сохраняет одно и то же значение 
\begin_inset Formula $\poly(h_{n})$
\end_inset

 после того как был использован для создания какой-либо S-пары.
 И можно утверждать, что выполняется равенство 
\begin_inset Formula 
\[
\poly(h_{n+1})=c\frac{\Sig(h_{n+1})}{\Sig(h_{n})}\poly(h_{n})+g_{n},
\]

\end_inset

, где 
\begin_inset Formula $g_{n}$
\end_inset

 -- многочлен, соответствующей младшей части S-пары, использованный при
 генерации 
\begin_inset Formula $h_{n+1}$
\end_inset

 из 
\begin_inset Formula $h_{n}$
\end_inset

, удовлетворяющее следующему:
\begin_inset Formula 
\begin{equation}
\HM(h_{n+1})\prec\HM\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)=\HM(g_{n}),\,\Sig(h_{n+1})=\Sig\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)\succ\Sig(g_{n}).\label{eq:spair-chain}
\end{equation}

\end_inset

Из первого неравенства в 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:spair-chain"

\end_inset

 получаем, что 
\begin_inset Formula $\frac{\HM(h_{n})}{\Sig(h_{n})}\succ_{q}\frac{\HM(h_{n+1})}{\Sig(h_{n+1})}$
\end_inset

, поэтому в цепи S-пар частные 
\begin_inset Formula $\frac{\HM(h_{i})}{\Sig(h_{i})}$
\end_inset

 строго убывают в смысле порядка на частных.
 Этот факт не может быть напрямую использован для доказательства конечности
 цепей, поскольку порядок на частных, в отличии от порядка на мономах, не
 даёт вполне упорядоченности: к примеру последовательность 
\begin_inset Formula $\frac{x}{x}\succ_{q}\frac{x}{x^{2}}\succ_{q}\cdots\succ_{q}\frac{x}{x^{n}}>_{q}\cdots$
\end_inset

 является бесконечно убывающей.
\end_layout

\begin_layout Proof
Существует две возможности для отношения между 
\begin_inset Formula $\HM$
\end_inset

 соседних элементов.
 Известно, что 
\begin_inset Formula $\Sig(h_{n})|\Sig(h_{n+1})$
\end_inset

, поэтому они или имеют равные сигнатуры, или 
\begin_inset Formula $\totaldeg(h_{n})<\totaldeg(h_{n+1})$
\end_inset

.
 В первом случае 
\begin_inset Formula $\HM(h_{n+1})\prec\HM(h_{n})$
\end_inset

 при равенстве полной степени, а во втором -- 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(h_{n+1})\succ\HM(h_{n})$
\end_inset

, поскольку полные степени 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\HM$
\end_inset

 отличаются
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
 Поэтому, последовательность
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\HM$
\end_inset

 элементов бесконечной цепи S-пар состоит из блоков с фиксированной полной
 степенью, где 
\begin_inset Formula $\HM$
\end_inset

 внутри блока строго убывают.
 Длины блоков могут быть равными единице, и полные степени блоков возрастают.
 Это приводит к следующим свойствам: цепь S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

 не может содержать элементов с равными 
\begin_inset Formula $\HM$
\end_inset

 и 
\begin_inset Formula $\HM(h_{i})|\HM(h_{j})$
\end_inset

 возможно только в случае 
\begin_inset Formula $i<j$
\end_inset

 и 
\begin_inset Formula $\totaldeg(h_{i})<\totaldeg(h_{j})$
\end_inset

.
\end_layout

\begin_layout Proof
Это позволяет использовать метод аналогичный используемому в Предложении
 14 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

: рассмотрим 
\begin_inset Formula $\HM$
\end_inset

 бесконечной цепи S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

.
 Они порождают бесконечную последовательность в 
\begin_inset Formula $\mathbb{T}$
\end_inset

, поэтому по лемме Диксона существует два многочлена, с 
\begin_inset Formula $\HM(h_{i})|\HM(h_{j})$
\end_inset

.
 Из предыдущего абзаца следует, что при этом 
\begin_inset Formula $i<j$
\end_inset

, а при помощи свойств цепи S-пар мы получаем, что 
\begin_inset Formula $\Sig(h_{i})|\Sig(h_{i+1})|\cdots|\Sig(h_{j})$
\end_inset

 и 
\begin_inset Formula $\frac{\HM(h_{i})}{\Sig(h_{i})}\succ_{q}\frac{\HM(h_{i+1})}{\Sig(h_{i+1})}\succ_{q}\cdots\succ_{q}\frac{\HM(h_{j})}{\Sig(h_{j})}$
\end_inset

, поэтому можно взять 
\begin_inset Formula $f'=h_{i}$
\end_inset

 и 
\begin_inset Formula $f=h_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
Последнее свойство о делимости сигнатур из утверждения теоремы является
 побочным эффектом от использования цепей S-пар и не используется в дальнейшем.
 При этом первые два свойства используются для построения сигнатурного редуктора.
\end_layout

\begin_layout Fact
Если никакие многочлены не были отброшены проверками критериев (b) и (c)
 в 
\family typewriter
IsReducible
\family default
, рассматриваемый алгоритм завершается.
\end_layout

\begin_layout Proof
Данное выше доказательство теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 не опирается на соответствие между порядками на сигнатурах и мономах многочлено
в.
 Но алгоритм F5 использует один и тот же порядок в обоих случаях, и теперь
 мы можем воспользоваться этим фактом и переформулировать отношение на частных
 мономов из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 в отношение на сигнатурах: 
\begin_inset Formula 
\[
\Sig(f)\succ t\cdot\Sig(f'),\mbox{ где }t=\frac{\HM(f)}{\HM(f')}\in\mathbb{T}.
\]

\end_inset

Это неравенство вместе с делимостью 
\begin_inset Formula $\HM$
\end_inset

 из утверждения теоремы показывает, что 
\begin_inset Formula $tf'$
\end_inset

 является редуктором для 
\begin_inset Formula $f$
\end_inset

 в 
\family typewriter
TopReduction
\family default
 с точки зрения сигнатуры -- он проходит проверки (a) и (d) внутри 
\family typewriter
IsReducible
\family default
 и его сигнатура меньше.
 При отсутствии проверки критериев (b) и (c) это напрямую приводило бы к
 противоречию, так как в момент добавления 
\begin_inset Formula $f$
\end_inset

 в 
\begin_inset Formula $G$
\end_inset

 отмеченный многочлен 
\begin_inset Formula $f'$
\end_inset

 уже был там и процедура 
\family typewriter
TopReduction
\family default
 должна была бы редуцировать 
\begin_inset Formula $f$
\end_inset

 по 
\begin_inset Formula $f'$
\end_inset

.
\end_layout

\begin_layout Standard
Но существование критериев делает возможной ситуацию, в которой 
\begin_inset Formula $tf'$
\end_inset

 отбрасывается проверками (b) или (c) процедуры 
\family typewriter
IsReducible
\family default
.
 Идея дальнейших рассуждений состоит в том, чтобы показать что в этом случае
 может быть найден другой сигнатурный редуктор 
\begin_inset Formula $f$
\end_inset

, который не будет отброшен проверками и таким образом прийти к противоречию.
 Последующие главы работы посвящены этому.
\end_layout

\begin_layout Subsubsection
S-пары с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset


\end_layout

\begin_layout Standard
В этой и последующих частях 
\begin_inset Formula $g$
\end_inset

 подразумевается некоторым фиксированным многочленом с индексом сигнатуры
 1, добавленным на некоторой итерации алгоритма в 
\begin_inset Formula $Done$
\end_inset

.
 Мы будем анализировать состояние алгоритма в момент непосредственно предшествую
щий добавлению 
\begin_inset Formula $g$
\end_inset

 в 
\begin_inset Formula $Done$
\end_inset

 в вызове 
\family typewriter
AlgorithmF5
\family default
 с 
\begin_inset Formula $i=1$
\end_inset

.
 Рассмотрим в этот момент конечное множество 
\begin_inset Formula $G_{1}\cup Done$
\end_inset

.
 Оно состоит из чисел, являющихся позициями отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, поэтому его элементы могут быть упорядочены в соответствии с позицией
 в 
\begin_inset Formula $R$
\end_inset

 и оно окажется записанным в виде упорядоченной последовательности целых
 чисел 
\begin_inset Formula $G_{g}=\{b_{1},\ldots,b_{N}\}$
\end_inset

 с 
\begin_inset Formula $b_{j}<b_{j+1}$
\end_inset

.
 Необходимо отметить, что этот порядок соответствует порядку отмеченных
 многочленов в последовательности, получаемой склеиванием массивов правил
 
\begin_inset Formula $Rule[m]:Rule[m-1]:\cdots:Rule[1]$
\end_inset

, поскольку добавление нового многочлена в 
\begin_inset Formula $R$
\end_inset

 всегда сопровождается добавлением соответствующего правила.
 Но этот порядок может отличаться от порядка в котором многочлены добавлялись
 в множество 
\begin_inset Formula $G_{1}\cup Done$
\end_inset

, поскольку многочлены одной полной степени добавляются в 
\begin_inset Formula $Done$
\end_inset

 в порядке возрастания сигнатуры, при том что добавление многочленов одной
 полной степени в 
\begin_inset Formula $R$
\end_inset

 производится в довольно случайном порядке в процедурах 
\family typewriter
Spol
\family default
 и 
\family typewriter
TopReduction
\family default
.
 Далее для простоты мы будем говорить о отмеченных многочленах 
\begin_inset Formula $b_{j}$
\end_inset

 в 
\begin_inset Formula $G_{g}$
\end_inset

, подразумевая что 
\begin_inset Formula $G_{g}$
\end_inset

 является не упорядоченным списком позиций, а упорядоченным списком отмеченных
 многочленов, расположенных на этих позициях.
 В этой терминологии можно сказать, что все входные многочлены 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 присутствуют в 
\begin_inset Formula $G_{g}$
\end_inset

, поскольку они присутствуют в 
\begin_inset Formula $G_{1}$
\end_inset

 в момент его создания.
\end_layout

\begin_layout Standard
S-пары могут обрабатываться в алгоритме различным путями, но главный факт,
 описывающий порядок их обработки выражается следующими свойствами, соответствую
щими свойствам, использованным в Теореме 21 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

, но рассматриваются на произвольной итерации алгоритма, а не после его
 остановки.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exist-gg-repr"

\end_inset

К моменту добавления 
\begin_inset Formula $g$
\end_inset

 в 
\begin_inset Formula $Done$
\end_inset

 каждая S-пара элементов 
\begin_inset Formula $G_{g}$
\end_inset

, сигнатура которой меньше 
\begin_inset Formula $\Sig(g)$
\end_inset

, удовлетворяет одному из трёх свойств:
\end_layout

\begin_layout Enumerate
S-пара имеет часть, которая была отброшена критерием проверки нормальной
 формы 
\begin_inset Formula $\varphi$
\end_inset

 (в 
\family typewriter
CritPair
\family default
 или в 
\family typewriter
IsReducible
\family default
).
 Такие S-пары будут называться 
\emph on
S-парами с частью, удовлетворяющей критерию F5
\emph default
.
 
\end_layout

\begin_layout Enumerate
S-пара имеет часть, которая была отброшена проверкой 
\family typewriter
Rewritten?
\family default
 (в 
\family typewriter
SPol
\family default
 или в 
\family typewriter
IsReducible
\family default
).
 Такие S-пары будут называться 
\emph on
S-парами с частью, удовлетворяющей критерию Перезаписи
\emph default
.
\end_layout

\begin_layout Enumerate
S-пара не была отброшена, поэтому её S-многочлен был сигнатурно редуцирован
 по некоторым элементам 
\begin_inset Formula $G_{g}$
\end_inset

 и результат был добавлен как элемент 
\begin_inset Formula $G_{g}$
\end_inset

.
 Такие S-пары будут называться 
\emph on
S-парами с известным 
\begin_inset Formula $G_{g}$
\end_inset

-представлением
\emph default
.
\end_layout

\begin_layout Proof
S-пары элементов 
\begin_inset Formula $G_{g}$
\end_inset

 обрабатываются в алгоритме двумя основными путями.
 Основной путь используется для S-пар, полная степень которых больше чем
 полная степень породивших их многочленов.
 Такие S-пары обрабатываются в следующем порядке:
\end_layout

\begin_deeper
\begin_layout Itemize
в процедуре 
\family typewriter
AlgorithmF5
\family default
 они рассматриваются функцией 
\family typewriter
CritPair
\family default
 при перемещении элементов 
\begin_inset Formula $G_{i}$
\end_inset

 из 
\begin_inset Formula $R_{d}=Done$
\end_inset

 и при обработке входного многочлена 
\begin_inset Formula $r_{i}$
\end_inset


\end_layout

\begin_layout Itemize
функция 
\family typewriter
CritPair
\family default
 или отбрасывает пару после проверки нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 или добавляет пару в 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Itemize
S-пара извлекается из 
\begin_inset Formula $P$
\end_inset

 и передаётся в функцию 
\family typewriter
SPol
\end_layout

\begin_layout Itemize
функция 
\family typewriter
SPol
\family default
 или отбрасывает пару после проверки 
\family typewriter
Rewritten?
\family default
 или добавляет S-многочлен в 
\begin_inset Formula $F=ToDo$
\end_inset


\end_layout

\begin_layout Itemize
на некоторой итерации процедура 
\family typewriter
Reduction
\family default
 берёт S-многочлен из 
\begin_inset Formula $ToDo$
\end_inset

, производит некоторые сигнатурные редукции и добавляет результат в 
\begin_inset Formula $Done$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Второй путь обработки используется для S-пар, соответствующих редукциям,
 запрещённым алгоритмом -- соответствующие S-пары порождаются многочленами
 
\begin_inset Formula $r_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $r_{l_{*}}$
\end_inset

, такими что 
\begin_inset Formula $\HM(r_{l^{*}})|\HM(r_{l_{*}})$
\end_inset

, и S-многочлен им соответствующий имеет вид 
\begin_inset Formula $\overline{u_{l}}\cdot\poly(r_{l^{*}})-1\cdot\poly(r_{l_{*}})$
\end_inset

.
 Такая ситуация возможна, если для элементов 
\begin_inset Formula $G_{g}$
\end_inset

 редукция 
\begin_inset Formula $r_{l_{*}}$
\end_inset

 по 
\begin_inset Formula $r_{l^{*}}$
\end_inset

 была запрещена сравнением сигнатур в 
\family typewriter
TopReduction
\family default
 или проверками в 
\family typewriter
IsReducible
\family default
.
 Для этого случая порядок 
\begin_inset Quotes fld
\end_inset

обработки
\begin_inset Quotes frd
\end_inset

 S-пары такой:
\end_layout

\begin_deeper
\begin_layout Itemize
часть S-пары 
\begin_inset Formula $\overline{u_{l}}\cdot r_{l^{*}}$
\end_inset

 проверяется в 
\family typewriter
IsReducible
\family default
.
 (a) выполнено, поскольку 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(r_{l^{*}})|\HM(r_{l_{*}})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 Она может быть отброшена другими проверками:
\end_layout

\begin_deeper
\begin_layout Itemize
отбрасывание пунктом (b) соответствует проверке нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 для 
\begin_inset Formula $\overline{u_{l}}\cdot r_{l^{*}}$
\end_inset


\end_layout

\begin_layout Itemize
отбрасывание пунктом (c) соответствует проверке 
\family typewriter
Rewritten?
\family default
 для 
\begin_inset Formula $\overline{u_{l}}\cdot r_{l^{*}}$
\end_inset


\end_layout

\begin_layout Itemize
отбрасывание пунктом (d) означает, что один из многочленов 
\begin_inset Formula $\overline{u_{l}}\cdot r_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $1\cdot r_{l_{*}}$
\end_inset

 может быть перезаписано другим, поэтому, если S-пара не была отброшена
 проверкой (c), данный тип отбрасывания означает, что часть S-пары 
\begin_inset Formula $1\cdot r_{i_{1}}$
\end_inset

 не проходит проверку 
\family typewriter
Rewritten?
\end_layout

\end_deeper
\begin_layout Itemize
S-пары, не отброшенные в 
\family typewriter
IsReducible
\family default
 возвращаются в 
\family typewriter
TopReduction
\family default
.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Сравнение сигнатур в 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
TopReduction
\family default
 запрещает редукцию 
\begin_inset Formula $r_{l_{*}}$
\end_inset

 по 
\begin_inset Formula $r_{l^{*}}$
\end_inset

 и помещает вычисленный S-многочлен, соответствующий S-паре, в множество
 
\begin_inset Formula $ToDo_{1}$
\end_inset


\end_layout

\begin_layout Itemize
процедура 
\family typewriter
Reduction
\family default
 добавляет этот многочлен в 
\begin_inset Formula $ToDo$
\end_inset


\end_layout

\begin_layout Itemize
последний шаг совпадает для обоих путей обработки S-пар: на некоторой итерации
 процедура 
\family typewriter
Reduction
\family default
 берёт S-многочлен из 
\begin_inset Formula $ToDo$
\end_inset

, производит некоторые сигнатурные редукции и добавляет результат в 
\begin_inset Formula $Done$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Из путей обработки S-пар видно, что после окончания обработки каждая S-пара
 или редуцирована и добавлена в 
\begin_inset Formula $Done$
\end_inset

 или одна из частей S-пары была отброшена проверкой нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 или критерием 
\family typewriter
Rewritten?
\family default
.
 Некоторые S-пары могут оказываться на путях обработки несколько раз, к
 примеру это происходит на итерации в 
\family typewriter
AlgorithmF5
\family default
 со значением 
\begin_inset Formula $d$
\end_inset

, не изменившимся с прошлой итерации.
 Если S-пара была отброшена при первой попытке обработки, то она будет точно
 также отброшена и на следующей попытке.
 Если первая обработка добавила редуцированный многочлен в 
\begin_inset Formula $Done$
\end_inset

, то пара будет отбрасываться при следующих попытках обработки проверкой
\family typewriter
 Rewritten?
\family default
 за счёт этого многочлена.
 Поэтому все попытки обработки, кроме первой, не дают ничего нового.
\end_layout

\begin_layout Proof
Путь обработки не является одной процедурой, и в случае, если алгоритм не
 останавливается, некоторые S-пары всегда находятся в середине обработки,
 при этом или соответствующая S-пара находится в очереди 
\begin_inset Formula $P$
\end_inset

 или S-многочлен в очереди 
\begin_inset Formula $ToDo$
\end_inset

.
 Поэтому необходимо понять, обработка каких S-пар уже завершилась в рассматривае
мый нами момент.
 Элементы 
\begin_inset Formula $P$
\end_inset

 и 
\begin_inset Formula $ToDo$
\end_inset

 извлекаются в процедурах 
\family typewriter
AlgorithmF5
\family default
 и 
\family typewriter
Reduction
\family default
 в порядке возрастания сигнатур.
 S-пары с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset

, могут быть разделены на 3 класса:
\end_layout

\begin_deeper
\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)>\sigidx(\Sig(g))=1$
\end_inset

.
 Они обрабатывались на предыдущих вызовах 
\family typewriter
AlgorithmF5
\family default
.
\end_layout

\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)<\totaldeg(\Sig(g))$
\end_inset

.
 Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
 
\family typewriter
AlgorithmF5
\family default
, который обрабатывает 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)=\totaldeg(\Sig(g)),w\prec\Sig(g)$
\end_inset

.
 Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
 
\family typewriter
Reduce
\family default
, который обрабатывает 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
S-пары из этих классов не могут находиться в середине пути обработки, потому
 что в рассматриваемом состоянии алгоритма обработка только что завершена
 для 
\begin_inset Formula $g$
\end_inset

, поэтому ни 
\begin_inset Formula $P$
\end_inset

 ни 
\begin_inset Formula $ToDo$
\end_inset

 не содержат необработанных элементов с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset

.
 Осталось показать, что для всех S-пар из утверждения теоремы обработка
 начиналась хотя бы один раз.
 Это просто проверить для первых двух классов: обработка соответствующих
 S-пар была начата по крайней мере один раз путём вызова 
\family typewriter
CritPair
\family default
 в 
\family typewriter
AlgorithmF5
\family default
 непосредственно перед тем, как наибольший из порождающих S-пару был добавлен
 в 
\begin_inset Formula $G$
\end_inset

.
 Для S-пар третьего класса ситуация зависит от полной степени её порождающих.
 Если оба порождающих S-пары имеют полную степень 
\begin_inset Formula $<\totaldeg(g)$
\end_inset

, то её обработка была начата в 
\family typewriter
CritPair
\family default
 аналогично S-парам первых двух классов.
 Но некоторые S-пары третьего класса могут иметь старший по сигнатуре порождающи
й 
\begin_inset Formula $r_{l}$
\end_inset

, такой что 
\begin_inset Formula $\totaldeg(r_{l})=\totaldeg(g),\,\Sig(r_{l})\prec\Sig(g)$
\end_inset

.
 Они обрабатываются вторым из рассмотренных путей обработки S-пар, поэтому
 обработка таких S-пар ещё не стартовала к моменту последнего вызова 
\family typewriter
Reduction
\family default
.
 Однако, их обработка начинается внутри 
\family typewriter
Reduction
\family default
 до изучаемого нами момента: процедура выбирает многочлены из 
\begin_inset Formula $ToDo$
\end_inset

 в порядке возрастания сигнатуры, поэтому 
\begin_inset Formula $r_{l}$
\end_inset

 редуцируется до 
\begin_inset Formula $g$
\end_inset

 и в процессе редукции 
\begin_inset Formula $r_{l}$
\end_inset

 непосредственно перед добавлением 
\begin_inset Formula $r_{l}$
\end_inset

 в 
\begin_inset Formula $Done$
\end_inset

 вызов 
\family typewriter
TopReduction
\family default
 начинает обработку всех таких S-пар.
\end_layout

\begin_layout Standard
Понятия 
\emph on
удовлетворять критерию F5 
\emph default
и 
\emph on
удовлетворять критерию Перезаписи
\emph default
 могут быть расширены на произвольные умноженные на моном отмеченные многочлены
 
\begin_inset Formula $sh,\, h\in G_{g}$
\end_inset

:
\end_layout

\begin_layout Definition
Умноженный на моном отмеченный многочлен  
\begin_inset Formula $sr_{i},\, r_{i}\in G_{g}$
\end_inset

 называется 
\emph on
удовлетворяющим критерию F5
\emph default
, если 
\begin_inset Formula $\varphi_{index(r_{i})+1}(s\Sig(r_{i}))\ne s\Sig(r_{i})$
\end_inset

, где 
\begin_inset Formula $\varphi_{index(r_{i})+1}$
\end_inset

 -- оператор нормальной формы по отношению к 
\begin_inset Formula $G_{index(r_{i})+1}$
\end_inset

.
\end_layout

\begin_layout Standard
Это определение эквивалентно тому, что 
\begin_inset Formula $sr_{i}$
\end_inset

 является ненормализованным отмеченным многочленом с точки зрения определения
 2 в части 5 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

.
\end_layout

\begin_layout Definition
Умноженный на моном отмеченный многочлен 
\begin_inset Formula $sr_{i},\, r_{i}\in G_{g}$
\end_inset

 называется 
\emph on
удовлетворяющим критерию Перезаписи
\emph default
, если 
\begin_inset Formula $\exists j>i$
\end_inset

 такое что 
\begin_inset Formula $\Sig(r_{j})|s\Sig(r_{i})$
\end_inset

.
\end_layout

\begin_layout Standard
В случае, если 
\begin_inset Formula $sr_{i}$
\end_inset

 является частью S-пары, эти определения эквиваленты проверкам, производимым
 в алгоритме, в том смысле, что часть S-пары отбрасывается алгоритмом тогда
 и только тогда, когда она удовлетворяет данному определению как умноженный
 на моном отмеченный многочлен.
 Для обоих критериев выполняется важное свойство, утверждающее, что если
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $sr_{i}$
\end_inset

 удовлетворяет критерию, то то и дополнительно домноженный многочлен 
\begin_inset Formula $s_{1}sr_{i}$
\end_inset

 также ему удовлетворяет.
\end_layout

\begin_layout Subsubsection
Представления
\end_layout

\begin_layout Standard
Для описания способов, которыми многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан как элемент идеала 
\begin_inset Formula $\left(G_{g}\right)$
\end_inset

 мы будем использовать 
\begin_inset Formula $G_{g}$
\end_inset

-представления.
\end_layout

\begin_layout Definition
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 называется 
\emph on
сигнатурным
\emph default
, если 
\begin_inset Formula $\forall k\,\Sig(m_{k}b_{i_{k}})\preccurlyeq\Sig(p)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Примеры
\end_layout

\begin_layout Example
Первый важный пример 
\begin_inset Formula $G_{g}$
\end_inset

-представления тривиален: отмеченный многочлен из 
\begin_inset Formula $G_{g}$
\end_inset

 равен сумме одного слагаемого -- самого себя с единичным коэффициентом:
 
\begin_inset Formula 
\[
b_{j}=1\cdot b_{j}.
\]

\end_inset


\end_layout

\begin_layout Standard
Это 
\begin_inset Formula $G_{g}$
\end_inset

-представление сигнатурно.
 Запрет на наличие в представлении нескольких элементов, имеющих одинаковый
 моном 
\begin_inset Formula $t_{k}$
\end_inset

 и многочлен 
\begin_inset Formula $b_{i_{k}}$
\end_inset

 гарантирует, что все элементы представления, отличающиеся только коэффициентом
 из поля 
\begin_inset Formula $c_{k}$
\end_inset

 скомбинированы вместе путём суммирования коэффициентов из поля.
 Поэтому выражения вида 
\begin_inset Formula $b_{j}=-1\cdot b_{j}+2\cdot b_{j}$
\end_inset

 и 
\begin_inset Formula $b_{j}=2x\cdot b_{k}+1\cdot b_{j}-2x\cdot b_{k}$
\end_inset

 не являются корректными 
\begin_inset Formula $G_{g}$
\end_inset

-представлениями.
\end_layout

\begin_layout Example
Отмеченный многочлен 
\begin_inset Formula $b_{j}\in G_{g}$
\end_inset

, домноженный на произвольный многочлен 
\begin_inset Formula $h$
\end_inset

 также имеет простое 
\begin_inset Formula $G_{g}$
\end_inset

-представление, получающееся из записи 
\begin_inset Formula $h$
\end_inset

 в виде суммы термов: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $h=\sum_{k}m_{k},\, m_{k}\in\mathcal{K}\times\mathbb{T}$
\end_inset

.
 Это 
\begin_inset Formula $G_{g}$
\end_inset

-представление имеет форму 
\begin_inset Formula 
\begin{equation}
b_{j}h=\sum_{k}m_{k}\cdot b_{j}\label{eq:repr-ex-2}
\end{equation}

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
и также является сигнатурным.
\end_layout

\begin_layout Standard
Отмеченный многочлен может иметь бесконечное множество различных представлений:
 к любому представлению можно добавить элементы, соответствующие сизигии,
 сгруппировать элементы с одновременно равными мономами и многочленами и
 получить другое корректное представление.
 Это будет представление того же многочлена, поскольку сумма многочленов,
 соответствующих элементам сизигии равна 0.
\end_layout

\begin_layout Example
Произведение двух многочленов из 
\begin_inset Formula $G_{g}$
\end_inset

 имеет 2 представления вида 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:repr-ex-2"

\end_inset

, которые отличаются прибавлением сизигии:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
b_{j}b_{i}=\sum_{k}m_{i_{k}}\cdot b_{j}=\sum_{k}m_{i_{k}}\cdot b_{j}+0=\sum_{k}m_{i_{k}}\cdot b_{j}+\left(\sum_{k}m_{j_{k}}\cdot b_{i}-\sum_{k}m_{i_{k}}\cdot b_{j}\right)=\sum_{k}m_{j_{k}}\cdot b_{i},
\]

\end_inset

где 
\begin_inset Formula $m_{i_{k}}$
\end_inset

 -- термы 
\begin_inset Formula $b_{i}$
\end_inset

, а 
\begin_inset Formula $m_{j_{k}}$
\end_inset

 -- термы 
\begin_inset Formula $b_{j}$
\end_inset

.
\end_layout

\begin_layout Example
Нулевой многочлен имеет пустое представление и представление, соответствующее
 каждой сизигии:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
0=\sum_{\emptyset}\mbox{(empty sum)}=\sum_{k}m_{j_{k}}\cdot b_{i}+\sum_{k}(-m_{i_{k}})\cdot b_{j},
\]

\end_inset

где 
\begin_inset Formula $m_{i_{k}}$
\end_inset

 и 
\begin_inset Formula $m_{j_{k}}$
\end_inset

 взяты из предыдущего примера.
 Все непустые представления нулевого многочлена не сигнатурны.
\end_layout

\begin_layout Standard
Другой важный пример 
\begin_inset Formula $G_{g}$
\end_inset

-представлений получается из определений сигнатуры и идеала.
 Все отмеченные многочлены, вычисляемые алгоритмом, принадлежат идеалу 
\begin_inset Formula $\left(f_{1},\ldots,f_{m}\right)$
\end_inset

.
 Поэтому любой отмеченный многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан в виде 
\begin_inset Formula $\sum_{i}f_{i}g_{i}$
\end_inset

, где 
\begin_inset Formula $g_{i}$
\end_inset

 -- однородные многочлены.
 Все входные многочлены 
\begin_inset Formula $f_{i}$
\end_inset

 принадлежат 
\begin_inset Formula $G_{g}$
\end_inset

, поэтому 
\begin_inset Formula $f_{i}g_{i}$
\end_inset

 имеют 
\begin_inset Formula $G_{g}$
\end_inset

-представления вида 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:repr-ex-2"

\end_inset

.
\end_layout

\begin_layout Example
Сумма этих представлений даёт следующее сигнатурное представление: 
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot b_{i_{k}},\, m_{k}\in\mathcal{K}\times\mathbb{T},\, b_{i_{k}}\in\left\{ f_{1},\ldots,f_{m}\right\} \subset G_{g}.
\]

\end_inset


\end_layout

\begin_layout Definition
Частный случай 
\begin_inset Formula $G_{g}$
\end_inset

-представления, при котором 
\begin_inset Formula $b_{i_{k}}$
\end_inset

 ограничены лишь входными многочленами, будет называться 
\emph on
входным представлением
\emph default
.
\end_layout

\begin_layout Standard
Входные представления всегда имеют единственный элемент максимальной сигнатуры.
 Произвольные 
\begin_inset Formula $G_{g}$
\end_inset

-представления не всегда обладают этим свойством, поскольку могут иметь
 несколько разных элементов с одинаковой максимальной сигнатурой, так как
 для них возможна ситуация 
\begin_inset Formula $m_{1}\Sig(b_{i_{1}})=m_{2}\Sig(b_{i_{2}})$
\end_inset

 при 
\begin_inset Formula $i_{1}\ne i_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее утверждение устанавливает связь между входными представлениями
 и понятием сигнатуры:
\end_layout

\begin_layout Claim
Допустимый отмеченный многочлен 
\begin_inset Formula $p$
\end_inset

 с известной сигнатурой 
\begin_inset Formula $\Sig(p)$
\end_inset

 имеет входное представление, состоящее из элемента 
\begin_inset Formula $c\Sig(p)\cdot f_{index(p)}$
\end_inset

 и некоторых других элементов с меньшими сигнатурами.
\end_layout

\begin_layout Proof
Утверждение вытекает из определения допустимого многочлена в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, ссылающегося на функцию 
\begin_inset Formula $v$
\end_inset

, которая соответствует суммированию элементов входного представления.
\end_layout

\begin_layout Standard
Теорема 1 из 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 утверждает, что все многочлены, порождаемые алгоритмом, допустимы, поэтому
 мы будем применять предыдущее утверждение ко всем таким многочленам.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example-of-having-gg-repr"

\end_inset

Последний пример восходит к S-парам с известным 
\begin_inset Formula $G_{g}$
\end_inset

-представлением.
 S-многочлен, порождённый 
\begin_inset Formula $b_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $b_{l_{*}}$
\end_inset

 из 
\begin_inset Formula $G_{g}$
\end_inset

, имеет вид 
\begin_inset Formula $p=\overline{u_{l}}\poly(b_{l^{*}})-\underline{u_{l}}\poly(b_{l_{*}})$
\end_inset

.
 Из процесса редукции вытекает, что 
\begin_inset Formula $p$
\end_inset

 сигнатурно редуцируется и результат добавляется в 
\begin_inset Formula $G_{g}$
\end_inset

 как некоторый отмеченный многочлен 
\begin_inset Formula $b_{l}$
\end_inset

.
 Отсюда его 
\begin_inset Formula $G_{g}$
\end_inset

-представление имеет вид:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot b_{n_{k}}+1\cdot b_{l},
\]

\end_inset

где сигнатуры элементов 
\begin_inset Formula $m_{k}\cdot b_{n_{k}}$
\end_inset

 меньше чем 
\begin_inset Formula $\Sig(b_{l})=\Sig(p)$
\end_inset

.
 Значение 
\begin_inset Formula $l$
\end_inset

 -- позиция 
\begin_inset Formula $b_{l}$
\end_inset

 в упорядоченном списке 
\begin_inset Formula $G_{g}$
\end_inset

.
 В данном представлении 
\begin_inset Formula $l$
\end_inset

 больше чем 
\begin_inset Formula $l^{*}$
\end_inset

 и 
\begin_inset Formula $l_{*}$
\end_inset

, поскольку соответствующий отмеченный многочлен 
\begin_inset Formula $b_{l}$
\end_inset

 был добавлен в 
\begin_inset Formula $R$
\end_inset

 в момент подсчёта S-многочлена в процедурах 
\family typewriter
Spol
\family default
 или 
\family typewriter
TopReduction
\family default
, поэтому многочлены 
\begin_inset Formula $b_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $b_{l_{*}}$
\end_inset

, использованные для его создания не отброшенной S-пары, уже присутствовали
 в 
\begin_inset Formula $R$
\end_inset

 к тому моменту, а порядок 
\begin_inset Formula $G_{g}$
\end_inset

 соответствует порядку добавления элементов в 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Paragraph
Порядок на представлениях
\end_layout

\begin_layout Definition
Для введения порядка на 
\begin_inset Formula $G_{g}$
\end_inset

-представлениях мы начнём с 
\emph on
порядка на элементах представления
\emph default
 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

: будем говорить, что 
\begin_inset Formula $c_{i}t_{i}\cdot b_{i}\gtrdot_{1}c_{j}t_{j}\cdot b_{j}$
\end_inset

 если выполняется один из следующих случаев:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $t_{i}\Sig(b_{i})\succ t_{j}\Sig(b_{j})$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
\end_inset

 и 
\begin_inset Formula $i<j$
\end_inset

 (сравнение позиций -- в обратную сторону).
\end_layout

\end_deeper
\begin_layout Standard
Этот порядок основан лишь на сравнение сигнатур и позиций отмеченных многочленов
 в упорядоченном списке 
\begin_inset Formula $G_{g}$
\end_inset

, но не зависит от коэффициента из поля.
 Единственный случай, в котором два элемента не могут быть упорядочены --
 одновременное равенство сигнатур 
\begin_inset Formula $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
\end_inset

 и позиций в списке 
\begin_inset Formula $i=j$
\end_inset

.
 Равенство позиций означает равенство многочленов 
\begin_inset Formula $b_{i}=b_{j}$
\end_inset

, что вместе с равенством сигнатур даёт 
\begin_inset Formula $t_{i}=t_{j}$
\end_inset

.
 Поэтому любые два элемента, принадлежащие одному корректному 
\begin_inset Formula $G_{g}$
\end_inset

 представлению являются сравнимыми с точки зрения порядка 
\begin_inset Formula $\lessdot_{1}$
\end_inset

, поскольку они имеют различные 
\begin_inset Formula $\left(t_{k},b_{k}\right)$
\end_inset

 по определению.
 Ниже приведены некоторые примеры сравнений элементов по 
\begin_inset Formula $\lessdot_{1}$
\end_inset

 для списка 
\begin_inset Formula $G_{g}=\left\{ b_{1},\, b_{2},\, b_{3}\right\} $
\end_inset

 из 3-х элементов с порядком на сигнатурах 
\begin_inset Formula $x\mathbf{F}_{i}\succ y\mathbf{F}_{i}$
\end_inset

 и сигнатурами 
\begin_inset Formula $\Sig(b_{1})=\mathbf{F}_{1},\Sig(b_{2})=\mathbf{F}_{2},\Sig(b_{3})=x\mathbf{F}_{1}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $y\cdot b_{1}\gtrdot_{1}100y\cdot b_{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части  
\begin_inset Formula $\succ$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $x\cdot b_{1}\gtrdot_{1}y\cdot b_{1}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части 
\begin_inset Formula $\succ$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $-x\cdot b_{1}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
и
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $2x\cdot b_{1}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 не сравнимы, поскольку сигнатуры и позиции в списке равны
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}\cdot b_{1}\lessdot_{1}y\cdot b_{3}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\prec$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot_{1}x\cdot b_{3}$
\end_inset

 поскольку сигнатуры равны, а позиция в списке отмеченного многочлена левой
 части равна 1, что меньше чем позиция многочлена правой части, равная 3.
\end_layout

\begin_layout Standard
Для расширения этого порядка на 
\begin_inset Formula $G_{g}$
\end_inset

-представления целиком будем рассматривать 
\emph on
упорядоченную форму
\emph default
 представления, состоящую из всех его элементов, записанных в 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-убывающий список.
 Эта форма может быть использована для проверки на равенство, поскольку
 представления равны тогда и только тогда, когда равны их упорядоченные
 формы.
\end_layout

\begin_layout Definition
При помощи упорядоченных форм введём 
\emph on
порядок на 
\begin_inset Formula $G_{g}$
\end_inset

-представлениях
\emph default
: представление 
\begin_inset Formula $\sum_{k}m'_{k}\cdot b_{i'_{k}}$
\end_inset

 является 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем 
\begin_inset Formula $\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

, если упорядоченные формы для первого и второго представления удовлетворяют
 лексикографически расширенному на формы отношению 
\begin_inset Formula $\lessdot_{1}$
\end_inset

.
 Для особого случая, когда упорядоченные формы отличаются лишь длиной, более
 короткая форма будет называться 
\begin_inset Formula $\lessdot$
\end_inset

-меньшей.
 Если наибольшие различные элементы в упорядоченных формах двух представлений
 отличаются лишь коэффициентов поля, то представления являются не сравнимыми.
\end_layout

\begin_layout Standard
Далее даны некоторые примеры этого порядка для того же, трёх-элементного
 списка 
\begin_inset Formula $G_{g}$
\end_inset

.
 Все 
\begin_inset Formula $G_{g}$
\end_inset

-представления записаны в упорядоченных формах:
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}+xy\cdot b_{1}+y^{2}b_{1}\gtrdot x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}$
\end_inset

 поскольку 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $xy\cdot b_{1}\gtrdot_{1}y^{2}\cdot b_{1}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}\gtrdot x^{2}\cdot b_{1}$
\end_inset

 поскольку правая часть является началом левой
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 поскольку 
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot_{1}xy\cdot b_{1}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}\gtrdot y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 поскольку 
\begin_inset Formula $xy\cdot b_{1}\gtrdot_{1}y\cdot b_{3}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 и 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $2y\cdot b_{3}+y^{2}\cdot b_{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 не сравнимы, поскольку наибольшие различные элементы -- это 
\begin_inset Formula $y\cdot b_{3}$
\end_inset

 и 
\begin_inset Formula $2y\cdot b_{3}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Standard
Порядок на представлениях совместим с понятием сигнатурности представления:
\end_layout

\begin_layout Theorem
Если для пары представлений отмеченного многочлена 
\begin_inset Formula $p$
\end_inset

 выполняется отношение 
\begin_inset Formula $\sum_{k}m'_{k}\cdot b_{i'_{k}}\lessdot\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 и правое представление сигнатурно, то и левое представление сигнатурно.
\end_layout

\begin_layout Proof
Теорема легко следует из того, что сигнатуры элементов 
\begin_inset Formula $\lessdot$
\end_inset

-меньшего представления не могут быть 
\begin_inset Formula $\succ$
\end_inset

-больше, чем максимальная сигнатура 
\begin_inset Formula $\gtrdot$
\end_inset

-большего представления.
\end_layout

\begin_layout Standard
Важным фактом, позволяющим брать 
\begin_inset Formula $\lessdot$
\end_inset

-минимальный элемент, является вполне упорядоченность:
\end_layout

\begin_layout Theorem
Представления вполне упорядочены порядком 
\begin_inset Formula $\lessdot$
\end_inset

.
\end_layout

\begin_layout Proof
Количество различных отмеченных многочленов, входящих в элементы представления,
 конечно, поскольку оно равно 
\begin_inset Formula $|G_{g}|$
\end_inset

 для некоторого фиксированного 
\begin_inset Formula $g$
\end_inset

.
 Поэтому существование бесконечной 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-убывающей последовательности элементов представлений привело бы к существованию
 бесконечной 
\begin_inset Formula $\succ$
\end_inset

-убывающей последовательности сигнатур.
 Учитывая вполне упорядоченность сигнатур по 
\begin_inset Formula $\prec$
\end_inset

 мы получаем доказательство вполне упорядоченности элементов представлений
 по 
\begin_inset Formula $\lessdot{}_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
Прямое доказательство вполне упорядоченности представлений по 
\begin_inset Formula $\lessdot$
\end_inset

 на основе вполне упорядоченности их элементов по 
\begin_inset Formula $\lessdot_{1}$
\end_inset

 не является очень сложным, однако дабы не вдаваться в детали, используем
 теорему 2.5.5 книги 
\begin_inset CommandInset citation
LatexCommand cite
key "Baader.Nipkow98Term"

\end_inset

.
 Она утверждает вполне упорядоченность конечных наборов с порядком, являющимся
 лексикографическим расширением порядка на элементах набора.
 Это применимо к предмтавлениямм, так как они являются наборами своих элементов.
\end_layout

\begin_layout Paragraph
Последовательность представлений
\end_layout

\begin_layout Standard
Идея этой части состоит в построении конечной последовательности строго
 
\begin_inset Formula $\lessdot$
\end_inset

-убывающих сигнатурных 
\begin_inset Formula $G_{g}$
\end_inset

-представлений для некоторого отмеченного многочлена 
\begin_inset Formula $mh,\, m\in\mathcal{K}\times\mathbb{T},\, h\in G_{g}$
\end_inset

 со свойством 
\begin_inset Formula $\Sig(mh)\prec\Sig(g)$
\end_inset

.
 Первым сигнатурным представлением в последовательности является 
\begin_inset Formula $mh=m\cdot h$
\end_inset

, а последнее представление имеет вид 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 со свойствами, выполняющимися для 
\begin_inset Formula $\forall k$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m_{k}b_{i_{k}}$
\end_inset

 не удовлетворяет критерию F5.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m_{k}b_{i_{k}}$
\end_inset

 не удовлетворяет критерию Перезаписи.
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\HM(m_{k}b_{i_{k}})\leqslant\HM(mh)$
\end_inset


\end_layout

\begin_layout Standard
Доказательство существования такой последовательности довольно похоже на
 доказательство Теоремы 21 из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 и основано на том, что если некоторое сигнатурное представление 
\begin_inset Formula $mh$
\end_inset

 содержит не удовлетворяющий одному из свойств элемент 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

, то может быть найдено 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее представление.
 Метод построения отличается для разных свойств, однако схема замены одинакова:
\end_layout

\begin_layout Itemize
выбирается некоторый элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 в представлении 
\begin_inset Formula $mh$
\end_inset

.
 Следует отметить, что 
\begin_inset Formula $K'$
\end_inset

 может как совпадать, так и отличаться от 
\begin_inset Formula $K$
\end_inset


\end_layout

\begin_layout Itemize
строится некоторое представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 для этого элемента
\end_layout

\begin_layout Itemize
показывается, что построенное представление 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\end_layout

\begin_layout Standard
Построение такого представления для 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 позволяет применить следующую лемму:
\end_layout

\begin_layout Lemma
Если элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 сигнатурного представления 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 имеет представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

, 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

, то 
\begin_inset Formula $mh$
\end_inset

 имеет сигнатурное представление, 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
\end_layout

\begin_layout Proof
Заменим элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 в представлении 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 на 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 и скомбинируем коэффициенты при элементах с одновременно одинаковыми мономами
 и многочленами, получив таким образом изменённое представления для 
\begin_inset Formula $mh$
\end_inset

.
 Оно будет 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 поскольку: все элементы 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-большие 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 идентичны в исходном и изменённом представлениях; элемент 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 содержится в исходном, но не в изменённом представлении; все остальные
 элементы в представлениях являются 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-меньшими, чем 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поэтому они не играют роли при сравнении.
 Сравнение выполняется даже в случае, когда при комбинировании коэффициентов
 все элементы обнулились.
 Этот случай может возникнуть, если исходное представление было равно 
\begin_inset Formula $mh=m_{K'}\cdot b_{i_{K'}}+\sum_{l}(-m_{l})\cdot b_{i_{l}}$
\end_inset

, что привело к изменённому представлению вообще не содержащему элементов:
 
\begin_inset Formula $mh=0$
\end_inset

.
 Оно является 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем любое непустое представление.
\end_layout

\begin_layout Standard
Теперь покажем, что представление элемента по вышеуказанной схеме может
 быть построено, если исходное представление содержит элемент, не удовлетворяющи
й по крайней мере одному из свойств.
\end_layout

\begin_layout Lemma
Если сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 содержит элемент, не удовлетворяющий свойству 1, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 обладающий 
\begin_inset Formula $G_{g}$
\end_inset

-представлением 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

.
\end_layout

\begin_layout Standard
Элемент, не обладающий первым свойством, удовлетворяет критерию F5, что
 позволяет позволяет использовать соображение о том, что 
\begin_inset Formula $m_{K}\Sig(b_{i_{K}})$
\end_inset

 не является его сигнатурой 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 аналогично теореме 20 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 Для этого случая берётся 
\begin_inset Formula $K'=K$
\end_inset

.
\end_layout

\begin_layout Proof
Рассмотрим входное представление 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 с сигнатурой 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимального элемента, равной 
\begin_inset Formula $m_{K}\Sig(b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{equation}
m_{K}b_{i_{K}}=c_{0}s_{0}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.\label{eq:input-repr-case1}
\end{equation}

\end_inset

Из удовлетворения критерия F5 следует, что 
\begin_inset Formula $s_{0}$
\end_inset

 может быть представлено как 
\begin_inset Formula $s_{0}=s_{1}\HM(f_{j_{1}}),\, j_{1}>j_{0}$
\end_inset

, откуда 
\begin_inset Formula $s_{0}f_{j_{0}}=s_{1}f_{j_{0}}f_{j_{1}}-s_{1}(f_{j_{1}}-\HM(f_{j_{1}}))f_{j_{0}}$
\end_inset

.
 На основе этого выражения можно получить другое представление для 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

, обозначая за 
\begin_inset Formula $m_{0i}$
\end_inset

 упорядоченные термы 
\begin_inset Formula $f_{j_{0}}$
\end_inset

, за 
\begin_inset Formula $m_{1i}$
\end_inset

 -- упорядоченные термы 
\begin_inset Formula $f_{j_{1}}$
\end_inset

 и за 
\begin_inset Formula $N_{0,}N_{1}$
\end_inset

 число термов в этих многочленах:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
m_{K}b_{i_{K}}=\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}+\sum_{i=2}^{N_{1}}-c_{0}s_{1}m_{1i}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.
\]

\end_inset

Это представление 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

 поскольку сигнатуры всех его элементов меньше чем 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s_{0}\mathbf{F}_{j_{0}}$
\end_inset

.
 Для элементов третьей суммы 
\begin_inset Formula $\sum_{l}m_{l}\cdot f_{i_{l}}$
\end_inset

 это следует из 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, где эти элементы являются меньшими элементами входного представления.
 Для элементов первой суммы 
\begin_inset Formula $\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}$
\end_inset

 это следует из неравенства индексов сигнатур 
\begin_inset Formula $j_{1}>j_{0}$
\end_inset

.
 А для второй суммы используем совпадение порядка на сигнатурах и на термах:
 все термы 
\begin_inset Formula $m_{1i},\, i\geqslant2$
\end_inset

 меньше, чем 
\begin_inset Formula $m_{11}$
\end_inset

, поэтому и выполняется неравенство для сигнатур: 
\begin_inset Formula $s_{1}m_{1i}\mathbf{F}_{j_{0}}\prec s_{1}m_{11}\mathbf{F}_{j_{0}}=s_{0}\mathbf{F}_{j_{0}}$
\end_inset

.
 
\end_layout

\begin_layout Lemma
Если сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec\Sig(g)$
\end_inset

 содержит элемент, не удовлетворяющий свойству 2, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 обладающий 
\begin_inset Formula $G_{g}$
\end_inset

-представлением 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Standard
Для элементов, не удовлетворяющих критерию Перезаписи 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее представление сроится методом, аналогичным Предложению 17 из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 В этом случае также берётся 
\begin_inset Formula $K'=K$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим, что сигнатура 
\begin_inset Formula $\Sig(m_{K}b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 и она перезаписывается отмеченным многочленом 
\begin_inset Formula $b_{i'}$
\end_inset

 из 
\begin_inset Formula $R$
\end_inset

.
 Поскольку представление сигнатурно, мы имеем 
\begin_inset Formula $\Sig(b_{i'})\preccurlyeq s_{0}\mathbf{F}_{j_{0}}\preccurlyeq\Sig(mh)\prec\Sig(g)$
\end_inset

.
 Поэтому 
\begin_inset Formula $b_{i'}$
\end_inset

 обрабатывался в процедуре 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
TopReduction
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 раньше 
\begin_inset Formula $g$
\end_inset

.
 Значит 
\begin_inset Formula $b_{i'}$
\end_inset

 был редуцирован и результат его редукции или был нулевым или присутствует
 в 
\begin_inset Formula $G_{g}$
\end_inset

, поэтому он может использоваться как многочлен элемента 
\begin_inset Formula $G_{g}$
\end_inset

-представления.
 Из критерия Перезаписи известно, что 
\begin_inset Formula $i'>i_{K}$
\end_inset

 и существует 
\begin_inset Formula $s'\in\mathbb{T}$
\end_inset

, такое что 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $s'\Sig(b_{i'})=s_{0}\mathbf{F}_{j_{0}}$
\end_inset

.
 Для 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 есть входное представление 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset

 а для 
\begin_inset Formula $s'b_{i'}$
\end_inset

 входным представлением является:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
s'b_{i'}=c's_{0}\cdot f_{j_{0}}+\sum_{l'}m_{l'}\cdot f_{i_{l'}}.
\]

\end_inset

Преобразованием этого выражения получим 
\begin_inset Formula $G_{g}$
\end_inset

-представление для 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{0}s_{0}f_{j_{0}}$
\end_inset

:
\end_layout

\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
c_{0}s_{0}f_{j_{0}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}.
\]

\end_inset

Используя его для замены первого элемента в 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset

 получим желаемый результат:
\begin_inset Formula 
\[
m_{K}b_{i_{K}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}+\sum_{l}m_{l}\cdot f_{i_{l}}
\]

\end_inset

Он 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$
\end_inset

 поскольку элементы обоих сумм имеют сигнатуры, меньшие 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s_{0}\mathbf{F}_{j_{0}}$
\end_inset

, а для первого элемента, если 
\begin_inset Formula $b_{i'}$
\end_inset

 не нулевой, имеем 
\begin_inset Formula $\Sig(c'^{-1}c_{0}s'\cdot b_{i'})=\Sig(m_{K}\cdot b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$
\end_inset

 с 
\begin_inset Formula $i'>i_{K}$
\end_inset

, откуда применяя правило 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-сравнения для равных сигнатур и различных позиций в списке, получаем, что
 элемент 
\begin_inset Formula $c'^{-1}c_{0}s'\cdot b_{i'}$
\end_inset

 также 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

.
 Если же 
\begin_inset Formula $b_{i'}=0$
\end_inset

, то он отбрасывается, и желаемое представление состоит только из оставшихся
 2-х сумм.
\end_layout

\begin_layout Lemma
Если все элементы сигнатурного представления 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec\Sig(g)$
\end_inset

 удовлетворяют свойствам 1 и 2, но один из них не удовлетворяет свойству
 3, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

, имеющий представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

.
\end_layout

\begin_layout Proof
Существует по крайней мере один элемент 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

, не удовлетворяющий свойству 3.
 Обозначим за 
\begin_inset Formula $m_{\max}$
\end_inset

 максимальный 
\begin_inset Formula $\HM$
\end_inset

 отмеченных многочленов, соответствующих элементам представления, и за 
\begin_inset Formula $H_{\max}$
\end_inset

 список элементов, на котором 
\begin_inset Formula $m_{\max}$
\end_inset

 достигается.
 Возьмём в качестве 
\begin_inset Formula $K'$
\end_inset

 номер элемента представления, являющегося 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимальным в 
\begin_inset Formula $H_{\max}$
\end_inset

.
 Имеем 
\begin_inset Formula $\HM(m_{K'}b_{i_{K'}})=m_{\max}\succcurlyeq\HM(m_{K}b_{i_{K}})\succ\HM(mh)$
\end_inset

, поэтому 
\begin_inset Formula $\HM$
\end_inset

 суммы всех элементов, кроме 
\begin_inset Formula $K'$
\end_inset

-го равен 
\begin_inset Formula $\HM(mh-m_{K'}b_{i_{K'}})=\HM(m_{K'}b_{i_{K'}})=m_{\max}$
\end_inset

, поэтому существует другой элемент 
\begin_inset Formula $K''$
\end_inset

, обладающий 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(m_{K''}b_{i_{K''}})=m_{\max}$
\end_inset

.
 Отсюда 
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}\in H_{\max}$
\end_inset

 и 
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}\lessdot_{1}m_{K'}\cdot b_{i_{K'}}$
\end_inset

 поскольку 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимален в 
\begin_inset Formula $H_{\max}$
\end_inset

.
\end_layout

\begin_layout Proof
Равенство 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(m_{K''}b_{i_{K''}})=\HM(m_{K'}b_{i_{K'}})$
\end_inset

 означает, что S-пара 
\begin_inset Formula $b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $b_{i_{K''}}$
\end_inset

 имеет вид 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $[m'^{-1}m_{\max},\, m'^{-1}m_{K'},\, b_{i_{K'}},\, m'^{-1}m_{K''},\, b_{i_{K''}}]$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 где 
\begin_inset Formula $m'=\mbox{gcd}(m_{K'},m_{K''})$
\end_inset

.
 Пусть 
\begin_inset Formula $q$
\end_inset

 -- соответствующий S-многочлен.
 Тогда 
\begin_inset Formula $m'\Sig(q)\preccurlyeq\Sig(mh)\prec\Sig(g)$
\end_inset

 поскольку 
\begin_inset Formula $m'\Sig(q)=\Sig(m_{K'}b_{i_{K'}})$
\end_inset

 и представление сигнатурно.
 Части S-многочлена 
\begin_inset Formula $m'^{-1}m_{K'}b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $m'^{-1}m_{K''}b_{i_{K''}}$
\end_inset

 не удовлетворяют критериям F5 и Перезаписи, поскольку они же, умноженные
 на 
\begin_inset Formula $m'$
\end_inset

 равны 
\begin_inset Formula $m_{K'}b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $m_{K''}b_{i_{K''}}$
\end_inset

 -- отмеченным многочленам, соответствующим элементам, про которые известно,
 что они не удовлетворяют критериям по предположению леммы.
 Из 
\begin_inset Formula $m'\Sig(q)\prec\Sig(g)$
\end_inset

 имеем 
\begin_inset Formula $\Sig(q)\prec\Sig(g)$
\end_inset

, а значит можно применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-gg-repr"

\end_inset

 и получить, что 
\begin_inset Formula $(b_{i_{K'}},b_{i_{K''}})$
\end_inset

 -- S-пара с 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
известным
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $G_{g}$
\end_inset

-представлением, что означает существование представления, описанного в
 примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example-of-having-gg-repr"

\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
q=1\cdot b_{i'}+\sum_{l}m_{l}\cdot b_{i_{l}},
\]

\end_inset

причём выполняются свойства, показанные после примера: 
\begin_inset Formula $\Sig(q)=\Sig(b_{i'})$
\end_inset

, 
\begin_inset Formula $\forall l\,\Sig(q)\succ\Sig(m_{l}b_{i_{l}})$
\end_inset

 и 
\begin_inset Formula $i'>K'$
\end_inset

.
\end_layout

\begin_layout Proof
С другой стороны по определению S-многочлена мы имеем 
\begin_inset Formula $m'q=c_{0}m_{K'}b_{i_{K'}}-c_{1}m_{K''}b_{i_{K''}}$
\end_inset

, откуда получаем следующее представление:
\begin_inset Formula 
\[
m_{K'}b_{i_{K'}}=c_{0}^{-1}c_{1}m_{K''}\cdot b_{i_{K''}}+c_{0}^{-1}m'\cdot b_{i'}+\sum_{l}c_{0}^{-1}m'm_{l}\cdot b_{i_{l}}.
\]

\end_inset

Оно 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

: 
\end_layout

\begin_layout Proof
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}$
\end_inset

 уже сравнивалось с 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\end_layout

\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $m'\cdot b_{i'}$
\end_inset

 имеет ту же сигнатуру, но больший номер позиции 
\begin_inset Formula $i'>i_{K'}$
\end_inset


\end_layout

\begin_layout Proof
последняя сумма состоит из элементов с сигнатурами, меньшими чем 
\begin_inset Formula $m'\Sig(b_{i'})=\Sig(m_{K'}\cdot b_{i_{K'}})$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-smaller-signature-safe-representation"

\end_inset

Или сигнатурное представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec\Sig(g)$
\end_inset

 удовлетворяет свойствам 1-3 или существует другое сигнатурное представление
 
\begin_inset Formula $mh=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
\end_layout

\begin_layout Proof
Теорема немедленно следует из комбинации четырёх предыдущих лемм.
\end_layout

\begin_layout Standard
Это привод нас к следующему ключевому результату:
\end_layout

\begin_layout Theorem
Для любого многочлена 
\begin_inset Formula $mh,\, m\in\mathcal{K}\times\mathbb{T},\, h\in G_{g}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec\Sig(g)$
\end_inset

 существует удовлетворяющее свойствам 1-3 сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Proof
Начнём с представления 
\begin_inset Formula $mh=m\cdot h$
\end_inset

 и будем заменять текущее представление на 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-smaller-signature-safe-representation"

\end_inset

 до тех пор пока текущее представление не будет удовлетворять свойствам
 1-3.
 Конечность процесса гарантируется вполне упорядоченностью представлений
 по 
\begin_inset Formula $\lessdot$
\end_inset

.
\end_layout

\begin_layout Standard
Этот результат может представлять интерес сам по себе, однако для целей
 доказательства остановки нужно лишь одно следствие из него:
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:all-needed-for-terminaton"

\end_inset

Рассмотрим произвольный многочлен 
\begin_inset Formula $f$
\end_inset

 без ограничений на его сигнатуру.
 Если существует сигнатурный редуктор 
\begin_inset Formula $f'\in G_{g}$
\end_inset

 для 
\begin_inset Formula $f$
\end_inset

 с 
\begin_inset Formula $\Sig(f')\frac{\HM(f)}{\HM(f')}\prec\Sig(g)$
\end_inset

 то 
\begin_inset Formula $G_{g}$
\end_inset

 содержит сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

, который не отбрасывается критериями F5 и перезаписи.
\end_layout

\begin_layout Proof
Пусть 
\begin_inset Formula $mf',\, m=\frac{\HM(f)}{\HM(f')}\in\mathcal{K}\times\mathbb{T},\, f'\in G_{g}$
\end_inset

 умноженный редуктор с 
\begin_inset Formula $\Sig(mf')\prec\Sig(g)$
\end_inset

.
 Из предыдущей теоремы мы можем найти удовлетворяющее свойствам 1-3 представлени
е 
\begin_inset Formula $mf'=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
 Свойство 3 означает отсутствие элементов с 
\begin_inset Formula $\HM$
\end_inset

, большим чем у 
\begin_inset Formula $mf'$
\end_inset

, откуда, поскольку сумма всех элементов этого представления имеет 
\begin_inset Formula $\HM$
\end_inset

 равный 
\begin_inset Formula $\HM(mf')$
\end_inset

, существует элемент 
\begin_inset Formula $K$
\end_inset

, на котором достигается равенство 
\begin_inset Formula $\HM$
\end_inset

: 
\begin_inset Formula $\HM(m_{K}\cdot b_{i_{K}})=\HM(mf')=\HM(f)$
\end_inset

.
 Поскольку представление сигнатурно, имеем 
\begin_inset Formula $\Sig(m_{K}\cdot b_{i_{K}})\preccurlyeq\Sig(mf')\prec\Sig(f)$
\end_inset

, а значит 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 и выполнение свойств 1-2 гарантирует, что 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 не отбрасывается критериями.
\end_layout

\begin_layout Subsubsection
Обнаружение противоречия с учётом критериев
\end_layout

\begin_layout Standard
Теперь мы можем вернуться к результату теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

, утверждающей, что в случае.
 если алгоритм не останавливается, существуют многочлены 
\begin_inset Formula $f',f\in G$
\end_inset

, такие что 
\begin_inset Formula $\HM(f')|\HM(f)$
\end_inset

, 
\begin_inset Formula $\frac{\HM(f')}{\Sig(f')}\succ_{q}\frac{\HM(f)}{\Sig(f)}$
\end_inset

.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Используя этот результат и последнее следствие мы построим два многочлена,
 приводящие к противоречию в случае отсутствия остановки алгоритма
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:always-exist-ok-reductor"

\end_inset

Если алгоритм не останавливается на некоторых входных данных, то найдётся
 шаг, после которого конечное множество 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G\cup Done$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 содержит пару отмеченных многочленов 
\begin_inset Formula $f'_{1},f$
\end_inset

, для которых выполняется:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $f'_{1}$
\end_inset

 было добавлено в 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G\cup Done$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 до 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{1}f'_{1}$
\end_inset

 не удовлетворяет критериям F5 и Перезаписи, где 
\begin_inset Formula $t_{1}=\frac{\HM(f)}{\HM(f'_{1})}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $f'_{1}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Пусть 
\begin_inset Formula $f',f$
\end_inset

 -- многочлены из теоремы
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 и
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $t=\frac{\HM(f)}{\HM(f')}$
\end_inset

.
 Многочлен 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $f\in G$
\end_inset

, поэтому построенная выше теория о представлениях может быть рассмотрена
 применительно к случаю 
\begin_inset Formula $g$
\end_inset

 равного 
\begin_inset Formula $f$
\end_inset

, и можно говорить о множестве 
\begin_inset Formula $G_{f}$
\end_inset

 и 
\begin_inset Formula $G_{f}$
\end_inset

-представлениях.
 Поскольку
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $tf'$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 -- мы имеем 
\begin_inset Formula $\Sig(f')t\prec\Sig(f)$
\end_inset

 и следствие 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:all-needed-for-terminaton"

\end_inset

 может быть применено для нахождения сигнатурного редуктора 
\begin_inset Formula $t_{1}f'_{1}$
\end_inset

 для 
\begin_inset Formula $f$
\end_inset

, который не удовлетворяет критериям.
 Помимо этого известно, что он принадлежит 
\begin_inset Formula $G_{f}$
\end_inset

, поэтому выполняется и первое свойство: в процессе работы алгоритма 
\begin_inset Formula $f'_{1}$
\end_inset

 был добавлен в 
\begin_inset Formula $G\cup Done$
\end_inset

 раньше 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Theorem
Алгоритм F5, описанный в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, останавливается на любых входных данных.
\end_layout

\begin_layout Proof
Покажем, что существование многочленов 
\begin_inset Formula $f'_{1},f$
\end_inset

 из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 приводит к противоречию.
 Рассмотрим вызов 
\family typewriter
TopReduction
\family default
 после которого многочлен 
\begin_inset Formula $f$
\end_inset

 был добавлен в 
\begin_inset Formula $Done$
\end_inset

.
 Этот вызов вернул многочлен 
\begin_inset Formula $f$
\end_inset

 как первую половину значения, возвращаемого 
\family typewriter
TopReduction
\family default
, что означает что предшествующий вызов 
\family typewriter
IsReducible
\family default
 вернул пустое множество.
 Это значит, что для каждого многочлена в 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G\cup Done$
\end_inset

, в том числе
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $f'_{1}$
\end_inset

, хотя бы одно из условий (a) - (d) не выполнилось.
 Это невозможно, поскольку:
\end_layout

\begin_deeper
\begin_layout Itemize
(a) удовлетворяется, так как 
\begin_inset Formula $f'_{1}$
\end_inset

 -- редуктор для 
\begin_inset Formula $f$
\end_inset

 по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 
\end_layout

\begin_layout Itemize
(b) и (c) удовлетворяются, поскольку 
\begin_inset Formula $\frac{\HM(f)}{\HM(f'_{1})}f'_{1}$
\end_inset

 не удовлетворяет критериям F5 и Перезаписи по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 
\end_layout

\begin_layout Itemize
(d) удовлетворяется, поскольку 
\begin_inset Formula $f'_{1}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
Упрощение F5
\end_layout

\begin_layout Standard
[доказательство единственности выбираемого редуктора]
\end_layout

\begin_layout Standard
[отсуствие добавления S-пар до окончания редукции - краткое объяснение,
 и ссылка на L.Huang (перепроверить правильность)]
\end_layout

\begin_layout Standard
[переформулировка критериев в стиле, близком к SSG]
\end_layout

\begin_layout Standard
[Формулировка списка фактов, натолкнувших на идею SSG]
\end_layout

\begin_layout Section
Простой алгоритм, основанный на сигнатурах
\end_layout

\begin_layout Standard
Рассмотрим кольцо многочленов 
\begin_inset Formula $P=\mathcal{K}[x_{1},\dots,x_{n}]$
\end_inset

 над полем 
\begin_inset Formula $\mathcal{K}$
\end_inset

.
 Будем предполагать, что на моноиде его мономов 
\begin_inset Formula $\mathbb{T}$
\end_inset

 задан допустимый мономиальный порядок 
\begin_inset Formula $\prec$
\end_inset

.
 В этом кольце может быть поставлена задача вычисления базиса Грёбнера для
 произвольного идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{l}\right)$
\end_inset

.
 Один из способов её решения инкрементальный: последовательно вычисляются
 базисы идеалов 
\begin_inset Formula $\left(f_{1},\dots,f_{i}\right),i=2\dots l$
\end_inset

 на основе уже вычисленного для идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{i-1}\right)$
\end_inset

 базиса 
\begin_inset Formula $R_{i-1}$
\end_inset

 и многочлена 
\begin_inset Formula $f_{i}$
\end_inset

.
 Представляемый алгоритм позволяет выполнить шаг такого вычисления.
 Таким образом, входные данные для алгоритма -- это некоторый многочлен
 
\begin_inset Formula $f$
\end_inset

 и множество многочленов, обозначаемое 
\begin_inset Formula $\left\{ g_{1},\dots,g_{m}\right\} $
\end_inset

, являющееся базисом Грёбнера идеала 
\begin_inset Formula $I_{0}=\left(g_{1},\dots,g_{m}\right)$
\end_inset

.
 В качестве результата своей работы алгоритм должен построить множество
 многочленов 
\begin_inset Formula $R$
\end_inset

, являющееся базисом Грёбнера идеала 
\begin_inset Formula $I=\left(g_{1},\dots,g_{m},f\right)$
\end_inset

.
 Поскольку случаи 
\begin_inset Formula $f=0\Rightarrow I=I_{0}$
\end_inset

 и 
\begin_inset Formula $\exists i\, g_{i}\in\mathcal{K}\Rightarrow I=P$
\end_inset

 не представляют интереса, далее предполагается что 
\begin_inset Formula $f\neq0,\forall i\, g_{i}\notin\mathcal{K}.$
\end_inset

 Заметим, что в отличии от алгоритма F5, описанного в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, однородность многочленов не требуется.
\end_layout

\begin_layout Subsection
Определения
\end_layout

\begin_layout Standard
Понятие делимости также расширяется на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

: 
\begin_inset Formula $t_{1}|t_{2}\eqdef\exists t_{3}\, t_{1}t_{3}=t_{2}$
\end_inset

.
 Для 
\begin_inset Formula $p\in\mathcal{P},p\neq0$
\end_inset

 старшие по 
\begin_inset Formula $\prec$
\end_inset

 моном и коэффициент обозначим 
\begin_inset Formula $\HM(p)\in\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\HC(p)\in\mathcal{K}$
\end_inset

.
 Для нуля -- 
\begin_inset Formula $\HM(0)\eqdef0\in\mathbb{T}_{0}$
\end_inset

, 
\begin_inset Formula $\HC(0)\eqdef0\in\mathcal{K}$
\end_inset

.
 Далее все определения даются для фиксированных 
\begin_inset Formula $I_{0}$
\end_inset

 и 
\begin_inset Formula $f$
\end_inset

:
\end_layout

\begin_layout Definition

\emph on
Отмеченным многочленом
\emph default
 называется пара 
\begin_inset Formula $h=(\sigma,p)\in\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

, удовлетворяющая условию корректности: 
\begin_inset Formula $\exists u\in\mathcal{P}\,\HM(u)=\sigma,uf\equiv p\pmod{I_{0}}.$
\end_inset

 На отмеченные многочлены распространяются определения старшего монома 
\begin_inset Formula $\HM(h)\eqdef\HM(p)$
\end_inset

 и коэффициента 
\begin_inset Formula $\HC(h)\eqdef\HC(p)$
\end_inset

.
 Также определяются 
\emph on
сигнатура
\emph default
 
\begin_inset Formula $\Sig(h)\eqdef\sigma$
\end_inset

 и вводится обозначение многочлена -- второго элемента пары: 
\begin_inset Formula $\poly(h)\eqdef p$
\end_inset

.
 Множество отмеченных многочленов обозначается за 
\begin_inset Formula $H\subset\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

.
 Тривиальными примерами отмеченных многочленов являются 
\begin_inset Formula $\left(1,f\right)$
\end_inset

 и 
\begin_inset Formula $\left(0,g\right)$
\end_inset

 для 
\begin_inset Formula $g\in I_{0}$
\end_inset

.
 Другим примером отмеченного многочлена является 
\begin_inset Formula $\left(\HM(g),0\right)$
\end_inset

 для 
\begin_inset Formula $g\in I_{0}$
\end_inset

.
 Он корректен, поскольку в качестве 
\begin_inset Formula $u$
\end_inset

 можно взять 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Lemma
Умножение для 
\begin_inset Formula $h\in H,t\in\mathbb{T}$
\end_inset

, заданное как 
\begin_inset Formula $th\eqdef(t\sigma,tp)\in H,$
\end_inset

 корректно.
\end_layout

\begin_layout Proof
Корректность определения проверяется явным нахождением 
\begin_inset Formula $u$
\end_inset

 для 
\begin_inset Formula $th$
\end_inset

.
\end_layout

\begin_layout Definition
Если для некоторых
\emph on
 
\begin_inset Formula $h'_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset


\emph default
 выполняется 
\begin_inset Formula $\Sig(h'_{1})\succ_{0}\Sig(th_{2}),\HM(h'{}_{1})=\HM(th{}_{2})\neq0,$
\end_inset

 то возможна 
\emph on
редукция 
\begin_inset Formula $h'_{1}$
\end_inset

 по 
\begin_inset Formula $h_{2}$
\end_inset

 с сохранением сигнатуры
\emph default
, дающая в результате многочлен 
\begin_inset Formula $h_{1}\in H$
\end_inset

, равный: 
\begin_inset Formula 
\[
h_{1}=\left(\Sig(h'_{1}),\poly(h'_{1})+Kt\poly(h_{2})\right),
\]

\end_inset

где коэффициент 
\begin_inset Formula $K\in\mathcal{K}$
\end_inset

 взят так, чтобы при сложении сократились старшие мономы и выполнилось 
\begin_inset Formula $\HM(h{}_{1})\prec_{0}\HM(h'{}_{1})$
\end_inset

.
 По сути такая редукция представляет из себя обычную редукцию многочлена
 с сокращением старшего монома, дополненную требованием того, что сигнатура
 редуктора меньше сигнатуры редуцируемого.
 Корректность проверяется как и выше.
\end_layout

\begin_layout Standard
Введём частичный порядок 
\begin_inset Formula $\GVWl$
\end_inset

 на 
\begin_inset Formula $H$
\end_inset

: 
\begin_inset Formula 
\[
h_{1}=(\sigma_{1},p_{1})\GVWl h_{2}=(\sigma_{2},p_{2})\equivdef\HM(p_{1})\sigma_{2}\prec_{0}\HM(p_{2})\sigma_{1}.
\]

\end_inset


\end_layout

\begin_layout Standard
Элементы с нулевой сигнатурой и старшим мономом оказываются экстремумами:
\begin_inset Formula 
\[
\forall\sigma_{1},\sigma_{2},p_{1},p_{2}\,\left(0,p_{1}\right)\not\GVWl\left(\sigma_{2},p_{2}\right),\,\left(\sigma_{1},0\right)\not\GVWg\left(\sigma_{2},p_{2}\right).
\]

\end_inset


\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset

.
 Тогда 
\begin_inset Formula $h_{1}\GVWg h_{2}\Leftrightarrow h_{1}\GVWg th_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Выводится из того, что умножение на 
\begin_inset Formula $t$
\end_inset

 одного из сравниваемых отмеченных многочленов приводит к умножению на 
\begin_inset Formula $t$
\end_inset

 обоих частей в определении 
\begin_inset Formula $\GVWg$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,\HM(h_{1})|\HM(h_{2}),\HM(h_{2})\neq0$
\end_inset

.
 Тогда редукция 
\begin_inset Formula $h_{2}$
\end_inset

 по 
\begin_inset Formula $h_{1}$
\end_inset

 с сохранением сигнатуры возможна если и только если 
\begin_inset Formula $h_{1}\GVWg h_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Следует из того что оба утверждения равносильны 
\begin_inset Formula $\Sig(h_{2})\succ_{0}\Sig(h_{1})\frac{\HM(h_{2})}{\HM(h_{1})}$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1}\in H$
\end_inset

 -- результат редукции 
\begin_inset Formula $h_{1}'$
\end_inset

 с сохранением сигнатур по некоторому многочлену.
 Тогда 
\begin_inset Formula $h_{1}\GVWl h_{1}'$
\end_inset

.
\end_layout

\begin_layout Proof
Следует из 
\begin_inset Formula $\Sig(h_{1})=\Sig(h_{1}')$
\end_inset

 и уменьшения 
\begin_inset Formula $\HM$
\end_inset

 при редукции: 
\begin_inset Formula $\HM(h_{1})\prec_{0}\HM(h_{1}').$
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:greater-or-smaller"

\end_inset

Пусть 
\begin_inset Formula $h_{1}\GVWl h_{2}$
\end_inset

 отмеченные многочлены.
 Тогда 
\begin_inset Formula $\forall h_{3}\in H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

 выполняется хотя бы одно из двух неравенств: 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

 или 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Из условия леммы известно, что
\begin_inset Formula 
\begin{equation}
\HM(h_{1})\Sig(h_{2})\prec_{0}\HM(h_{2})\Sig(h_{1})\label{eq:gvw-order-3}
\end{equation}

\end_inset

откуда 
\begin_inset Formula $\HM(h_{2})\neq0,\Sig(h_{1})\neq0$
\end_inset

.
 Поэтому, если 
\begin_inset Formula $\HM(h_{3})=0$
\end_inset

, имеем 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

, а если 
\begin_inset Formula $\Sig(h_{3})=0$
\end_inset

 -- то 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

.
 Иначе можно домножить неравенство 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:gvw-order-3"

\end_inset

 на ненулевой элемент 
\begin_inset Formula $\HM(h_{3})\Sig(h_{3})$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
\HM(h_{3})\Sig(h_{3})\HM(h_{1})\Sig(h_{2})\prec_{0}\HM(h_{3})\Sig(h_{3})\HM(h_{2})\Sig(h_{1}).\label{eq:left-or-right-monom}
\end{equation}

\end_inset

Поэтому 
\begin_inset Formula $\HM(h_{3})^{2}\Sig(h_{2})\Sig(h_{1})\in\mathbb{T}_{0}$
\end_inset

 будет или 
\begin_inset Formula $\succ_{0}$
\end_inset

 левой или 
\begin_inset Formula $\prec_{0}$
\end_inset

 правой части неравенства 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:left-or-right-monom"

\end_inset

, и после сокращения даст эквивалентное утверждению леммы неравенство.
\end_layout

\begin_layout Subsection
Алгоритм
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Вход: многочлены 
\begin_inset Formula $\{g_{1},\dots,g_{m}\}$
\end_inset

, образующие базис Грёбнера; многочлен 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Переменные: 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 -- подмножества 
\begin_inset Formula $H$
\end_inset

; 
\begin_inset Formula $(\sigma,p')\in H$
\end_inset

 -- отмеченный многочлен текущего шага до редукции; 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- он же после редукции; 
\begin_inset Formula $r,b$
\end_inset

 -- элементы 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(g_{1},\dots,g_{m},f\right)$
\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:SimpleSignatureGroebner"

\end_inset

SimpleSignatureGroebner
\begin_inset Formula $\left(\left\{ g_{1},\dots,g_{m}\right\} ,f\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\{\left(\HM(g_{1}),0\right),\left(\HM(g_{2}),0\right),\dots,\left(\HM(g_{m}),0\right),(0,g_{1}),(0,g_{2}),\dots,(0,g_{m})\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\sigma,p')\leftarrow(1,f)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do forever:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-before-reduce"

\end_inset


\begin_inset Formula $p\leftarrow$
\end_inset

ReduceCheckingSignatures(
\begin_inset Formula $\sigma,p',R$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-after-reduce"

\end_inset


\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-from-B"

\end_inset


\begin_inset Formula $B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\Sig(r)|\Sig(b)\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if 
\begin_inset Formula $B\neq\varnothing$
\end_inset

: 
\series default

\begin_inset Formula $(\sigma,p')\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate

\series bold
else: break
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)\,|\, r\in R\}$
\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:ReduceCheckingSignatures:"

\end_inset

ReduceCheckingSignatures
\begin_inset Formula $\left(\sigma,p,R\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $\exists r\in R\, r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

редуцировать 
\begin_inset Formula $p$
\end_inset

 с сохранением сигнатуры по 
\begin_inset Formula $\GVWg$
\end_inset

-максимальному элементу 
\begin_inset Formula $r$
\end_inset

 среди указанных в условии цикла
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Lemma
Все пары из 
\begin_inset Formula $\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

 в алгоритме -- элементы 
\begin_inset Formula $H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Proof
Элементы, формируемые до начала главного цикла, являются рассмотренными
 выше примерами отмеченных многочленов.
 Все остальные отмеченные многочлены в алгоритме формируются или умножением
 на 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

 или редукцией с сохранением сигнатуры, поэтому они корректны и лежат в
 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Условия циклов, расширяющих 
\begin_inset Formula $B$
\end_inset

, таковы, что в
\series bold
 
\series default

\begin_inset Formula $B$
\end_inset

 нет ни нулевых сигнатур, ни нулевых старших мономов.
 Поэтому 
\begin_inset Formula $\sigma$
\end_inset

 никогда не обращается в 0 и нулевые сигнатуры в 
\begin_inset Formula $R$
\end_inset

 лишь у элементов 
\begin_inset Formula $(0,g_{1}),...,(0,g_{m}).$
\end_inset

 Нулевой старший моном может быть у любого многочлена, добавляемого в 
\begin_inset Formula $R$
\end_inset

, а нулевых многочленов с одновременно нулевой сигнатурой в 
\begin_inset Formula $R$
\end_inset

 нет.
\end_layout

\begin_layout Subsection
Остановка алгоритма
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:exist-reductor"

\end_inset

В любой момент работы алгоритма любой отмеченный многочлен из 
\begin_inset Formula $B$
\end_inset

 может быть редуцирован с сохранением сигнатуры по некоторому элементу 
\begin_inset Formula $R.$
\end_inset


\end_layout

\begin_layout Proof
Отмеченные многочлены добавляются в 
\begin_inset Formula $B$
\end_inset

 таким образом, чтобы иметь хотя бы один подходящий редуктор.
 
\begin_inset Formula $(\sigma,p)\in R$
\end_inset

 является таким редуктором при добавлении в первом цикле 
\series bold
for
\series default
, 
\begin_inset Formula $r\in R$
\end_inset

 -- во втором.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-small"

\end_inset

До редукции многочлена 
\begin_inset Formula $p'$
\end_inset

, то есть на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-before-reduce"

\end_inset

 любой итерации алгоритма, сигнатуры элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $
\end_inset

 не делят 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
На первой итерации алгоритма это выполняется, поскольку 
\begin_inset Formula $\sigma=1$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

 не содержит элементы с сигнатурами, делящими 1.
 На последующих итерациях это выполнено, поскольку если бы в 
\begin_inset Formula $R$
\end_inset

 существовали такие элементы, то 
\begin_inset Formula $\left(\sigma,p'\right)$
\end_inset

 был бы убран из 
\begin_inset Formula $B$
\end_inset

 в предыдущей итерации на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-big"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, старшие мономы элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $
\end_inset

 не делят 
\begin_inset Formula $\HM(p)$
\end_inset

.
\end_layout

\begin_layout Proof
Вытекает из того, что цикл в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures:"

\end_inset

 останавливается по достижении 
\begin_inset Formula $p$
\end_inset

, для которого такие элементы в 
\begin_inset Formula $R$
\end_inset

 не существуют.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:adds-really-new"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, элементы 
\begin_inset Formula $R$
\end_inset

 не могут одновременно иметь старшие мономы, делящие 
\begin_inset Formula $\HM(p)$
\end_inset

, и сигнатуры, делящие 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor"

\end_inset

 будет произведена хотя бы одна редукция 
\begin_inset Formula $p'$
\end_inset

, поэтому 
\begin_inset Formula $(\sigma,p')\GVWg(\sigma,p)$
\end_inset

.
 Отсюда по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:greater-or-smaller"

\end_inset

 для 
\begin_inset Formula $\forall r\in R$
\end_inset

 имеем 
\begin_inset Formula $r\GVWg(\sigma,p)$
\end_inset

 или 
\begin_inset Formula $r\GVWl(\sigma,p')$
\end_inset

.
 Выполнение одного из неравенств позволяет применить одну из лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-small"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

.
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 останавливается
\end_layout

\begin_layout Proof
Для доказательства остановки нужно показать, что все циклы 
\series bold
do
\series default
 выполняются лишь конечное число раз.
 В 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures:"

\end_inset

 при ненулевых 
\begin_inset Formula $p$
\end_inset

 на каждой итерации 
\begin_inset Formula $\HM(p)$
\end_inset

 уменьшается по 
\begin_inset Formula $\prec_{0}$
\end_inset

, что возможно лишь конечное число раз.
 При обнулении 
\begin_inset Formula $p$
\end_inset

 он завершится в силу 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $(\sigma,0)$
\end_inset

.
\end_layout

\begin_layout Proof
На каждом шаге основного цикла пополняется множество 
\begin_inset Formula $R\subset\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

.
 Оно может быть разбито как 
\begin_inset Formula $R_{*0}\cup R_{0*}\cup R_{**},$
\end_inset

 где 
\begin_inset Formula $R_{*0}\subset\mathbb{T}\times\left\{ 0\right\} ,R_{0*}\subset\left\{ 0\right\} \times\mathcal{P}\setminus\left\{ 0\right\} ,R_{**}\subset\mathbb{T}\times\mathcal{P}\setminus\left\{ 0\right\} $
\end_inset

.
 
\begin_inset Formula $R_{0*}$
\end_inset

 не пополняется в силу 
\begin_inset Formula $\sigma\neq0$
\end_inset

.
 Для 
\begin_inset Formula $R_{*0}$
\end_inset

 и 
\begin_inset Formula $R_{**}$
\end_inset

 применим подход, основанный на понятии идеалов моноидов, предложенном в
 
\begin_inset CommandInset citation
LatexCommand cite
key "KreuzerRobbianoBook1"

\end_inset

 как ``monoid ideal''.
 Рассмотрим следующие множества, являющиеся идеалами моноидов: 
\begin_inset Formula $L_{*0}=\left(\left\{ \sigma\,|\,(\sigma,0)\in R_{*0}\right\} \right)\subset\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $L_{**}=\left(\left\{ (\sigma,t)\,|\,\exists(\sigma,p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$
\end_inset

.
 В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new"

\end_inset

 добавляемые в 
\begin_inset Formula $R$
\end_inset

 элементы расширяют на каждом шаге 
\begin_inset Formula $L_{*0}$
\end_inset

 или 
\begin_inset Formula $L_{**}$
\end_inset

.
 Поскольку моноиды 
\begin_inset Formula $\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\mathbb{T}\times\mathbb{T}$
\end_inset

 изоморфны 
\begin_inset Formula $\mathbb{N}^{n}$
\end_inset

 и 
\begin_inset Formula $\mathbb{N}^{2n}$
\end_inset

, к их идеалам может быть применена лемма Диксона, которая и утверждает,
 что расширение может происходить лишь конечное число раз.
\end_layout

\begin_layout Subsection
Корректность результата
\end_layout

\begin_layout Definition

\emph on
S-представлением
\emph default
 
\begin_inset Formula $h\in H$
\end_inset

 над множеством 
\begin_inset Formula $\left\{ r_{i}\right\} \subset H$
\end_inset

 будем называть выражение 
\begin_inset Formula $\poly(h)=\sum_{j}K_{j}t_{j}\poly(r_{i_{j}}),$
\end_inset

 
\begin_inset Formula $K_{j}\in\mathcal{K},t_{j}\in\mathbb{T},i_{j}\in\mathbb{N}$
\end_inset

, такое что 
\begin_inset Formula $\forall j\,\HM(h)\succcurlyeq_{0}\HM(t_{j}r_{i_{j}}),\Sig(h)\succcurlyeq_{0}\Sig(t_{j}r_{i_{j}})$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:one-j-exact"

\end_inset

Пусть 
\begin_inset Formula $\poly(h)=\sum_{j}K_{j}t_{j}\poly(r_{i_{j}})$
\end_inset

 -- S-представление для 
\begin_inset Formula $h$
\end_inset

.
 Тогда для хотя бы одного 
\begin_inset Formula $j$
\end_inset

 достигается 
\begin_inset Formula $\HM(h)=\HM(t_{j}r_{i_{j}})$
\end_inset

.
\end_layout

\begin_layout Proof
В качестве такого 
\begin_inset Formula $j$
\end_inset

 можно взять то, на котором достигается 
\begin_inset Formula $\succ$
\end_inset

-максимум 
\begin_inset Formula $\HM(t_{j}r_{i_{j}})$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее определение расширяет понятие S-базиса из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

:
\end_layout

\begin_layout Definition
Назовём 
\begin_inset Formula $R\subset H$
\end_inset


\emph on
 S-базисом
\emph default
 (соответственно 
\emph on
S
\begin_inset Formula $_{\sigma}$
\end_inset

-базисом
\emph default
), если все элементы 
\begin_inset Formula $H$
\end_inset

 (соответственно 
\begin_inset Formula $\left\{ h\in H\,|\,\Sig(h)\prec_{0}\sigma\right\} $
\end_inset

)
\emph on
 
\emph default
имеют S-представление
\emph on
 
\emph default
над 
\begin_inset Formula $R$
\end_inset


\emph on
.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:s-basis-and-no-reductions"

\end_inset

Пусть 
\begin_inset Formula $\sigma\succ_{0}0,R=\left\{ r_{i}\right\} $
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис и выбраны 
\begin_inset Formula $h_{1},h_{2}\in H,\Sig(h_{i})=\sigma$
\end_inset

, которые не редуцируются по 
\begin_inset Formula $R$
\end_inset

 с сохранением сигнатуры.
 Тогда 
\begin_inset Formula $\HM(h_{1})=\HM(h_{2})$
\end_inset

 и у 
\begin_inset Formula $h_{1}$
\end_inset

 есть S-представление над 
\begin_inset Formula $R\cup\left\{ h_{2}\right\} $
\end_inset

.
\end_layout

\begin_layout Proof
Из определения 
\begin_inset Formula $H$
\end_inset

 имеем 
\begin_inset Formula $\exists u_{i}\in\mathcal{P}\,\HM(u_{i})=\sigma,u_{i}f\equiv\poly(h_{i})\pmod{I_{0}},i=1,2.$
\end_inset

 Значит некоторой линейной комбинации 
\begin_inset Formula $\poly(h_{i})$
\end_inset

 сопоставляется 
\begin_inset Formula $\prec_{0}\sigma$
\end_inset

 сигнатура: 
\begin_inset Formula 
\[
\exists K\in\mathcal{K},v\in\mathcal{P}\,\HM(v)=\sigma'\prec_{0}\sigma,vf\equiv\poly(h_{1})-K\poly(h_{2})\pmod{I_{0}},
\]

\end_inset

то есть 
\begin_inset Formula $\left(\sigma',p'\right)=\left(\sigma',\poly(h_{1})-K\poly(h_{2})\right)\in H$
\end_inset

.
 Из определения S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базиса и 
\begin_inset Formula $\sigma'\prec_{0}\sigma$
\end_inset

 вытекает 
\begin_inset Formula $\exists r_{j}\in R,t\in\mathbb{T}\,\Sig(tr_{j})\preccurlyeq_{0}\sigma',\HM(tr_{j})=\HM(p')$
\end_inset

.
 Отсюда 
\begin_inset Formula $\HM(h_{i})\neq\HM(p'),i=1,2$
\end_inset

, иначе 
\begin_inset Formula $r_{j}$
\end_inset

 редуцировало бы 
\begin_inset Formula $h_{i}$
\end_inset

 с сохранением сигнатуры.
 Значит, 
\begin_inset Formula $\HM(h_{i})$
\end_inset

 сокращаются при вычитании с 
\begin_inset Formula $\mathcal{K}$
\end_inset

-коэффициентом, что даёт 
\begin_inset Formula $\HM(h_{1})=\HM(h_{2})$
\end_inset

.
 S-представление 
\begin_inset Formula $h_{1}$
\end_inset

 получается добавлением 
\begin_inset Formula $K\poly(h_{2})$
\end_inset

 к S-представлению 
\begin_inset Formula $\left(\sigma',p'\right)$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-r-sigma"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен инвариант: для 
\begin_inset Formula $\forall\sigma\in\mathbb{T},\sigma\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, найдутся 
\begin_inset Formula $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\Sig(t_{\sigma}r_{\sigma})=\sigma$
\end_inset

 и 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 не редуцируется по 
\begin_inset Formula $R$
\end_inset

 с сохранением сигнатуры.
\end_layout

\begin_layout Proof
Множество 
\begin_inset Formula $R_{\sigma}=\left\{ r\in R\,|\,\Sig(r)|\sigma\right\} $
\end_inset

 непусто, так как содержит добавленный на первой итерации элемент 
\begin_inset Formula $r_{0}$
\end_inset

 с 
\begin_inset Formula $\Sig(r_{0})=1$
\end_inset

.
 Обозначим за 
\begin_inset Formula $r_{\sigma}$
\end_inset

 его 
\begin_inset Formula $\GVWl$
\end_inset

-минимальный элемент; положим 
\begin_inset Formula $t_{\sigma}=\frac{\sigma}{\Sig(r_{\sigma})}$
\end_inset

.
 Предположим, что 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 может быть редуцирован с сохранением сигнатуры относительно некоторого
 
\begin_inset Formula $r_{1}\in R$
\end_inset

.
 Отсюда следует, что 
\begin_inset Formula $r_{1}\GVWg r_{\sigma}$
\end_inset

, а также что они не нулевые.
 Значит на той же итерации, когда в 
\begin_inset Formula $R$
\end_inset

 был добавлен последний из 
\begin_inset Formula $\{r_{\sigma},r_{1}\}$
\end_inset

, в множество 
\begin_inset Formula $B$
\end_inset

 был добавлен многочлен 
\begin_inset Formula $t'r_{\sigma}$
\end_inset

, где 
\begin_inset Formula $t'=\frac{\LCM(\HM(r_{1}),\HM(r_{\sigma}))}{\HM(r_{\sigma})}$
\end_inset

, причём 
\begin_inset Formula $t'|t_{\sigma}$
\end_inset

.
 Отсюда 
\begin_inset Formula $\Sig(t'r_{\sigma})|\Sig(t_{\sigma}r_{\sigma})=\sigma\Rightarrow\Sig(t'r_{\sigma})\preccurlyeq\sigma\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

.
 В силу этого неравенства на сигнатуры получается, что 
\begin_inset Formula $t'r_{\sigma}$
\end_inset

 уже не может быть элементом 
\begin_inset Formula $B$
\end_inset

, а значит был выкинут на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 одной из итераций, то есть 
\begin_inset Formula $\exists r_{2}\in R\, r_{2}\GVWl t'r_{\sigma},\Sig(r_{2})|\Sig(t'r_{\sigma})$
\end_inset

.
 Это невозможно, поскольку влечёт 
\begin_inset Formula $r_{2}\GVWl r_{\sigma},r_{2}\in R_{\sigma}$
\end_inset

, что противоречит 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $r_{\sigma}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:has-s-repr"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен инвариант: 
\begin_inset Formula $\forall h\in H,\Sig(h)\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, имеет S-представление над 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим нарушение инварианта на какой-то итерации и рассмотрим 
\begin_inset Formula $\prec_{0}$
\end_inset

-минимальную 
\begin_inset Formula $\sigma$
\end_inset

, для которой непусто 
\begin_inset Formula $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\Sig(h)=\sigma\}$
\end_inset

.
 Тогда 
\begin_inset Formula $R$
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис.
 
\begin_inset Formula $\forall g\in I_{0}\,\left(0,g\right)$
\end_inset

 имеют S-представления над 
\begin_inset Formula $\{(0,g_{1}),...,(0,g_{m})\}\subset R$
\end_inset

, поэтому 
\begin_inset Formula $\sigma\succ_{0}0$
\end_inset

.
 Выберем 
\begin_inset Formula $v_{\sigma}$
\end_inset

 -- один из элементов 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\prec_{0}$
\end_inset

-наименьшим 
\begin_inset Formula $\HM$
\end_inset

.
 Он не может быть редуцирован с сохранением сигнатуры по 
\begin_inset Formula $R$
\end_inset

, поскольку результат редукции 
\begin_inset Formula $v_{1}$
\end_inset

 был бы элементом 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\HM(v_{1})\prec_{0}\HM(v_{\sigma})$
\end_inset

.
 Возьмём 
\begin_inset Formula $w_{\sigma}\eqdef t_{\sigma}r_{\sigma}$
\end_inset

 из инварианта теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-r-sigma"

\end_inset

 и применим лемму 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:s-basis-and-no-reductions"

\end_inset

 к 
\begin_inset Formula $v_{\sigma},w_{\sigma}$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

.
 Получим что 
\begin_inset Formula $v_{\sigma}$
\end_inset

 имеет S-представление над 
\begin_inset Formula $R\cup\{w_{\sigma}\}$
\end_inset

.
 Вхождения 
\begin_inset Formula $w_{\sigma}$
\end_inset

 в нём можно заменить на 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

, получив представление 
\begin_inset Formula $v_{\sigma}$
\end_inset

 над 
\begin_inset Formula $R$
\end_inset

, что приводит к противоречию.
\end_layout

\begin_layout Lemma
Если 
\begin_inset Formula $R$
\end_inset

 -- S-базис, то 
\begin_inset Formula $\{\poly(r)\,|\, r\in R\}$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

.
\end_layout

\begin_layout Proof
Для 
\begin_inset Formula $\forall p\in I$
\end_inset

 можно взять некоторый 
\begin_inset Formula $h=\left(\sigma,p\right)\in H$
\end_inset

 и применить лемму 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:one-j-exact"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 возвращает базис Грёбнера
\end_layout

\begin_layout Proof
К моменту остановки 
\begin_inset Formula $B=\varnothing$
\end_inset

, значит по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr"

\end_inset

 
\begin_inset Formula $R$
\end_inset

 -- S-базис.
\end_layout

\begin_layout Subsection
Сравнение с аналогами
\end_layout

\begin_layout Standard
Представленный алгоритм принадлежит к семейству алгоритмов вычисления базисов
 Грёбнера, использующих сигнатуры, которые вычисляют S-базис и в той или
 иной степени являются модификациями алгоритма F5 из 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

.
 Одно из основных направлений его модификации -- упрощение теоретических
 обоснований и расширение области применимости -- представлено в 
\begin_inset CommandInset citation
LatexCommand cite
key "GermanF5Proof,ZobninGeneralization,F5InBBStyle"

\end_inset

.
 Другое -- повышение эффективности путём ввода дополнительных критериев
 отбрасывания некоторых вычислений -- описывается в 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C,G2V,SignatureBasedGBs"

\end_inset

 и позволяет проводить вычисления так, чтобы до конца редуцировались лишь
 многочлены, являющиеся новыми элементами S-базиса или дающие новую сигнатуру
 нулевого многочлена, расширяющую идеал моноида, содержащий такие сигнатуры,
 называемые также 
\emph on
сигнатурами сизигий.

\emph default
 Обобщение с одновременным применением всех критериев в алгоритмах TRB-MJ
 и SB 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception,PracticalGB"

\end_inset

 позволяет добиться большей эффективности благодаря тому, что все отбрасывания
 применяются до проведения таких вычислительно трудоёмких операций, как
 редукция многочлена или подсчёт старшего монома S-пары, -- в результате
 не оказывается, что результаты каких-то вычислений были отброшены.
\end_layout

\begin_layout Standard
Во всех упомянутых алгоритмах, включая немодифицированный F5, формулируется
 два типа критериев отброса: критерии, связанные с сизигиями, и критерии
 перезаписи, корректность каждого из которых доказывается независимо.
 Также, даже в алгоритмах, не вычисляющих S-полиномы явно, теоретическое
 обоснование корректности алгоритма на них опирается.
\end_layout

\begin_layout Standard
Данная работа описывает алгоритм вычисляющий минимальный S-базис и осуществляющи
й отброс вычислений не менее эффективно, чем в TRB-MJ, но использующий лишь
 единственный критерий отброса на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

, основанный на 
\begin_inset Formula $\GVWl$
\end_inset

-упорядочивании множества 
\begin_inset Formula $R$
\end_inset

.
 Вопрос наиболее эффективного способа выбора редуктора в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures:"

\end_inset

 является открытым.
 Представленный в этой работе способ выбора основан на всё том же упорядочении
 
\begin_inset Formula $R$
\end_inset

 и совпадает для случая однородных многочленов со способом выбора, применявшемся
 в алгоритме F5.
 Теоретическое обоснование сформулировано без S-полиномов и позволяет применять
 к нему простую алгебраическую интерпретацию из 
\begin_inset CommandInset citation
LatexCommand cite
key "ZobninGeneralization"

\end_inset

.
\end_layout

\begin_layout Standard
Упрощение формулировки алгоритма повлекло значительное уменьшение времени
 на его реализацию и отладку на компьютере по сравнению с аналогами, как
 за счёт меньшего количества множеств, так и за счёт общего для критериев
 отбрасывания и процедуры редукции порядка.
 Простота реализации и нетребовательность к структурам данных позволяет
 за небольшое время внедрять эффективную версию алгоритма в любую систему
 компьютерной алгебры.
 Реализация, упоминаемая ниже, была создана автором за 8 часов, что на порядок
 меньше, чем время, затраченное автором на экспериментальные реализации
 других алгоритмов в подобных условиях.
 Доказательство, основанное на инвариантах в терминах S-представлений, позволило
 сделать работу алгоритма более прозрачной с алгебраической точки зрения
 и потенциально расширяемым на объекты, обобщающие кольцо многочленов над
 полем.
\end_layout

\begin_layout Standard
Алгоритм был реализован на С++ с использованием функций ядра программного
 комплекса Singular 3-1-4 и открытых наработок Кристиана Эдера (одного из
 авторов 
\begin_inset CommandInset citation
LatexCommand cite
key "SignatureBasedGBs"

\end_inset

) по реализации F5-подобных алгоритмов на этом ядре.
 Исходный код реализации содержится в функции ssg файла, доступного по адресу
 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc"

\end_inset


\end_layout

\begin_layout Standard
Сравнение реализации SimpleSignatureGroebner с другими алгоритмами вычисления
 базисов Грёбнера, реализованных Кристианом Эдером подтвердили следующие
 соображения:
\end_layout

\begin_layout Itemize
алгоритм SimpleSignatureGroebner корректно вычисляет базис Грёбнера;
\end_layout

\begin_layout Itemize
результат содержит не большее число многочленов, чем результат других инкремента
льных алгоритмов, возвращающих S-базис;
\end_layout

\begin_layout Itemize
время работы алгоритма оказывается не больше, чем у других инкрементальных
 алгоритмов, основанных на сигнатурах.
\end_layout

\begin_layout Subsection
Вариант без итераций
\end_layout

\begin_layout Standard
[Построение варианта без итераций и доказательство корректности работы с
 произвольным порядком на сигнатурах]
\end_layout

\begin_layout Subsection
Взвешенные порядки
\end_layout

\begin_layout Standard
[Общее определение, порядок Schreyer]
\end_layout

\begin_layout Part
Решение систем полиномиальных уравнений
\end_layout

\begin_layout Standard
[Метод использующий, матрицу линейного оператора и базис краёв]
\end_layout

\begin_layout Section
Задачи с приближёнными входными данными
\end_layout

\begin_layout Standard
[Символический метод, приближённая арифметика, интервальная арифметика]
\end_layout

\begin_layout Section
Проблемы применения алгоритмов Базиса Грёбнера в интервальной арифметике
\end_layout

\begin_layout Standard
[Влияние нулей на процесс вычисления]
\end_layout

\begin_layout Subsection
Символические нули
\end_layout

\begin_layout Standard
[Пример того, когда ноль при любом значении параметра]
\end_layout

\begin_layout Subsection
Приближённые нули, порождаемые входными данными
\end_layout

\begin_layout Standard
[Пример того, когда ноль выражает существующую зависимость во входных данных.
 Примеры устранимой (
\begin_inset Formula $\varepsilon x+y+1$
\end_inset

) и неустранимой (
\begin_inset Formula $\varepsilon x+1$
\end_inset

) зависимости.
 Хорошо бы с определениями, если удастся сформулировать]
\end_layout

\begin_layout Subsection
Приближённые нули, порождаемые вычислениями
\end_layout

\begin_layout Standard
[Пример - во многом готов, адаптировать к SSG-Shreyer]
\end_layout

\begin_layout Standard
Рассмотрим задачу нахождения базиса Грёбнера с точки зрения порядка degrevlex(
\begin_inset Formula $x,y,z$
\end_inset

) для идеала, заданного многочленами с параметрами 
\begin_inset Formula $a$
\end_inset

 и 
\begin_inset Formula $b$
\end_inset

: 
\begin_inset Formula 
\[
g_{1}=y^{2}z+z^{2}+az
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{2}=xyz
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{3}=xy^{2}+bx+1
\]

\end_inset


\end_layout

\begin_layout Standard
Применим алгоритм Бухбергера:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{4}=S(g_{1},g_{2})=xz^{2}+axz
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{5}=S(g_{1},g_{3})=-xz^{2}+(b-a)xz+z
\]

\end_inset


\end_layout

\begin_layout Standard
что после редукции по 
\begin_inset Formula $g_{4}$
\end_inset

 даёт:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(1-1)xz^{2}+(a+(b-a))xz+z=(a+(b-a))xz+z
\]

\end_inset


\end_layout

\begin_layout Standard
При вычислениях с ограниченной точностью или в интервальной арифметике выражения
 вида 
\begin_inset Formula $(a+(b-a))xz+z$
\end_inset

 с фиксированным значением параметра 
\begin_inset Formula $a$
\end_inset

 может произойти потеря точности в ведущем коэффициенте многочлена, особенно
 если абсолютная точность значения 
\begin_inset Formula $a$
\end_inset

 много меньше абсолютной точности значения значения 
\begin_inset Formula $b$
\end_inset

.
 Если же проводить вычисление базиса символически, и подставить конкретные
 значения параметров в результат -- точность полученного результата будет
 больше.
\end_layout

\begin_layout Section
Вычисления для борьбы с нулями
\end_layout

\begin_layout Standard
[Символические вычисления, вычисления над конечными полями с полной полиномиальн
ой сигнатурой, теорема из дипломной работы]
\end_layout

\begin_layout Subsection
Борьба с устранимыми нулями
\end_layout

\begin_layout Standard
[Идея Фожера о замене переменных, применение расширенного базиса к задаче
 решения системы; недостатки используемого Фожером подхода с перезапуском
 алгоритма при каждом обнаружении нуля]
\end_layout

\begin_layout Subsection
Использование взвешенного порядка
\end_layout

\begin_layout Standard
[Модификация алгоритма SSG для борьбы с устранимыми нулями путём добавления
 многочленов 
\begin_inset Formula $m_{i}-\varepsilon_{i}$
\end_inset

 с правильными сигнатурными весами]
\end_layout

\begin_layout Section
Заключение
\end_layout

\begin_layout Standard
[Построен алгоритм, позволяющий численно решать системы полиномиальных уравнений
, комбинирующий один из самых эффективных методов вычисления Базисов Грёбнера
 с методиками численной устойчивости]
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "f5_references_1251"
options "vestnik"

\end_inset


\end_layout

\end_body
\end_document
