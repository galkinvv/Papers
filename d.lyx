#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\input{gost/babelbst.tex}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\begin_local_layout

\end_local_layout
\language russian
\language_package babel
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 7
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWl}{<_{\text{H}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWg}{>_{\text{\textnormal{H}}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\eqdef}{\overset{\mathrm{_{def}}}{=}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\equivdef}{\overset{\mathrm{_{def}}}{\Leftrightarrow}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Sig}{\mathcal{S}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\HM}{\mathrm{HM}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\HC}{\mathrm{HC}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\LCM}{\mathrm{LCM}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\totaldeg}{\mathrm{deg}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\poly}{\mathrm{poly}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\sigidx}{\mathrm{index}}
\end_inset


\end_layout

\begin_layout Title
Алгоритмы вычисления Базисов Грёбнера, основанные на сигнатурах
\end_layout

\begin_layout Author
Василий Галкин
\end_layout

\begin_layout Address
МГУ
\end_layout

\begin_layout Address
galkin-vv@ya.ru
\end_layout

\begin_layout Abstract
Основное направление данной работы -- построение эффективного способа применения
 алгоритмов, основанных на сигнатурах, для решения полиномиальных уравнений.
 В первой части показана остановка алгоритм F5, предложенного Фожером, и
 описан его вариант, значительно упрощающий реализацию и теоретическое обоснован
ие.
 Во второй части показано, как данная вариация может быть модифицирована
 для эффективного решения полиномиальных систем уравнений в интервальной
 арифметике путём ввода новых переменных и дополнительных вычислений над
 конечными полями.
\end_layout

\begin_layout Part
Вычисление базисов Грёбнера
\end_layout

\begin_layout Standard
Для работы с базисами Грёбнера необходимо договориться об обозначениях,
 которые будут использоваться на протяжении всего текста:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{K}$
\end_inset

 -- некоторое поле
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

 -- абстрактное множество переменных
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{T}$
\end_inset

 -- множество мономов, образуемых этими переменными.
 Является коммутативным моноидом по операции умножения мономов
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{T}_{0}=\mathbb{T}\cup\left\{ 0\right\} $
\end_inset

 -- формально расширенное нулём множество мономов.
 Операция умножения расширяется как 
\begin_inset Formula $\forall t\in\mathbb{T}_{0}\, t\cdot0=0$
\end_inset

.
 Является коммутативной полугруппой по этой операции.
 Понятие делимости в 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 стандартно: 
\begin_inset Formula $t_{1}|t_{2}\eqdef\exists t_{3}\, t_{1}\cdot t_{3}=t_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}$
\end_inset

 -- кольцо многочленов 
\begin_inset Formula $\mathcal{K}[x_{1},\dots,x_{n}]$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\totaldeg(t)\in\mathbb{Z}$
\end_inset

 -- полная степень монома 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset


\end_layout

\begin_layout Definition
Полный порядок 
\begin_inset Formula $\prec$
\end_inset

 на 
\begin_inset Formula $\mathbb{T}$
\end_inset

 называется 
\emph on
мономиальным
\emph default
, если он делает 
\begin_inset Formula $\mathbb{T}$
\end_inset

 вполне упорядоченным, а также 
\begin_inset Formula $\forall t_{1},t_{2},t_{3}\in\mathbb{T}$
\end_inset

 выполняется:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
t_{1}\prec t_{2}\Longrightarrow t_{1}t_{3}\prec t_{2}t_{3}
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
1\preccurlyeq t_{1}
\]

\end_inset


\end_layout

\begin_layout Lemma
Для мономиального порядка 
\begin_inset Formula $\forall t_{1},t_{2},t_{3}\in\mathbb{T}$
\end_inset

 выполняется: 
\begin_inset Formula 
\[
t_{1}\prec t_{2}\Longleftrightarrow t_{1}t_{3}\prec t_{2}t_{3}
\]

\end_inset


\end_layout

\begin_layout Proof
Заметим, что поскольку порядок полный, из неравенства 
\begin_inset Formula $t_{1}t_{3}\prec t_{2}t_{3}$
\end_inset

 вытекает что 
\begin_inset Formula $t_{1}\ne t_{2}$
\end_inset

 и значит
\begin_inset Formula 
\[
\left[\begin{array}{c}
t_{1}\prec t_{2}\\
t_{1}\succ t_{2}
\end{array}\right..
\]

\end_inset

Второе при этом невозможно, поскольку тогда из определения бы следовало,
 что 
\begin_inset Formula $t_{1}t_{3}\succ t_{2}t_{3}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\prec$
\end_inset

 -- зафиксированный мономиальный порядок на 
\begin_inset Formula $\mathbb{T}$
\end_inset

.
 Минимальным элементом является 
\begin_inset Formula $1\in\mathbb{T}$
\end_inset

, то есть пустое произведение
\end_layout

\begin_layout Itemize
\begin_inset Formula $\prec_{0}$
\end_inset

 -- порядок 
\begin_inset Formula $\prec$
\end_inset

, продолженный на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 заданием 
\begin_inset Formula $1\succ_{0}0$
\end_inset

.
 Легко показать, что он делает 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 вполне упорядоченным
\end_layout

\begin_layout Itemize
\begin_inset Formula $\HM(p)\in\mathbb{T}_{0}$
\end_inset

 -- старший моном многочлена, определён для 
\begin_inset Formula $\forall p\in\mathcal{P}$
\end_inset

; при 
\begin_inset Formula $p\neq0$
\end_inset

 равен старшему по 
\begin_inset Formula $\prec$
\end_inset

 моному, а для 
\begin_inset Formula $p=0$
\end_inset

 определён как 
\begin_inset Formula $\HM(0)=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\HC(p)\in\mathcal{K}$
\end_inset

 -- старший коэффициент многочлена, определён для 
\begin_inset Formula $\forall p\in\mathcal{P}$
\end_inset

; при 
\begin_inset Formula $p\neq0$
\end_inset

 равен коэффициенту при старшем по 
\begin_inset Formula $\prec$
\end_inset

 моному, а для 
\begin_inset Formula $p=0$
\end_inset

 определён как 
\begin_inset Formula $\HC(0)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LCM(t_{1},t_{2})\in\mathbb{T}$
\end_inset

 -- наименьшее общее кратное мономов 
\begin_inset Formula $t_{1},t_{2}\in\mathbb{T}$
\end_inset

.
 
\end_layout

\begin_layout Definition
Ненулевой многочлен 
\begin_inset Formula $g$
\end_inset

 
\emph on
редуцирует
\emph default
 ненулевой многочлен 
\begin_inset Formula $f$
\end_inset

, если 
\begin_inset Formula $\HM(g)|\HM(f)$
\end_inset

.
 
\emph on
Результатом редукции
\emph default
 называется многочлен 
\begin_inset Formula $h=f-\frac{\HC(f)\HM(f)}{\HC(g)\HM(g)}g$
\end_inset

.
 Он может быть нулевой и для него выполняется 
\begin_inset Formula $\HM(h)\prec_{0}\HM(f)$
\end_inset

.
 Конечная или бесконечная последовательность 
\begin_inset Formula $\left\{ f,f_{1},f_{2},...\right\} $
\end_inset

 называется 
\emph on
последовательностью редукций 
\emph default
по элементам 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 многочлена 
\begin_inset Formula $f$
\end_inset

, если каждый следующий элемент есть результат редукции предыдущего по некотором
у многочлену из 
\begin_inset Formula $G$
\end_inset

.
 Многочлен называется 
\emph on
нередуцируемым
\emph default
 по множеству, если ни один из элементов множества не редуцирует его.
 
\emph on
Результатом редукции многочлена 
\emph default

\begin_inset Formula $f$
\end_inset


\emph on
 по множеству 
\emph default

\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 называется последний элемент в последовательности редукций, которую нельзя
 продолжить.
 Результат редукции по множеству нередуцируем по нему.
\end_layout

\begin_layout Standard
Определение редукции зависит от порядка.
 На его основе дадим самое простое определение базиса Грёбнера:
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gb-def-1"

\end_inset

Множество 
\begin_inset Formula $G\subset I$
\end_inset

 называется 
\emph on
базисом Грёбнера
\emph default
 идеала 
\begin_inset Formula $I$
\end_inset

 кольца 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для порядка 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall f\in I,f\neq0\exists g\in G$
\end_inset

, редуцирующий 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Lemma
Если множество 
\begin_inset Formula $G\subset I$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 есть конечная последовательность редукций по элементам 
\begin_inset Formula $G$
\end_inset

, начинающаяся с 
\begin_inset Formula $f$
\end_inset

 и заканчивающаяся нулём.
\end_layout

\begin_layout Proof
Она может быть получена последовательным проведением редукций до тех пор,
 пока не будет получен нулевой многочлен.
 Конечность этой операции гарантируется тем, что каждая редукция уменьшает
 
\begin_inset Formula $\HM$
\end_inset

 по 
\begin_inset Formula $\prec_{0}$
\end_inset

, а множество 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 вполне упорядочено.
\end_layout

\begin_layout Standard
Для алгоритмов вычисления базиса Грёбнера будет полезна некоторая переформулиров
ка этого определения, для которой вводятся понятия представлений отчасти
 заимствованные из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 Представления используются для описания способов, которыми многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан как комбинация многочленов из множества 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Definition
Для фиксированного множества 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 назовём 
\emph on
представлением над 
\begin_inset Formula $G$
\end_inset

 
\emph default
многочлена 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 любую соответствующую верному равенству в 
\begin_inset Formula $\mathcal{P}$
\end_inset

 запись вида
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot g_{i_{k}},\; g_{i_{k}}\in G
\]

\end_inset

с коэффициентами 
\begin_inset Formula $m_{k}=c_{k}t_{k}\in\mathcal{K}\times\mathbb{T}$
\end_inset

, в которой все пары 
\begin_inset Formula $\left(t_{k},g_{i_{k}}\right)$
\end_inset

 различны и коэффициенты 
\begin_inset Formula $c_{k}\ne0$
\end_inset

.
 Символические произведения 
\begin_inset Formula $m_{k}\cdot g_{i_{k}}$
\end_inset

 называются 
\emph on
элементами
\emph default
 представления.
 Если рассмотреть это символическое произведение как умножение многочленов,
 то мы получим многочлен 
\begin_inset Formula $m_{k}g_{i_{k}}$
\end_inset

, соответствующий элементу представления.
 Тогда 
\begin_inset Formula $p$
\end_inset

 оказывается равным сумме отмеченных многочленов, соответствующих элементам
 его представления.
 Два представления равны, если наборы их элементов совпадают как множества.
 Поскольку правая часть представления лежит в идеале 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\left(G\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang russian
, представление может существовать лишь для 
\begin_inset Formula $p\in\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Понятие представления не зависит от порядка 
\begin_inset Formula $\prec$
\end_inset

.
 Для базисов Грёбнера нужна следующая разновидность представлений, определение
 которой уже зависит от порядка:
\end_layout

\begin_layout Definition
Представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

 называется 
\emph on
степенным
\emph default
, если 
\begin_inset Formula $\forall k\,\HM(m_{k}g_{i_{k}})\preccurlyeq\HM(p)$
\end_inset

.
\end_layout

\begin_layout Standard
Дадим несколько примеров представлений над множеством 
\begin_inset Formula $G=\{y,y^{2},x^{2}+y\}\subset\mathbb{R}[x,y]$
\end_inset

 с лексикографическим порядком, заданным 
\begin_inset Formula $x\succ y$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $y=1\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}=y\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}=y\cdot(x^{2}+y)-x^{2}\cdot y$
\end_inset

 -- представление, не являющееся степенным
\end_layout

\begin_layout Itemize
\begin_inset Formula $0=1\cdot y^{2}-y\cdot y$
\end_inset

 -- представление, не являющееся степенным
\end_layout

\begin_layout Itemize
\begin_inset Formula $0=0$
\end_inset

 (сумма нуля элементов) -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}=1\cdot(x^{2}+y)-1\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}y=y\cdot y+y\cdot(x^{2}+y)-2y\cdot y$
\end_inset

 -- не является представлением, так как первый и последний элементы отличаются
 лишь коэффициентом
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}y+y^{2}=y\cdot y+y\cdot(x^{2}+y)-1\cdot y^{2}$
\end_inset

 -- степенное представление, так как первый и последний элементы отличаются
 как пары, хотя и равны как многочлены.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exist-hm-in-deg-repr"

\end_inset

В степенном представлении 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 существует элемент 
\begin_inset Formula $m_{K}\cdot g_{i_{K}}$
\end_inset

, для которого 
\begin_inset Formula $\HM(p)=\HM(m_{K}g_{i_{K}})$
\end_inset


\end_layout

\begin_layout Proof
Выберем любой из элементов представления с 
\begin_inset Formula $\succ$
\end_inset

-максимальным среди элементов старшим мономом 
\begin_inset Formula $m$
\end_inset

.
 Из определения степенного представления имеем 
\begin_inset Formula $m\preccurlyeq\HM(p)$
\end_inset

.
 С другой стороны, поскольку сумма всех элементов даёт 
\begin_inset Formula $p$
\end_inset

, хотя бы один из них обязан иметь старший моном не меньше 
\begin_inset Formula $\HM(p)$
\end_inset

.
 Таким образом 
\begin_inset Formula $m=\HM(p)$
\end_inset

 и выбранный элемент -- искомый.
\end_layout

\begin_layout Standard
Теперь можно сформулировать эквивалентное определение для базиса Грёбнера:
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gb-def-2"

\end_inset

Множество 
\begin_inset Formula $G\subset I$
\end_inset

 называется 
\emph on
базисом Грёбнера
\emph default
 идеала 
\begin_inset Formula $I$
\end_inset

 кольца 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для порядка 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall f\in I$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Theorem
Определения 
\begin_inset CommandInset ref
LatexCommand ref
reference "gb-def-1"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "gb-def-2"

\end_inset

 эквивалентны
\end_layout

\begin_layout Proof
Если множество 
\begin_inset Formula $G$
\end_inset

 удовлетворяет второму определению, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 один из элементов степенного представления может быть взят в качестве редуцирую
щего.
\end_layout

\begin_layout Proof
Если множество 
\begin_inset Formula $G$
\end_inset

 удовлетворяет первому определению, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 степенное представление может быть получено как последовательность вычитаемых
 элементов в последовательности редукций 
\begin_inset Formula $f$
\end_inset

 к нулю по элементам 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
При зафиксированных кольце многочленов и порядке на мономах для постановки
 задачи вычисления базисов Грёбнера необходимо задать идеал 
\begin_inset Formula $I\subset\mathcal{P}$
\end_inset

.
 Все алгоритмы, описанные в этой работе подразумевают, что идеал задаётся
 конечным набором своих порождающих: 
\begin_inset Formula $I=\left(F\right)=\left(f_{1},\ldots,f_{m}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Все алгоритмы вычисления базиса Грёбнера по заданным таким образом входным
 данным могут быть разделены на 2 больших группы: инкрементальные и одноэтапные.
 Инкрементальные алгоритмы состоят из 
\begin_inset Formula $m-1$
\end_inset

 шагов, причём 
\begin_inset Formula $i$
\end_inset

-й шаг строит базис Грёбнера 
\begin_inset Formula $G_{i+1}$
\end_inset

 идеала 
\begin_inset Formula $\left(f_{1},\ldots,f_{i+1}\right)$
\end_inset

, принимая на вход многочлен 
\begin_inset Formula $f_{i+1}$
\end_inset

 и набор многочленов, составляющих найденный ранее базис 
\begin_inset Formula $G_{i}$
\end_inset

.
 При этом 
\begin_inset Formula $G_{1}$
\end_inset

 известно сразу, поскольку равно 
\begin_inset Formula $\left\{ f_{1}\right\} $
\end_inset

, а последний найденный базис 
\begin_inset Formula $G_{m}$
\end_inset

 является искомым базисом 
\begin_inset Formula $I$
\end_inset

.
 Таким образом, чтоб задать инкрементальный алгоритм нужно задать лишь его
 шаг, находящий конечное множество 
\begin_inset Formula $G_{i+1}$
\end_inset

 по заданным 
\begin_inset Formula $f_{i+1}$
\end_inset

 и множеству 
\begin_inset Formula $G_{i}$
\end_inset

.
 При формулировке шага входные данные будут обозначаться просто как 
\begin_inset Formula $f$
\end_inset

 и 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
Одноэтапные алгоритмы принимают на вход сразу все многочлены 
\begin_inset Formula $f_{1},\ldots,f_{m}$
\end_inset

 и возвращают искомый базис Грёбнера, и не допускают естественного разбиения
 на шаги, аналогичные инкрементальным алгоритмам.
 Они могут быть сделаны инкрементальными 
\begin_inset Quotes fld
\end_inset

искусственно
\begin_inset Quotes frd
\end_inset

 путём использования одноэтапного алгоритма в роли шага для инкрементального,
 подавая ему на вход множество 
\begin_inset Formula $G_{i}\cup f_{i+1}$
\end_inset

.
\end_layout

\begin_layout Section
Алгоритм Бухбергера
\end_layout

\begin_layout Standard
Простейшим алгоритмом вычисления базиса Грёбнера является алгоритм Бухбергера.
 Мы не будем подробно останавливаться на нём, однако дадим некоторые теоретическ
ие сведения, которые будут использоваться и в других алгоритмах, и опишем
 наиболее простую его версию без каких-либо оптимизаций.
\end_layout

\begin_layout Definition

\emph on
\begin_inset CommandInset label
LatexCommand label
name "def:S-pair-nosig"

\end_inset

S-парой
\emph default
 ненулевых многочленов 
\begin_inset Formula $g_{1}$
\end_inset

 и 
\begin_inset Formula $g_{2}$
\end_inset

 называется пара произведений:
\begin_inset Formula 
\[
\left(\frac{\HM(g_{2})\HC(g_{2})}{\LCM(\HM(g_{1}),\HM(g_{2}))}\cdot g_{1};\frac{\HM(g_{1})\HC(g_{1})}{\LCM(\HM(g_{1}),\HM(g_{2}))}\cdot g_{2}\right).
\]

\end_inset

Каждое из произведений называется 
\emph on
частью S-пары
\emph default
.
 Части S-пары могут рассматриваться как символические произведения монома
 на многочлен, или как многочлены, равные этим произведениям.
 При последней трактовке у частей S-пары оказывается одинаковый старший
 моном, называемый 
\emph on
сокращаемым мономом S-пары
\emph default
, и одинаковый старший коэффициент.
 Поэтому при вычитании второй части S-пары из первой происходит сокращение
 старших мономов.
 Получаемая разность называется 
\emph on
S-многочленом
\emph default
, соответствующим S-паре, или просто S-многочленом 
\begin_inset Formula $g_{1}$
\end_inset

 и 
\begin_inset Formula $g_{2}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Simple-spoly"

\end_inset

Пусть задано конечное множество ненулевых многочленов 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

, и известно что любой S-многочлен элементов 
\begin_inset Formula $G$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
 Тогда любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

, и таким образом 
\begin_inset Formula $G$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Эта теорема является главной теоремой, показывающей корректность алгоритма
 Бухбергера, однако вместо неё будет доказана более общая версия, применимая
 далее для алгоритмов, основанных на сигнатурах.
 Следующее определение формулируется для любых объектов, с которыми можно
 проводить операции сравнения на равенство, умножения на моном и взятия
 старшего монома 
\begin_inset Formula $\HM$
\end_inset

.
 При всех использованиях этого понятия таким объектом будет являться многочлен
 из 
\begin_inset Formula $\mathcal{P}$
\end_inset

, возможно с некоторыми дополнительно ассоциированными с ним данными, поэтому
 в тексте определения мы будем использовать термин 
\begin_inset Quotes fld
\end_inset

обобщённый многочлен
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Definition

\emph on
Условием представления
\emph default
 обобщённого многочлена 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 через обобщённый многочлен 
\begin_inset Formula $g\in\mathcal{P}$
\end_inset

 называется булева функция 
\begin_inset Formula $\beta(p,g)$
\end_inset

, удовлетворяющая следующим условиям:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\beta(p,p)=\mbox{TRUE}$
\end_inset


\end_layout

\begin_layout Itemize
Если 
\begin_inset Formula $\beta(p,g)=\mbox{TRUE}$
\end_inset

, то 
\begin_inset Formula $\forall m\in\mathbb{T}$
\end_inset

 будет 
\begin_inset Formula $\beta(mp,mg)=\mbox{TRUE}$
\end_inset


\end_layout

\begin_layout Itemize
Если 
\begin_inset Formula $\beta(p,g)=\mbox{TRUE}$
\end_inset

, то 
\begin_inset Formula $\forall k\in\mathcal{K},k\ne0$
\end_inset

 будет 
\begin_inset Formula $\beta(kp,g)=\beta(p,kg)=\mbox{TRUE}$
\end_inset


\end_layout

\begin_layout Itemize
Если 
\begin_inset Formula $\beta(p,g)=\mbox{TRUE}$
\end_inset

 и 
\begin_inset Formula $\beta(g,h)=\mbox{TRUE}$
\end_inset

, то 
\begin_inset Formula $\beta(p,h)=\mbox{TRUE}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Простейшим примером условия представления является 
\emph on
условие на старший моном
\emph default
 
\begin_inset Formula $\beta_{\HM}$
\end_inset

, определённое как 
\begin_inset Formula 
\[
\beta_{\HM}(p,g)=\mbox{TRUE}\Longleftrightarrow\HM(g)\preccurlyeq\HM(p).
\]

\end_inset


\end_layout

\begin_layout Definition
Представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

 называется 
\emph on
удовлетворяющим условию 
\begin_inset Formula $\beta$
\end_inset


\emph default
, если 
\begin_inset Formula $\forall k\,\beta(p,m_{k}g_{i_{k}})=\mbox{TRUE}$
\end_inset

.
\end_layout

\begin_layout Standard
В соответствии с этим определением представление является степенным тогда
 и только тогда, когда удовлетворяет условию 
\begin_inset Formula $\beta_{\HM}$
\end_inset

.
 Теперь можно сформулировать теорему, которая в частном случае тождественно
 истинной функции 
\begin_inset Formula $\beta_{2}$
\end_inset

 совпадает с теоремой 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Simple-spoly"

\end_inset

.
\end_layout

\begin_layout Theorem
Пусть зафиксировано некоторое условие представления 
\begin_inset Formula $\beta_{2}$
\end_inset

 и задано конечное множество ненулевых многочленов 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

, про которое известно, что любой S-многочлен элементов 
\begin_inset Formula $G$
\end_inset

 имеет представление над 
\begin_inset Formula $G$
\end_inset

, одновременно удовлетворяющее условиям 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Пусть также любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет представление над 
\begin_inset Formula $G$
\end_inset

, удовлетворяющее условию 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Тогда любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет представление одновременно удовлетворяющее условиям 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

, и таким образом 
\begin_inset Formula $G$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим противное и рассмотрим некоторый многочлен 
\begin_inset Formula $p\in\left(G\right)$
\end_inset

, не имеющий представления одновременно удовлетворяющего условиям 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Среди его представлений, удовлетворяющих 
\begin_inset Formula $\beta_{2}$
\end_inset

 найдём минимум значения 
\begin_inset Formula $\max_{k}\HM(m_{k}g_{i_{k}})$
\end_inset

 и обозначим его за 
\begin_inset Formula $M$
\end_inset

.
 Далее зафиксируем среди представлений, на которых этот минимум достигается,
 представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 с минимальным количеством элементов, обладающих старшим мономом 
\begin_inset Formula $M$
\end_inset

.
 В силу предположенного оно не может удовлетворять 
\begin_inset Formula $\beta_{\HM}$
\end_inset

, а значит 
\begin_inset Formula $M\succ\HM(p)$
\end_inset

.
 Отсюда вытекает, что в представлении есть как минимум 2 элемента со старшим
 мономом 
\begin_inset Formula $M$
\end_inset

, поскольку при суммировании в 
\begin_inset Formula $p$
\end_inset

 он должен сократиться.
 Для простоты будем полагать, что это элементы с индексами 1 и 2: 
\begin_inset Formula $c_{1}t_{1}\cdot g_{i_{1}}$
\end_inset

 и 
\begin_inset Formula $c_{2}t_{2}\cdot g_{i_{2}}$
\end_inset

.
 При этом 
\begin_inset Formula $i_{1}\ne i_{2}$
\end_inset

, так как иначе из равенства их 
\begin_inset Formula $\HM$
\end_inset

 следовало бы равенство 
\begin_inset Formula $t_{1}=t_{2}$
\end_inset

, что вместе с 
\begin_inset Formula $i_{1}=i_{2}$
\end_inset

 противоречит неповторяемости элементов в представлении.
 S-пара 
\begin_inset Formula $g_{i_{1}}$
\end_inset

 и 
\begin_inset Formula $g_{i_{2}}$
\end_inset

 имеет вид 
\begin_inset Formula $\left(c_{1}'t_{1}'\cdot g_{i_{1}};c_{2}'t_{2}'\cdot g_{i_{2}}\right)$
\end_inset

, причём 
\begin_inset Formula $\exists t_{m}\in\mathbb{T},c_{m}\in\mathcal{K}$
\end_inset

 для которых 
\begin_inset Formula $c_{1}'t_{1}'c_{m}t_{m}=c_{1}t_{1}$
\end_inset

.
 S-многочлен 
\begin_inset Formula $c_{1}'t_{1}'\cdot g_{i_{1}}-c_{2}'t_{2}'\cdot g_{i_{2}}$
\end_inset

 имеет представление, удовлетворяющее 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 В силу свойств условий представления отсюда следует, что после умножения
 его на 
\begin_inset Formula $c_{m}t_{m}$
\end_inset

 он тоже будет иметь представление над 
\begin_inset Formula $G$
\end_inset

, удовлетворяющее 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Обозначим это представление за 
\begin_inset Formula $\sum_{l}m_{l}\cdot g_{i_{l}}$
\end_inset

.
 Тогда выражение 
\begin_inset Formula 
\[
p=\sum_{l}m_{l}\cdot g_{i_{l}}+(c_{2}+c_{m}c_{2}')t_{2}\cdot g_{i_{2}}+\sum_{k>2}m_{k}\cdot g_{i_{k}}
\]

\end_inset

после группировки подобных при их наличии даст удовлетворяющее 
\begin_inset Formula $\beta_{2}$
\end_inset

 представление, с меньшим количеством элементов, обладающих старшим мономом
 
\begin_inset Formula $M$
\end_inset

, что приводит к противоречию.
\end_layout

\begin_layout Standard
Теперь сформулируем простейший вариант алгоритма Бухбергера в виде одноэтапного
 алгоритма
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Вход: многочлены 
\begin_inset Formula $\{f_{1},\dots,f_{m}\}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Переменные: 
\begin_inset Formula $P\subset\mathcal{P}$
\end_inset

 -- множество вычисленных S-многочленов.
 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 -- получаемый базис Грёбнера.
 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 -- многочлен текущего шага
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\begin_inset CommandInset label
LatexCommand label
name "par:Buchberger"

\end_inset

Buchberger
\begin_inset Formula $\left(\left\{ f_{1},\dots,f_{m}\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $G\leftarrow\{f_{1},\dots,f_{m}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $P\leftarrow\{$
\end_inset

S-многочлены всех пар 
\begin_inset Formula $(f_{i},f_{j}),i<j\}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
while 
\begin_inset Formula $P\ne\varnothing$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 любой элемент 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $P\leftarrow P\setminus\{p\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 результат редукции 
\begin_inset Formula $p$
\end_inset

 по 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $P\leftarrow P\cup\{$
\end_inset

S-многочлены всех пар 
\begin_inset Formula $(p,g),g\in G\}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
\begin_inset Formula $G\leftarrow G\cup\{p\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Standard
Для доказательства правильности любого алгоритма вычисления базисов Грёбнера
 нужно показать его остановку за конечное число шагов и корректность результата.
 Для алгоритма Бухбергера это показывают две следующие известные теоремы.
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Buchberger"

\end_inset

 останавливается на любых входных данных
\end_layout

\begin_layout Proof
Каждый новый элемент добавляемый в 
\begin_inset Formula $G$
\end_inset

 нередуцируем по нему,а значит расширяет идеал моноида, порождаемый старшими
 элементами многочленов 
\begin_inset Formula $G$
\end_inset

.
 Этот процесс не может быть бесконечен по лемме Диксона.
 Значит, после некоторого шага все результаты редукции нулевые и 
\begin_inset Formula $P$
\end_inset

 перестаёт пополняться.
 После этого оно исчерпается за конечное число итераций и алгоритм завершится
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Buchberger"

\end_inset

 возвращает базис Грёбнера идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Proof
Все S-пары элементов 
\begin_inset Formula $G$
\end_inset

 были добавлены в 
\begin_inset Formula $P$
\end_inset

, и редуцированы.
 Вне зависимости от того произошла ли редукция к нулю, или в 
\begin_inset Formula $G$
\end_inset

 был добавлен новый элемент, после окончания итерации цикла рассматриваемый
 S-многочлен имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
 Отсюда по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Simple-spoly"

\end_inset

 следует, что 
\begin_inset Formula $G$
\end_inset

 -- базис Грёбнера 
\begin_inset Formula $(G)$
\end_inset

.
 С другой стороны 
\begin_inset Formula $(G)=\left(f_{1},\dots,f_{m}\right)$
\end_inset

, поскольку 
\begin_inset Formula $f_{1},\dots,f_{m}$
\end_inset

 были добавлены в 
\begin_inset Formula $G$
\end_inset

 на первом шаге и все вычисления производились лишь внутри идеала.
\end_layout

\begin_layout Section
Алгоритмы, основанные на сигнатурах
\end_layout

\begin_layout Standard
Понятие сигнатуры связано с понятием представлений: сигнатура многочлена
 содержит информацию о максимальном в определённом смысле элементе представления
 этого многочлена.
 Поэтому для её определения необходимо зафиксировать множество, над которым
 рассматривается представление.
 Вопрос единственности сигнатуры после этой фиксации зависит от того выбирается
 ли среди представлений какое-то одно.
 В работах 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5,SignatureBasedGBs"

\end_inset

 сигнатура определяется для многочлена однозначно, при помощи выбора минимальног
о в определённом смысле представления.
 В работах 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C,GVW,G2V,F5InBBStyle,HuangConception"

\end_inset

 и в данной работе представление не фиксируется и один многочлен может иметь
 неограниченное число сигнатур.
 Таким образом, в понятие сигнатуры зависит не только от многочлена, но
 и от того над каким множеством рассматриваются его представления и даже
 от самого представления.
 Для одноэтапных алгоритмов представления рассматриваются над множеством
 
\begin_inset Formula $f_{1},\dots,f_{m}$
\end_inset

, а для инкрементальных -- на каждом шаге берётся соответствующее этому
 шагу множество 
\begin_inset Formula $G_{i}\cup f_{i+1}$
\end_inset

.
\end_layout

\begin_layout Standard
Сначала введём определение сигнатуры для элемента представления в одноэтапном
 и инкрементальном случаях.
\end_layout

\begin_layout Definition
Для одноэтапного алгоритма 
\emph on
сигнатурой элемента представления
\emph default
 
\begin_inset Formula $ct\cdot f_{i}$
\end_inset

 называется пара 
\begin_inset Formula $(t;i)\in\mathbf{T}=\mathbb{T}\times\mathbb{N}$
\end_inset

.
 В этой паре 
\begin_inset Formula $i$
\end_inset

 называется 
\emph on
индексом сигнатуры
\emph default
, а 
\begin_inset Formula $t$
\end_inset

 -- 
\emph on
мономом сигнатуры
\emph default
.
 Умножение такой сигнатуры на моном определяется как 
\begin_inset Formula $t_{1}(t;i)\eqdef(t_{1}t,i)$
\end_inset

, что соответствует умножению на моном элемента представления.
 Делимость элементов 
\begin_inset Formula $t',t''\in\mathbf{T}$
\end_inset

 определяется в соответствии с этим определением умножения:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
t'|t''\equivdef\exists t_{1}\in\mathbb{T},t''=t_{1}t'
\]

\end_inset


\end_layout

\begin_layout Standard
Для сравнения сигнатур из 
\begin_inset Formula $\mathbf{T}$
\end_inset

 могут использоваться различные порядки.
 Обычно используется порядок 
\begin_inset Formula $\prec_{P}$
\end_inset

, сравнивающий вначале индексы, а потом мономы:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(t_{1},i_{1}\right)\prec_{P}\left(t_{2},i_{2}\right)\Longleftrightarrow\left[\begin{aligned} & i_{1}<i_{2}\\
 & i{}_{1}=i_{2},t_{1}\prec t_{2}
\end{aligned}
\right..
\]

\end_inset


\end_layout

\begin_layout Definition
Для
\emph on
 
\emph default
инкрементального алгоритма 
\emph on
сигнатурой элемента представления
\emph default
 
\begin_inset Formula $ct\cdot p$
\end_inset

 называется 
\begin_inset Formula $t\in\mathbb{T}_{0}$
\end_inset

, если 
\begin_inset Formula $p=f$
\end_inset

 и 
\begin_inset Formula $0\in\mathbb{T}_{0}$
\end_inset

, если 
\begin_inset Formula $p\in G$
\end_inset

.
 В этом случае понятие 
\emph on
монома сигнатуры
\emph default
 совпадает с понятием сигнатуры.
 Для их сравнения используется порядок 
\begin_inset Formula $\prec_{0}$
\end_inset

, уже заданный на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующие определения не зависят от типа алгоритма, поэтому в них будем
 подразумевать под 
\begin_inset Formula $\tau$
\end_inset

 множество сигнатур соответствующее 
\begin_inset Formula $\mathbf{T}$
\end_inset

 или 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

, а под 
\begin_inset Formula $\prec_{\tau}$
\end_inset

 порядок на нём.
\end_layout

\begin_layout Definition

\emph on
Представлением 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset


\emph default
 называется представление 
\begin_inset Formula $p$
\end_inset

, в котором 
\begin_inset Formula $\prec_{\tau}$
\end_inset

-максимальная сигнатура элементов в точности равна 
\begin_inset Formula $\sigma$
\end_inset

.
 
\emph on
Отмеченным многочленом
\emph default
 называется пара 
\begin_inset Formula $h=(\sigma,p)\in\tau\times\mathcal{P}$
\end_inset

, удовлетворяющая условию корректности: существует представление 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
 На отмеченные многочлены распространяются определения старшего монома 
\begin_inset Formula $\HM(h)\eqdef\HM(p)$
\end_inset

 и коэффициента 
\begin_inset Formula $\HC(h)\eqdef\HC(p)$
\end_inset

.
 Также определяются 
\emph on
сигнатура
\emph default
 
\begin_inset Formula $\Sig(h)\eqdef\sigma$
\end_inset

 и вводится обозначение многочлена -- второго элемента пары: 
\begin_inset Formula $\poly(h)\eqdef p$
\end_inset

.
 Множество отмеченных многочленов обозначается за 
\begin_inset Formula $H\subset\tau\times\mathcal{P}$
\end_inset

.
 Полная степень монома сигнатуры 
\begin_inset Formula $s\in\tau$
\end_inset

 обозначается 
\begin_inset Formula $\totaldeg(s)$
\end_inset

.
\end_layout

\begin_layout Lemma
Результат умножения отмеченного многочлена 
\begin_inset Formula $h\in H$
\end_inset

 на моном 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

, заданного как 
\begin_inset Formula $th\eqdef(t\sigma,tp),$
\end_inset

 лежит в 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Необходимо проверить условие корректности: представление 
\begin_inset Formula $tp$
\end_inset

 сигнатуры 
\begin_inset Formula $t\sigma$
\end_inset

 может быть получено умножением на 
\begin_inset Formula $t$
\end_inset

 представления 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
 
\end_layout

\begin_layout Definition

\emph on
Сигнатурное условие представления
\emph default
 
\begin_inset Formula $\beta_{\Sig}$
\end_inset

 для отмеченных многочленов 
\begin_inset Formula $p,g\in H$
\end_inset

 определяется как
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\beta_{\Sig}(p,g)=\mbox{TRUE}\Longleftrightarrow\Sig(g)\preccurlyeq_{\tau}\Sig(p).
\]

\end_inset


\end_layout

\begin_layout Definition
Представление, удовлетворяющее условиям 
\begin_inset Formula $\beta_{\Sig}$
\end_inset

 и 
\begin_inset Formula $\beta_{\HM}$
\end_inset

, называется сигнатурным представлением.
\end_layout

\begin_layout Standard
Следующее определение вводит понятие сигнатурной редукции отмеченных многочленов
, соответствующее сигнатурному представлению.
 
\end_layout

\begin_layout Definition
Если для некоторых
\emph on
 
\begin_inset Formula $h'_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset


\emph default
 выполняется 
\begin_inset Formula $\Sig(h'_{1})\succ_{\tau}\Sig(th_{2}),\HM(h'{}_{1})=\HM(th{}_{2})\neq0,$
\end_inset

 то возможна 
\emph on
сигнатурная редукция 
\begin_inset Formula $h'_{1}$
\end_inset

 по 
\begin_inset Formula $h_{2}$
\end_inset

 
\emph default
, дающая в результате отмеченный многочлен 
\begin_inset Formula $h_{1}\in H$
\end_inset

, равный: 
\begin_inset Formula 
\[
h_{1}=\left(\Sig(h'_{1}),\poly(h'_{1})+Kt\poly(h_{2})\right),
\]

\end_inset

где коэффициент 
\begin_inset Formula $K\in\mathcal{K}$
\end_inset

 взят так, чтобы при сложении сократились старшие мономы и выполнилось 
\begin_inset Formula $\HM(h{}_{1})\prec_{0}\HM(h'{}_{1})$
\end_inset

.
 По сути такая редукция представляет из себя обычную редукцию многочлена
 с сокращением старшего монома, дополненную требованием того, что сигнатура
 редуктора меньше сигнатуры редуцируемого.
 Корректность проверяется взятием представления для 
\begin_inset Formula $\poly(h'_{1})+Kt\poly(h_{2})$
\end_inset

, равного соответствующей линейной комбинации представлений 
\begin_inset Formula $\poly(h'_{1})$
\end_inset

 и 
\begin_inset Formula $\poly(h_{2})$
\end_inset

.
\end_layout

\begin_layout Remark
Последовательность таких сигнатурных редукций по некоторому множеству отмеченных
 многочленов, заканчивающаяся нулём, определяет сигнатурное представление
 над этим множеством, состоящее из редуцирующих элементов.
\end_layout

\begin_layout Definition

\emph on
S-пара отмеченных многочленов
\emph default
 
\begin_inset Formula $h_{1},h_{2}\in H$
\end_inset

 определяется аналогично простой S-паре путём подстановки 
\begin_inset Formula $h_{1},h_{2}$
\end_inset

 на место обычных многочленов 
\begin_inset Formula $g_{1},g_{2}$
\end_inset

 в определении 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:S-pair-nosig"

\end_inset

.
 При этом каждая из частей S-пары 
\begin_inset Formula $\left(k_{1}u_{1}\cdot h_{1},k_{2}u_{2}\cdot h_{2}\right)$
\end_inset

 отмеченных многочленов имеет соответствующую ей сигнатуру 
\begin_inset Formula $\Sig(u_{i}h_{i})$
\end_inset

.
 Если сигнатуры частей различны, то часть с большей сигнатурой называется
 
\emph on
старшей частью S-пары
\emph default
, а часть с меньшей -- 
\emph on
младшей частью S-пары
\emph default
.
 При равенстве сигнатур частей такого разделения нет, но в этом случае нельзя
 определить сигнатуру S-многочлена, так как невозможно проверить условие
 корректности.
 При различии сигнатур частей S-многочлен 
\begin_inset Formula $k_{1}u_{1}\cdot h_{1}-k_{2}u_{2}\cdot h_{2}$
\end_inset

 является результатом сигнатурной редукции старшей части по младшей и имеет
 сигнатуру равную сигнатуре старшей части.
\end_layout

\begin_layout Standard
В дальнейшем мы не будем одновременно работать с сигнатурами двух видов,
 подразумевая сигнатуры из 
\begin_inset Formula $\mathbf{T}$
\end_inset

 в случае одноэтапных алгоритмов и сигнатуры из 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 для инкрементальных.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example:labeled-polys"

\end_inset

Простейшие отмеченные многочлены для одноэтапного случая:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(\left(\HM(p),i\right),pf_{i}\right),p\in\mathcal{P},i\in\mathbb{N}$
\end_inset

.
 Соответствует представлению вида 
\begin_inset Formula $pf_{i}=\sum_{m_{p}\in p}m_{p}\cdot f_{i}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\left(t\HM(f_{i}),j\right),0\right)$
\end_inset

 для 
\begin_inset Formula $i<j\in\mathbb{N},t\in\mathbb{T}$
\end_inset

.
 Соответствует представлению, получаемому для нуля из разбиения 
\begin_inset Formula $f_{i}$
\end_inset

 и 
\begin_inset Formula $f_{j}$
\end_inset

 на составляющие их мономы: 
\begin_inset Formula 
\[
0=t(f_{i}f_{j}-f_{j}f_{i})=\sum_{m_{f_{i}}\in f_{i}}m_{f_{i}}\cdot f_{j}-\sum_{m_{f_{j}}\in f_{j}}m_{f_{j}}\cdot f_{i}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Простейшие отмеченные многочлены для инкрементального случая:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(\HM(p),pf\right),p\in\mathcal{P}$
\end_inset

.
 Соответствует представлению вида 
\begin_inset Formula $pf=\sum_{m_{p}\in p}m_{p}\cdot f$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(0,g\right)$
\end_inset

 для 
\begin_inset Formula $g\in\left(G\right)$
\end_inset

.
 Соответствует любому представлению 
\begin_inset Formula $g$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\HM(g),0\right)$
\end_inset

 для 
\begin_inset Formula $g\in\left(G\right)$
\end_inset

.
 Соответствует представлению, получаемому для нуля из разбиения 
\begin_inset Formula $g$
\end_inset

 и 
\begin_inset Formula $f$
\end_inset

 на составляющие их мономы: 
\begin_inset Formula 
\[
0=gf-fg=\sum_{m_{g}\in g}m_{g}\cdot f-\sum_{m_{f}\in f}m_{f}\cdot g.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Алгоритм F5 в исходной формулировке
\end_layout

\begin_layout Standard
Первым сигнатурным алгоритмом, получившим широкое распространение, стал
 алгоритм F5, сформулированный в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

.
 Являясь по сути инкрементальным алгоритмом, его исходная формулировка не
 допускает строго инкрементальной записи в определённом выше смысле, поскольку
 на каждом следующем шаге используется не только базис, найденный на предыдущем,
 но и некоторая информация о сигнатурах элементов этого базиса.
 Наиболее близкая к исходному алгоритму строго инкрементальная формулировка
 описывается в Следствии 33 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
\end_layout

\begin_layout Standard
Подробное изложение идей алгоритма дано в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, поэтому сформулируем здесь лишь главные из них.
 Объектами, над которыми работает алгоритм, в большинстве случаев являются
 не просто многочлены, а отмеченные многочлены, над которыми производятся
 сигнатурные редукции, и арифметические операции, дающие результат с известной
 сигнатурой.
 Каждый инкрементальный шаг алгоритма соответствует алгоритму Бухбергера
 со следующими дополнениями:
\end_layout

\begin_layout Itemize
разрешены только сигнатурные редукции
\end_layout

\begin_layout Itemize
при взятии S-пары из очереди выбирается S-пара с наименьшей сигнатурой
\end_layout

\begin_layout Itemize
при образовании S-пар, построении S-многочленов и выборе редуктора для редукции
 проверяются критерии, которым должен удовлетворять домноженный многочлен,
 чтобы не быть отброшенным.
\end_layout

\begin_layout Standard
Помимо этого F5 добавляет требование однородности всех входных многочленов
 и проводит вычисления таким образом, что все получаемые многочлены также
 однородны.
 С более подробным сравнением шага алгоритма F5 с алгоритмом Бухбергера
 можно ознакомиться в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "F5InBBStyle"

\end_inset

.
\end_layout

\begin_layout Standard
Для удобства дальнейших рассуждений об остановке алгоритма приведём здесь
 полный псевдокод F5, основанный на исходной формулировке.
 Алгоритмически он эквивалентен ей во всём, кроме порядка обработки входных
 многочленов -- приводимая версия обрабатывает многочлены начиная с первого,
 в то время как в первоисточнике многочлены обрабатываются, начиная с последнего
, что вызвано противоположным направлением сравнения индексов в определении
 порядка 
\begin_inset Formula $\prec_{P}$
\end_inset

 на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
 Остальные отличия приводимого псевдокода от исходного носят лишь характер
 упрощения символики и самого псевдокода, но не вносят никаких изменений
 в сам алгоритм.
 Большинство используемых обозначений, включая названия этапов алгоритма,
 взято из первоисточника.
\end_layout

\begin_layout Paragraph
Глобальные переменные:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $R$
\end_inset

 Пополняемый массив отмеченных многочленов, нумеруемый числовыми индексами,
 начинающимися с единичного.
 Большая часть процедур оперирует не с отмеченными многочленами, а с их
 индексами в этом массиве.
 При редукции, многочлен уже однажды добавленный в 
\begin_inset Formula $R$
\end_inset

 может меняться, но сигнатура любого элемента 
\begin_inset Formula $R$
\end_inset

 остаётся неизменной после первого добавления.
 Изначально 
\begin_inset Formula $R$
\end_inset

 заполняется входными многочленами, которые всегда являются первыми 
\begin_inset Formula $m$
\end_inset

 элементами, а в процессе работы пополняется со стороны конца
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\#R$
\end_inset

 Обозначает число отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, меняется при добавлении элементов в 
\begin_inset Formula $R$
\end_inset

.
 Используется для получения индекса только что добавленного в 
\begin_inset Formula $R$
\end_inset

 элемента
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Rule Массив правил перезаписи, содержащий 
\begin_inset Formula $m$
\end_inset

 элементов.
 Каждый элемент соответствует ровно одному индексу сигнатуры и в свою очередь
 является пополняемым массивом чисел, являющихся индексами отмеченных многочлено
в в 
\begin_inset Formula $R$
\end_inset

.
 Изначально Rule состоит из 
\begin_inset Formula $m$
\end_inset

 пустых массивов, которые в процессе работы пополняется со стороны начала
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\prec$
\end_inset

 Мономиальный порядок, используемый при определении 
\begin_inset Formula $\HM$
\end_inset

 и 
\begin_inset Formula $\HC$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\prec_{P}$
\end_inset

 Используемый порядок на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:AddRule"

\end_inset

AddRule
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\begin_inset Formula $k$
\end_inset


\series default
 -- индекс элемента в 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
Добавить 
\begin_inset Formula $k$
\end_inset

 в начало массива Rule[
\shape italic

\begin_inset Formula $\sigidx\left(R[k]\right)$
\end_inset


\shape default
] 
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:Rewritten?"

\end_inset

Rewritten?
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $u$
\end_inset

 -- моном, 
\series bold

\begin_inset Formula $k$
\end_inset


\series default
 -- индекс элемента в 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
булево значение, равное истине, если произведение 
\begin_inset Formula $u\cdot R[k]$
\end_inset

 отбрасывается критерием перезаписи
\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $L\leftarrow$
\end_inset


\shape default
 Rule[
\begin_inset Formula $\sigidx\left(R[k]\right)$
\end_inset

]
\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $r\leftarrow$
\end_inset

 число элементов 
\begin_inset Formula $L$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\begin_inset Formula $i=1,\dots,r$
\end_inset

 do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default
\shape italic

\begin_inset Formula $u\Sig(R[k])$
\end_inset

 
\shape default
делится на 
\begin_inset Formula $\Sig(R[L[i]])$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $k\ne L[i]$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return false
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:IncrementalF5"

\end_inset

IncrementalF5
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $F=[f_{1},\dots,f_{m}]$
\end_inset

 -- упорядоченный массив однородных многочленов
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $i$
\end_inset

 -- этап алгоритма,
\begin_inset Formula $G_{i}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера идеала 
\begin_inset Formula $(f_{1},\dots,f_{i})$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
множество, образующее базис Грёбнера идеала 
\begin_inset Formula $(f_{1},\dots,f_{m})$
\end_inset

 с точки зрения порядка 
\begin_inset Formula $\prec$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $R\leftarrow[((1,1),f_{1}),((1,2),f_{2}),\dots,((1,m),f_{m})]$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $G_{1}\leftarrow\{1\}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\begin_inset Formula $i=2,\dots,m$
\end_inset

 do
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\begin_inset Formula $G_{i}\leftarrow$
\end_inset

 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\begin_inset Formula $(((1,i),f_{i}),G_{i-1})$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\left\{ poly(R[r])|r\in G_{m}\right\} $
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:AlgorithmF5"

\end_inset

AlgorithmF5
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $((1,i),f_{i})$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $G_{i-1}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера некоторого идеала 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset

, 
\begin_inset Formula $d$
\end_inset

 -- число, соответствующее минимальной степени оставшихся S-пар, 
\begin_inset Formula $P$
\end_inset

 -- упорядоченный список S-пар отмеченных многочленов, 
\begin_inset Formula $P_{d}$
\end_inset

 -- подмножество S-пар фиксированной степени, 
\begin_inset Formula $F_{d},R_{d}$
\end_inset

 -- некоторые множества индексов 
\begin_inset Formula $R$
\end_inset

, соответствующие многочленам фиксированной степени, 
\begin_inset Formula $r,p$
\end_inset

 -- индексы элементов в 
\begin_inset Formula $R$
\end_inset

, используемые при итерировании
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default

\begin_inset Formula $G_{i}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера идеала 
\begin_inset Formula $\left(\left\{ poly(R[r])|r\in G_{i-1}\right\} \cup f_{i}\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}=G_{i-1}\cup\left\{ i\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $\varphi\leftarrow$
\end_inset


\shape default
Оператор нормальной формы, производящий полную редукцию по множеству многочленов
 
\begin_inset Formula $\left\{ poly(R[r])|r\in G_{i-1}\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow$
\end_inset


\shape default
Отсортированный по возрастанию сокращаемого монома список 
\family typewriter
{CritPair
\family sans

\begin_inset Formula $(i,r,i,\varphi)|r\in G_{i-1}$
\end_inset

}
\end_layout

\begin_layout Enumerate

\family sans
\series bold
while 
\series default

\begin_inset Formula $P\ne\varnothing$
\end_inset

 
\series bold
do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $d\leftarrow\totaldeg\left(\HM\left(P[1]\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $P_{d}\leftarrow\{p\in P|\totaldeg($
\end_inset

сокращаемого монома
\begin_inset Formula $)=d\}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\setminus P_{d}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $F_{d}\leftarrow$
\end_inset


\family typewriter
\shape default
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset


\family sans

\begin_inset Formula $(P_{d})$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $R_{d}\leftarrow$
\end_inset


\shape default
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset


\begin_inset Formula $(F_{d},G_{i},\varphi)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\series default
\shape italic

\begin_inset Formula $r\in R_{d}$
\end_inset


\series bold
\shape default
 do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\cup\{$
\end_inset


\shape default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\begin_inset Formula $(r,p,i,\varphi)|p\in G_{i}\}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}\leftarrow G_{i}\cup\left\{ r\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
Отсортировать 
\begin_inset Formula $P$
\end_inset

 по возрастанию сокращаемого монома 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $G_{i}$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:CritPair"

\end_inset

CritPair
\family sans
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $r_{1},r_{2}$
\end_inset

 -- индексы отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $k$
\end_inset

 -- число, обозначающее индекс сигнатур, для которого проверяется нормальная
 форма, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $t,t_{1},t_{2},u_{1},u_{2}$
\end_inset

 -- мономы
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
множество S-пар отмеченных многочленов, содержащее не более одного элемента
\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $t\leftarrow\LCM(\HM(R[r_{1}]),\HM(R[r_{2}])$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\series default
\shape italic

\begin_inset Formula $i=1,2$
\end_inset


\series bold
\shape default
 do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $u_{i}\leftarrow\frac{t}{HT(R[r_{i}])}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $t_{i}\leftarrow$
\end_inset

 моном сигнатуры 
\begin_inset Formula $R[r_{i}]$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $u_{1}\Sig(R[r_{1}])\prec_{P}u_{2}\Sig(R[r_{2}])$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\family typewriter
\series default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\family sans

\begin_inset Formula $(r_{2},r_{1},k,\varphi)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $\varphi(u_{1}t_{1})\ne u_{1}t_{1}$
\end_inset

 
\series bold
then
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\varnothing$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default
\shape italic

\begin_inset Formula $\sigidx(R[r_{2}])=k$
\end_inset

 
\series bold
\shape default
and
\series default
 
\begin_inset Formula $\varphi(u_{2}t_{2})\ne u_{2}t_{2}$
\end_inset

 
\series bold
then
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\varnothing$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\left\{ \left(u_{1}\cdot R[r_{1}],u_{2}\cdot R[r_{2}]\right)\right\} $
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\begin_inset CommandInset label
LatexCommand label
name "par:Spol"

\end_inset

Spol
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $P=\left\{ p_{1},\dots,p_{h}\right\} $
\end_inset

 -- множество S-пар фиксированной степени
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $(u\cdot R[r_{i}],v\cdot R[r_{j}])$
\end_inset

 -- S-пара отмеченных многочленов
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default

\begin_inset Formula $F$
\end_inset

 -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих отмеченным многочленам, полученным из входных S-пар как
 S-многочлены
\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $F\leftarrow\varnothing$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\begin_inset Formula $l=1,\dots,h$
\end_inset

 do 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(u\cdot R[r_{i}],v\cdot R[r_{j}])\leftarrow P[l]$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default
(
\series bold
not
\series default
 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\family sans

\begin_inset Formula $(u,r_{i})$
\end_inset

) 
\series bold
and
\series default
 (
\series bold
not
\series default
 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\family sans

\begin_inset Formula $(v,r_{j})$
\end_inset

) 
\series bold
then
\end_layout

\begin_deeper
\begin_layout Enumerate
Добавить 
\family sans

\begin_inset Formula $(u\Sig(R[r_{i}]),u\poly(R[r_{i}])-v\poly(R[r_{j}]))$
\end_inset


\family default
 в конец 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AddRule"

\end_inset


\family sans

\begin_inset Formula $\left(\#R\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $F\leftarrow F\cup\left\{ \#R\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default
\shape italic

\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:Reduction"

\end_inset

Reduction
\family sans
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default
ToDo, 
\begin_inset Formula $G$
\end_inset

 -- множества индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих отмеченным многочленам, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $h$
\end_inset

 -- индекс отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, Done
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

, ToDo
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

 -- множества индексов 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
Done -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих отмеченным многочленам из ToDo, редуцированным по многочленам
 из 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
while 
\series default
ToDo 
\begin_inset Formula $\ne\varnothing$
\end_inset

 
\series bold
do 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $h\leftarrow$
\end_inset


\family sans
 индекс из ToDo
\family default
,
\family sans
 соответствующий многочлену с минимальной по 
\begin_inset Formula $\prec_{P}$
\end_inset

 среди ToDo сигнатурой
\end_layout

\begin_layout Enumerate

\family sans
ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 ToDo
\begin_inset Formula $\setminus\left\{ h\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R[h]\leftarrow\left(\Sig(R[h]),\varphi(\poly(R[h]))\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $($
\end_inset


\shape default
Done
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

, ToDo
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

) 
\family default

\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

(
\shape italic

\begin_inset Formula $h,G\cup$
\end_inset


\shape default
Done
\shape italic
, 
\begin_inset Formula $\varphi$
\end_inset


\shape default
) 
\end_layout

\begin_layout Enumerate

\family sans
Done
\family default
 
\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 Done
\shape italic
 
\shape default

\begin_inset Formula $\cup$
\end_inset

 Done
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family sans
ToDo
\family default
 
\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 ToDo 
\begin_inset Formula $\cup$
\end_inset

 ToDo
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default
Done
\shape italic
 
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:IsReducible"

\end_inset

IsReducible
\family sans
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $r_{0}$
\end_inset

 -- индекс отмеченного многочлена в 
\begin_inset Formula $R$
\end_inset

, для которого выполняется поиск возможных сигнатурных редукций,
\begin_inset Formula $G$
\end_inset

 -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих потенциальным редукторам, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $u$
\end_inset

 -- моном, 
\begin_inset Formula $r_{j}$
\end_inset

 -- индекс в 
\begin_inset Formula $R$
\end_inset

, для итерирования по 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $t_{j}$
\end_inset

 -- моном сигнатуры
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих возможным редукторам, содержащее не более одного элемента
\end_layout

\begin_layout Enumerate

\family sans
\series bold
for
\series default
 
\begin_inset Formula $r_{i}\in G$
\end_inset


\series bold
 do:
\series default
 
\series bold
if 
\series default
одновременно выполнены 4 нижеследующих условия
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-a"

\end_inset


\begin_inset Formula $u=\frac{HT(R[r_{0}])}{HT(R[r_{\text{j}}])}$
\end_inset

 -- корректный моном из 
\begin_inset Formula $\mathbb{T}$
\end_inset

, т.е.
 числитель делится на знаменатель
\end_layout

\begin_layout Enumerate

\family sans
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-b"

\end_inset


\begin_inset Formula $\varphi(ut_{j})=ut_{j}$
\end_inset

, где 
\begin_inset Formula $t_{j}$
\end_inset

 -- моном сигнатуры 
\begin_inset Formula $\Sig(R[r_{j}])$
\end_inset

.
\end_layout

\begin_layout Enumerate

\family sans
\series bold
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-c"

\end_inset

not
\series default
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $(u,r_{j})$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-d"

\end_inset


\begin_inset Formula $u\Sig(R[r_{j}])\ne\Sig(R[r_{0}])$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
then return 
\series default

\begin_inset Formula $\left\{ r_{j}\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\varnothing$
\end_inset

 
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:TopReduction"

\end_inset

TopReduction
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $r_{0}$
\end_inset

 -- индекс отмеченного многочлена в 
\begin_inset Formula $R$
\end_inset

, для которого выполняется редукция,
\begin_inset Formula $G$
\end_inset

 -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих многочленам, используемых в качестве редукторов, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $r'$
\end_inset

 -- множество индексов элементов 
\begin_inset Formula $R$
\end_inset

, являющихся потенциальными редукторами, 
\begin_inset Formula $r_{1}$
\end_inset

 -- конкретный его элемент, 
\begin_inset Formula $u$
\end_inset

 -- моном
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
Редуцированный многочлен перезаписывает 
\begin_inset Formula $R[r_{0}]$
\end_inset

.
 Возвращаемое значение -- пара множеств (ToDo, Done) содержащих индексы
 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $\poly(R[r_{0}])=0$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
Warning 
\series default

\begin_inset Quotes eld
\end_inset

На вход алгоритма подана нерегулярная последовательность” 
\end_layout

\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done
\family default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
, ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
) 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $R[r_{0}]\leftarrow\left(\Sig(R[r_{0}]),\frac{\poly(R[r_{0}])}{\HC(R[r_{0}])}\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
\begin_inset Formula $r'\leftarrow$
\end_inset


\family sans
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

(
\begin_inset Formula $h,G,\varphi$
\end_inset

) 
\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default
\shape italic

\begin_inset Formula $r'=\varnothing$
\end_inset


\series bold
\shape default
 then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done
\family default

\begin_inset Formula $\leftarrow\left\{ r_{0}\right\} $
\end_inset


\family sans
, ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
) 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
else 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $r_{1}\leftarrow$
\end_inset


\shape default
любой элемент 
\begin_inset Formula $r'$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $u\leftarrow\frac{HM(R[r_{0}])}{HM(R[r_{1}])}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $u\Sig(R[r_{1}])\prec_{\tau}\Sig(R[r_{1}])$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\begin_inset Formula $R[r_{0}]\leftarrow\left(\Sig(R[r_{0}]),\poly(R[r_{0}])-u\poly(R[r_{1}])\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done 
\family default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
 , ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\left\{ r_{0}\right\} $
\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
else 
\end_layout

\begin_deeper
\begin_layout Enumerate
Добавить 
\family sans

\begin_inset Formula $(u\Sig(R[r_{1}]),\poly(R[r_{0}])-u\poly(R[r_{1}])$
\end_inset


\family default
 в конец 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AddRule"

\end_inset


\family sans

\begin_inset Formula $\left(\#R\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done 
\family default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
 , ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\left\{ r_{0},\#R\right\} $
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Доказательство остановки
\end_layout

\begin_layout Standard
Алгоритм F5 является эффективным алгоритмом вычисления базисов Грёбнера,
 но обладает рядом проблем, связанных с его обоснованием.
 Корректность его работы при условии остановки показана в первоисточнике
 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 и в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "GermanF5Proof_ru,F5InBBStyle,NewF5Proof"

\end_inset

, предложивших другие способы её доказательства.
 Но остановка алгоритма, как в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, так и в детальных исследованиях 
\begin_inset CommandInset citation
LatexCommand cite
key "F5-revisited"

\end_inset

, показана только для случая отсутствия редукций к нулю.
 В свою очередь отсутствие редукций к нулю доказано для случая, когда входное
 множество многочленов представлено регулярной последовательностью, а среди
 нерегулярных последовательностей известны примеры, приводящие появлению
 в алгоритме F5 редукций к нулю.
 При этом примеров, приводящих к отсутствию остановки алгоритма найдено
 не было.
 Поскольку для большинства входных последовательностей их регулярность неизвестн
а, эти исследования не позволяют ответить на вопрос завершения практической
 реализации алгоритма на конкретных входных данных.
 Один из подходов к решению проблемы -- добавление в алгоритм дополнительных
 проверок и критериев, гарантирующих остановку алгоритма.
 Этот подход даёт строгое доказательство остановки, однако получаемый результат
 есть доказательство остановки модифицированной версии F5, содержащей дополнител
ьные проверки, которая в силу этого может быть более сложна в реализации
 или иметь большее время работы на некоторых входных данных.
 Этот подход применяется в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG,Hashemi-ExtF5,ZobninGeneralization_ru"

\end_inset

.
\end_layout

\begin_layout Standard
Другой подход состоит в доказательстве остановки семейства алгоритмов, основанны
х на идеях F5, с последующей попыткой переформулировать F5 таким образом,
 чтобы он являлся представителем этого семейства.
 Основная проблема этого подхода появляется в процессе переформулировки:
 описание F5 в других терминах может привести к незаметному внесению различий
 в поведение алгоритма, которые потребуют дополнительных рассуждений для
 доказательства эквивалентности с F5.
 К примеру, 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

 доказывает остановку алгоритма F5GEN, который отличается от исходного F5
 отсутствием проверки критериев при выборе редуктора.
 Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 даёт доказательство остановки алгоритма TRB-F5, который, как удалось осознать
 автору в процессе плодотворных дискуссий с Джоном Перри, имеет два существенных
 отличия от F5.
 Первое отличие -- другая схема построения правил, приводящая в конце концов
 к тому, что в процессе выполнения TRB-F5 правила в массивах Rule оказываются
 отсортированными по возрастанию сигнатуры.
 Второе отличие -- отсутствие в TRB-F5 применения оператора нормальной формы
 
\begin_inset Formula $\varphi$
\end_inset

 перед редукцией, что приводит к эффекту противоположному отличиям F5 от
 F5GEN: алгоритм TRB-F5 при выборе редуктора проверяет критерии для элементов
 с индексами сигнатуры, отличными от текущего, которые в F5 используются
 неявно в операторе нормальной формы и за счёт этого не подвергаются проверки
 критериев.
 Предположительно, эти алгоритмы могут быть изменены таким образом, чтобы
 в точности повторять поведение алгоритма F5, а доказательство остановки
 может быть перенесено на изменённые версии.
 Однако подход с алгоритмами, эквивалентными F5 имеет и другой недостаток:
 он усложняет понимание того, как теоремы, используемые для доказательства
 остановки, отражают поведение исходного алгоритма F5.
\end_layout

\begin_layout Standard
Подход к доказательству остановки, представляемый в данной работе, применяется
 к F5 без каких-либо модификаций.
 Первый шаг доказательства основан на предлагаемой ниже идее цепей S-пар.
 Второй шаг основывается на методе, использованном в теореме 21 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 для доказательства корректности алгоритма F5C: сигнатурное представление
 S-многочлена над множеством, вычисленным F5C, может быть модифицировано
 последовательностью замен S-пар и их отброшенных частей, и за конечное
 число таких шагов приведено к состоянию, когда выполняются определённые
 
\begin_inset Quotes fld
\end_inset

хорошие
\begin_inset Quotes frd
\end_inset

 свойства.
 Для применения этого метода к доказательству остановки F5 он сформулирован
 таким образом, что его предусловия ослаблены для применения к множеству
 на любом промежуточном шаге вычислений F5, а получаемые следствия усилены
 для их использования в доказательстве остановки.
\end_layout

\begin_layout Subsubsection
Потенциально бесконечные циклы в F5
\end_layout

\begin_layout Paragraph
Процедура 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
: увеличение 
\begin_inset Formula $d$
\end_inset


\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "iterations-d_grow"

\end_inset

Если при некоторых входных данных цикл 
\series bold
while
\series default
 внутри процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
 выполняется бесконечное число раз, то значение 
\begin_inset Formula $d$
\end_inset

 неограниченно возрастает.
\end_layout

\begin_layout Proof
Предположим существование последовательности многочленов 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 в кольце 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для которой алгоритм F5 не завершается.
 Без ограничение общности будем считать что это самая короткая последовательност
ь такого рода -- алгоритм завершается на более короткой последовательности
 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m-1}\right\} $
\end_inset

.
 Это означает, что не завершается последняя итерация цикла внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IncrementalF5"

\end_inset

, то есть не завершается последний вызов процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
.
 Для исследования данной ситуации необходимо понять, как ведёт себя значение
 полной степени 
\begin_inset Formula $d$
\end_inset

 в процессе выполнения цикла внутри процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
.
 Обозначим за 
\begin_inset Formula $d_{j}$
\end_inset

 значение 
\begin_inset Formula $d$
\end_inset

 на 
\begin_inset Formula $j$
\end_inset

-ой итерации цикла и положим 
\begin_inset Formula $d_{0}=-1$
\end_inset

.
 Простейшее свойство 
\begin_inset Formula $d_{j}$
\end_inset

 -- неубывание: 
\begin_inset Formula $d_{j}\geqslant d_{j-1}$
\end_inset

.
 Оно выполняется, поскольку на 
\begin_inset Formula $j-1$
\end_inset

-ой итерации все многочлены в 
\begin_inset Formula $R_{d}$
\end_inset

 имеют степень 
\begin_inset Formula $d_{j-1}$
\end_inset

, и поэтому все вновь создаваемые S-пары имеют степень не менее 
\begin_inset Formula $d_{j-1}$
\end_inset

.
 Предположим теперь, что 
\begin_inset Formula $j$
\end_inset

 -- фиксированный номер некоторой итерации.
 В начале итерации 
\begin_inset Formula $j$
\end_inset

 все критические пары степени 
\begin_inset Formula $d_{j}$
\end_inset

 извлекаются из 
\begin_inset Formula $P$
\end_inset

.
 После вызова процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset


\family default
 в 
\begin_inset Formula $P$
\end_inset

 добавляются некоторые новые S-пары в цикле, итерирующем по 
\begin_inset Formula $R_{d}$
\end_inset

.
 Существует возможность что некоторые из них будут иметь полную степень
 равную 
\begin_inset Formula $d_{j}$
\end_inset

.
 Нижеследующие рассуждения призваны показать, что все критические пары такой
 полной степени будут отброшены на следующей итерации алгоритма и ни одна
 из них не породит S-многочлен.
\end_layout

\begin_layout Proof
Для каждой из S-пар 
\begin_inset Formula $\left(u_{1}\cdot R\left[r_{1}\right],u_{2}\cdot R\left[r_{2}\right]\right)$
\end_inset

, порождённых на итерации 
\begin_inset Formula $j$
\end_inset

, как минимум один из многочленов пары принадлежит 
\begin_inset Formula $R_{d}$
\end_inset

 и не более чем один многочлен из пары мог принадлежать 
\begin_inset Formula $G_{i}$
\end_inset

 на момент начала итерации.
 Все многочлены 
\begin_inset Formula $R_{d}$
\end_inset

 генерируются процедурой 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset


\family default
 путём добавления по одному многочлену к множеству Done.
 Поэтому, среди одного или двух многочленов критической пары, принадлежащих
 
\begin_inset Formula $R_{d}$
\end_inset

, мы можем выбрать индекс многочлена 
\begin_inset Formula $r_{k}$
\end_inset

 добавленный в Done позже.
 Тогда про другой индекс многочлен S-пары 
\begin_inset Formula $r_{3-k}$
\end_inset

 можно утверждать, что он уже присутствовал в 
\begin_inset Formula $G\cup$
\end_inset

Done к моменту добавления 
\begin_inset Formula $r_{k}$
\end_inset

 в Done.
 Поэтому процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 пыталась редуцировать 
\begin_inset Formula $R\left[r_{k}\right]$
\end_inset

 по 
\begin_inset Formula $R\left[r_{3-k}\right]$
\end_inset

, но не сделала этого, поскольку в функции 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset


\family default
 одна из проверок 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-a"

\end_inset

 - 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 запретила использование редуктора.
\end_layout

\begin_layout Proof
При этом для критических пар с полной степенью равной 
\begin_inset Formula $d_{j}$
\end_inset

 мы имеем 
\begin_inset Formula $u_{k}=1$
\end_inset

, поскольку полная степень критической пары равна полной степени её челна
 
\begin_inset Formula $\totaldeg\left(\HM\left(R\left[r_{k}\right]\right)\right)$
\end_inset

.
 Это означает, что значение 
\begin_inset Formula $u_{3-k}$
\end_inset

 равно 
\begin_inset Formula $\frac{\HM(R\left[r_{k}\right])}{\HM(R\left[r_{3-k}\right])}$
\end_inset

, поэтому в 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset


\family default
 правило 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-a"

\end_inset

 разрешает редукцию 
\begin_inset Formula $R\left[r_{k}\right]$
\end_inset

 по 
\begin_inset Formula $R\left[r_{3-k}\right]$
\end_inset

.
 Получается, что только правила 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 - 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 могли запретить редукцию.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

.
 Это означает, что в 
\begin_inset Formula $G_{i-1}$
\end_inset

 существует многочлен, редуцирующий 
\begin_inset Formula $u_{3-k}t_{3-k}$
\end_inset

, где 
\begin_inset Formula $t_{3-k}$
\end_inset

 -- моном сигнатуры 
\begin_inset Formula $\Sig\left(R\left[r_{3-k}\right]\right)$
\end_inset

.
 Для нашего случая отсюда следовало бы, что в функции 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\family default
 эквивалентная проверка 
\begin_inset Formula $\varphi(u_{3-k}t_{3-k})=u_{3-k}t_{3-k}$
\end_inset

 запретила бы создание критической пары.
 Получается, что правило 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 также не могло запретить редукцию.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

.
 Это означает существование перезаписи для домноженного редуктора.
 В нашем случае это значит, что 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 показала наличие перезаписи в процессе выполнения 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

, и будет продолжать возвращать значение 
\begin_inset Quotes fld
\end_inset

Истина
\begin_inset Quotes frd
\end_inset

 на всех последующих этапах алгоритма, поскольку перезаписывающие многочлены
 не могут исчезнуть.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

.
 Это обозначает, что сигнатуры 
\begin_inset Formula $r_{k}$
\end_inset

 и 
\begin_inset Formula $u_{3-k}r_{3-k}$
\end_inset

 равны.
 Значит вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 будет возвращать 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

 после добавления правила, соответствующего 
\begin_inset Formula $r_{k}$
\end_inset

, поскольку 
\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 перезаписывается 
\begin_inset Formula $\left(1,r_{k}\right)$
\end_inset

.
 Получается, что как и в случае с правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 возвращает 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

 при выполнении 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 и позже.
\end_layout

\begin_layout Proof
Теперь рассмотрим функцию 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

, выполняемую для некоторой S-пары полной степени 
\begin_inset Formula $d_{j}$
\end_inset

, добавленной в 
\begin_inset Formula $P$
\end_inset

 на итерации 
\begin_inset Formula $j$
\end_inset

.
 Она выполняется внутри 
\begin_inset Formula $j+1$
\end_inset

 итерации цикла в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, то есть уже после того, как закончилось выполнение 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 для 
\begin_inset Formula $r_{k}$
\end_inset

.
 Поэтому для случаев 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 вернёт 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

.
 Значит на итерации 
\begin_inset Formula $j+1$
\end_inset

 ни одна из S-пар полной степени 
\begin_inset Formula $d_{j}$
\end_inset

 не добавит многочлена в 
\begin_inset Formula $F_{d}$
\end_inset

.
\end_layout

\begin_layout Proof
Итого, получено: 
\end_layout

\begin_deeper
\begin_layout Itemize
первая возможность относительного расположения 
\begin_inset Formula $d_{j+1}$
\end_inset

 и 
\begin_inset Formula $d_{j}$
\end_inset

 -- их равенство: 
\begin_inset Formula $d_{j+1}=d_{j}$
\end_inset

.
 В этом случае 
\begin_inset Formula $F_{d}$
\end_inset

 оказывается пустым на итерации 
\begin_inset Formula $j+1$
\end_inset

, и, таким образом, 
\begin_inset Formula $P$
\end_inset

 не содержит ни одной пары с полной степенью 
\begin_inset Formula $d_{j}$
\end_inset

 после того как итерация 
\begin_inset Formula $j+1$
\end_inset

 завершится.
 Значит 
\begin_inset Formula $d_{j+2}>d_{j+1}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Другая возможность относительного расположения -- строгое возрастание 
\begin_inset Formula $d_{j+1}>d_{j}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Вместе эти факты дают 
\begin_inset Formula $\forall j\,\, d_{j+2}>d_{j}$
\end_inset

, что доказывает утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterations-d_grow"

\end_inset

.
\end_layout

\begin_layout Paragraph
Процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

: конечность ToDo
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "Every_cycle_iteration_finish"

\end_inset

Каждая итерация цикла внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 останавливается, в частности останавливаются все вызовы процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

.
\end_layout

\begin_layout Proof
Факт остановки известен для вызовов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, соответствующих многочленам 
\begin_inset Formula $f_{1},\dots,f_{m-1}$
\end_inset

, поэтому будет рассматриваться лишь один оставшийся вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, обрабатывающий последний элемент входного набора многочленов 
\begin_inset Formula $f_{m}$
\end_inset

.
 Вначале покажем несколько общих утверждений о многочленах в множествах
 ToDo и Rule в процессе 
\begin_inset Formula $j$
\end_inset

-ой итераций цикла внутри этого вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

.
 Старшая по сигнатуре часть S-пары всех критических пар, добавляемых функцией
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 вначале выполнения 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, обладает индексом сигнатуры, равным 
\begin_inset Formula $m$
\end_inset

.
 Все прочие критические пары порождаются с индексом сигнатуры, соответствующим
 некоторому отмеченному многочлену, перемещённому из множества ToDo в множество
 Done.
 В свою очередь все элементы ToDo создаются или на основе критических пар
 или внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Многочлены, генерируемые 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 имеют сигнатуру, превышающую сигнатуру многочлена, который редуцирует данный
 вызов процедуры, и который является элементом ToDo.
 Поэтому многочлен или критическая пара с индексом сигнатуры, отличным от
 
\begin_inset Formula $m$
\end_inset

 не могут появиться в рассматриваемом вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

.
 С другой стороны, все многочлены в ToDo имеют одну и ту же полную степень
 
\begin_inset Formula $d_{j}$
\end_inset

.
 Вместе с равенством индексов это позволяет заключить, что полная степень
 мономов сигнатур равна 
\begin_inset Formula $d_{j}-\totaldeg(f_{m})$
\end_inset

 для всех элементов ToDo.
\end_layout

\begin_layout Proof
Каждое добавление элемента в массив Rule соответствует добавлению в множество
 ToDo.
 Поэтому, элементы добавляемые в начало Rule
\begin_inset Formula $[m]$
\end_inset

 на итерации 
\begin_inset Formula $j$
\end_inset

 имеют полную степень равную 
\begin_inset Formula $d_{j}$
\end_inset

.
 Вспоминая неубывание 
\begin_inset Formula $d_{j}$
\end_inset

 получаем, что на 
\begin_inset Formula $j$
\end_inset

-ой итерации все элементы Rule с индексом сигнатуры 
\begin_inset Formula $m$
\end_inset

 имеют полную степень 
\begin_inset Formula $\leqslant d_{j}$
\end_inset

 и полную степень монома сигнатуры 
\begin_inset Formula $\leqslant d_{j}-\totaldeg(f_{m})$
\end_inset

.
 Также это даёт следующий факт:
\end_layout

\begin_deeper
\begin_layout Fact
Полная степень элементов Rule
\begin_inset Formula $[m]$
\end_inset

 не возрастает.
\end_layout

\end_deeper
\begin_layout Proof
Алгоритм производит только сигнатурные редукции: процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 производит редукцию по неотброшенному редуктору, если он сигнатурный, и
 добавляет элемент в ToDo в противном случае.
 Элементы ToDo обрабатываются в порядке возрастания сигнатур, поэтому ни
 один из элементов 
\begin_inset Formula $G\cup$
\end_inset

Done не может иметь сигнатуры, превышающей сигнатуру многочлена 
\begin_inset Formula $R\left[r_{k}\right]$
\end_inset

, редуцируемого в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Рассмотрим неотброшенный проверками редуктор 
\begin_inset Formula $R\left[r_{q}\right]$
\end_inset

.
 Если он имеет полную степень 
\begin_inset Formula $\totaldeg(R\left[r_{q}\right])=\totaldeg(R\left[r_{k}\right])$
\end_inset

, мы получаем свойства 
\begin_inset Formula $t=1$
\end_inset

 и 
\begin_inset Formula $\Sig(R\left[r_{k}\right])\succ\Sig(R\left[r_{q}\right])$
\end_inset

, гарантирующие что редукция по нему будет сигнатурной.
 Случай 
\begin_inset Formula $\Sig(R\left[r_{k}\right])=\Sig(R\left[r_{q}\right])$
\end_inset

 невозможен, поскольку такие редукторы отбрасываются в правиле 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Таким образом, ситуация 
\begin_inset Formula $\Sig(R\left[r_{k}\right])\prec t\cdot\Sig(R\left[r_{q}\right])$
\end_inset

 возможна только при 
\begin_inset Formula $\totaldeg(R\left[r_{q}\right])<\totaldeg(R\left[r_{k}\right])$
\end_inset

 и все добавления в ToDo в процессе 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 соответствуют этому случаю.
 Моном сигнатуры многочлена, добавляемого таким образом, равен 
\begin_inset Formula $t\cdot\Sig(R\left[r_{q}\right])$
\end_inset

 и тот факт что 
\begin_inset Formula $r_{q}$
\end_inset

 не был отброшен проверкой правила 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 гарантирует, что ни одного многочлена с сигнатурой 
\begin_inset Formula $t\Sig(R\left[r_{q}\right])$
\end_inset

 не было порождено, потому что иначе такой многочлен имел бы связанное с
 ним правило в Rule с большей полной степенью, чем правило, соответствующее
 
\begin_inset Formula $r_{q}$
\end_inset

, и 
\begin_inset Formula $r_{q}$
\end_inset

 был бы отброшен в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Таким образом показан вспомогательный факт
\end_layout

\begin_deeper
\begin_layout Fact
Добавление в ToDo элемента с сигнатурой 
\begin_inset Formula $t\in\mathbf{T}$
\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 возможно только если элемент с такой сигнатурой не добавлялся в ToDo ранее.
\end_layout

\end_deeper
\begin_layout Proof
Мы хотим показать, что единственная возможность отсутствия остановки алгоритма
 соответствует случаю неограниченного возрастания 
\begin_inset Formula $d_{j}$
\end_inset

.
 Мы показали, что отсутствие остановки алгоритма происходит в случае, когда
 не завершается вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, и что он не может зациклиться обрабатывая бесконечное число итераций итерации
 с одним и тем же значением 
\begin_inset Formula $d$
\end_inset

.
 Остаются два варианта: неограниченное возрастание 
\begin_inset Formula $d$
\end_inset

 и зацикливание внутри одной из итераций с фиксированным значением.
 Далее показано, что такое зацикливание невозможно.
 Процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 содержит 3 цикла помимо главного:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
for
\series default
-цикл внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 завершается, поскольку число его итераций ограничено числом критических
 пар к моменту начала выполнения цикла;
\end_layout

\begin_layout Itemize

\series bold
for
\series default
-цикл внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 проходит по элементам 
\begin_inset Formula $R_{d}$
\end_inset

 и также завершается, поскольку число элементов 
\begin_inset Formula $R_{d}$
\end_inset

 зафиксировано к моменту начала выполнения цикла;
\end_layout

\begin_layout Itemize
наиболее сложный случай соответствует 
\series bold
while
\series default
-циклу внутри 
\family typewriter
процедуры 
\family default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

, который выполняется до тех пор, пока множество ToDo не станет пустым.
 Множество ToDo изначально заполняется процедурой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и потом дополняется новыми элементами в процессе выполнения 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 порождает конечное число элементов, поскольку она завершается, а все элементы
 добавляемые 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 имеют различные сигнатуры индекса 
\begin_inset Formula $m$
\end_inset

, поэтому их число ограничено числом различных сигнатур полной степени 
\begin_inset Formula $d_{j}-\totaldeg(f_{1})$
\end_inset

, поэтому в ToDo добавляется лишь конечное число элементов.
 Теперь мы покажем, что все типы шагов, происходящих внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 могут быть выполнены лишь конечное число раз:
\end_layout

\begin_deeper
\begin_layout Itemize
шаг, на котором 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращает пустое множество, соответствует переносу элемента множества
 ToDo в Done и число таких шагов ограничено числом элементов, добавляемых
 в ToDo
\end_layout

\begin_layout Itemize
шаг, на котором 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращает не сигнатурный редуктор, соответствует добавлению нового элемента
 в ToDo и число таких шагов ограничено числом возможных добавлений
\end_layout

\begin_layout Itemize
шаг, на котором 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращает сигнатурный редуктор, соответствует редукции одного из элементов
 ToDo.
 Это может произойти лишь конечное число раз, поскольку в ToDo добавляется
 конечное число многочленов и не может существовать бесконечной цепочки
 редукций для одного многочлена, поскольку в процессе редукции его старший
 моном 
\begin_inset Formula $\HM$
\end_inset

 строго 
\begin_inset Formula $\prec$
\end_inset

-убывает, а множество мономов вполне упорядочено по 
\begin_inset Formula $\prec$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Мы получили, что все циклы внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, кроме главного, завершаются, что доказывает утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "Every_cycle_iteration_finish"

\end_inset

.
\end_layout

\begin_layout Standard
Отсюда получается следующий факт о поведении алгоритма в ситуации, когда
 он не завершается:
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "d-does-grow"

\end_inset

Если алгоритм не завершается на некоторых входных данных, то значение 
\begin_inset Formula $d$
\end_inset

 неограниченно возрастает в процессе итераций.
\end_layout

\begin_layout Proof
Следует из комбинирования утверждений 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterations-d_grow"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "Every_cycle_iteration_finish"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Цепи S-пар
\end_layout

\begin_layout Standard
Утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "d-does-grow"

\end_inset

 показывает, что в случае отсутствия остановки работа алгоритма приводит
 к появлению бесконечной последовательности ненулевых отмеченных многочленов
 с неограниченно возрастающей полной степенью, добавляемых в 
\begin_inset Formula $G_{i}$
\end_inset

.
 То есть, в этом случае алгоритм порождает в 
\begin_inset Formula $R$
\end_inset

 бесконечную последовательность отмеченных многочленов 
\begin_inset Formula $\left\{ R[1],\ldots,R[m],\ldots,R[l],\ldots\right\} $
\end_inset

, в которой 
\begin_inset Formula $R[1],\ldots,R[m]$
\end_inset

 соответствуют 
\begin_inset Formula $m$
\end_inset

 исходным многочленам, а остальные были получены в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 В обоих случаях новый элемент 
\begin_inset Formula $R[l]$
\end_inset

 порождается как S-многочлен двух уже ранее добавленных в последовательность
 многочленов.
 Будем обозначать за 
\begin_inset Formula $l^{*}$
\end_inset

 и 
\begin_inset Formula $l_{*}$
\end_inset

 позиции многочленов, использовавшихся для генерации 
\begin_inset Formula $l$
\end_inset

-го многочлена последовательности и за 
\begin_inset Formula $\overline{u_{l}}$
\end_inset

, 
\begin_inset Formula $\underline{u_{l}}$
\end_inset

 мономы, на которые они умножались.
 При этом 
\begin_inset Formula $l^{*}$
\end_inset

 соответствует части с большей сигнатурой: 
\begin_inset Formula $\poly(R[l])=\overline{u_{l}}\poly(R[l^{*}])-\underline{u_{l}}\poly(R[l_{*}])$
\end_inset

 и 
\begin_inset Formula $\Sig(R[l])=\overline{u_{l}}\Sig(R[l^{*}])\succ\underline{u_{l}}\Sig(R[l_{*}])$
\end_inset

.
 Значение 
\begin_inset Formula $\poly(R[l])$
\end_inset

 может меняться в процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 на многочлен с меньшим 
\begin_inset Formula $\HM$
\end_inset

, но 
\begin_inset Formula $\Sig(R[l])$
\end_inset

 нигде далее не меняется после добавления многочлена в последовательность.
 Далее, будем пытаться найти бесконечную подпоследовательность 
\begin_inset Formula $\left\{ R[k_{1}],R[k_{2}],\ldots,R[k_{n}],\ldots\right\} $
\end_inset

 в этой последовательности, обладающую свойством, что 
\begin_inset Formula $R[k_{n}]$
\end_inset

 является S-многочленом 
\begin_inset Formula $R[k_{n-1}]=R[k_{n}^{*}]$
\end_inset

 и некоторого другого многочлена меньшей сигнатуры.
 То есть 
\begin_inset Formula $\Sig(R[k_{n}])=\overline{u_{k_{n}}}\Sig(R[k_{n-1}])$
\end_inset

, откуда вытекает делимость: 
\begin_inset Formula 
\begin{equation}
\Sig(R[k_{n-1}])|\Sig(R[k_{n}]).\label{eq:s-pair-chain-def}
\end{equation}

\end_inset


\end_layout

\begin_layout Definition
Конечную или бесконечную последовательность отмеченных многочленов из 
\begin_inset Formula $H$
\end_inset

, соседние элементы которой удовлетворяют свойству 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:s-pair-chain-def"

\end_inset

 будем называть 
\emph on
цепью S-пар
\emph default
.
\end_layout

\begin_layout Standard
Каждый порождаемый многочлен 
\begin_inset Formula $R[l]$
\end_inset

 имеет конечную цепь S-пар, оканчивающуюся этим многочленом.
 Эта цепь может быть последовательно построена, начиная с последнего элемента
 
\begin_inset Formula $R[l]$
\end_inset

, если на каждом шаге переходить от текущего многочлена 
\begin_inset Formula $R[n]$
\end_inset

 к многочлену 
\begin_inset Formula $R[n^{*}]$
\end_inset

, который использовался при генерации 
\begin_inset Formula $R[n]$
\end_inset

 как S-многочлена.
 Результирующая цепь S-пар имеет вид 
\begin_inset Formula $\{R[q],\ldots,R[l^{**}],R[l^{*}],R[l]\}$
\end_inset

, где все многочлены имеют одинаковый индекс сигнатуры 
\begin_inset Formula $q=\sigidx(R[l])$
\end_inset

 и первый элемент является входным многочленом этого индекса.
\end_layout

\begin_layout Standard
Первое свойство цепей S-пар основано на критерии перезаписи и заключается
 в следующей теореме.
\end_layout

\begin_layout Theorem
Любой отмеченный многочлен может являться начальным элементом лишь конечного
 числа различных цепей S-пар длины 2.
\end_layout

\begin_layout Proof
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 считает S-многочлены в двух местах: процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Важно заметить, что в обоих случаях проверка 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 для части S-многочлена с большей сигнатурой выполняется непосредственно
 перед созданием S-многочлена.
 В первом случае такая проверка производится в самой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

, а в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 проверка присутствует в вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 И в обоих случаях получаемый S-многочлен немедленно добавляется в список
 Rule последним элементом.
 Поэтому, в момент построения S-многочлена с сигнатурой 
\begin_inset Formula $s$
\end_inset

 можно утверждать, что старшая часть S-пары соответствует последнему из
 правил с сигнатурой, делящей 
\begin_inset Formula $s$
\end_inset

 -- она даже может быть найдена исходя лишь из списка Rule и сигнатуры 
\begin_inset Formula $s$
\end_inset

 без знания какой-либо ещё информации об алгоритме.
\end_layout

\begin_layout Proof
Рассмотрим произвольный отмеченный многочлен 
\begin_inset Formula $R[L]$
\end_inset

 с сигнатурой 
\begin_inset Formula $\Sig(R[L])=s$
\end_inset

 и упорядоченное по порядку добавления подмножество 
\begin_inset Formula $\{R[l_{1}],\ldots,R[l_{i}],\ldots\}$
\end_inset

 отмеченных многочленов с сигнатурами удовлетворяющими условию 
\begin_inset Formula $\Sig(R[l_{i}])=v_{i}\Sig(R[L])$
\end_inset

.
 С точки зрения делимости любая из потенциально бесконечного числа пар 
\begin_inset Formula $\{R[L],R[l_{i}]\}$
\end_inset

 может быть цепью S-пар длины 2.
 Но идеал 
\begin_inset Formula $\left(v_{1},\ldots,v_{i},\ldots\right)$
\end_inset

 в 
\begin_inset Formula $\mathbb{T}$
\end_inset

 является конечно порождённым по лемме Диксона, поэтому после некоторого
 шага 
\begin_inset Formula $i_{0}$
\end_inset

 будет выполняться 
\begin_inset Formula $\forall i>i_{0}\,\exists j\leqslant i_{0}$
\end_inset

 такое что 
\begin_inset Formula $v_{j}|v_{i}$
\end_inset

.
 Поэтому при 
\begin_inset Formula $\forall i>i_{0}$
\end_inset

 последовательность 
\begin_inset Formula $\{R[L],R[l_{i}]\}$
\end_inset

 не может являться цепью S-пар, поскольку 
\begin_inset Formula $\Sig(R[L])\cdot v_{i}$
\end_inset

 перезаписывается 
\begin_inset Formula $\Sig(R[l_{j}])\cdot\frac{v_{i}}{v_{j}}$
\end_inset

 и существует не более чем 
\begin_inset Formula $i_{0}$
\end_inset

 цепей S-пар длины 2, начинающихся с многочлена 
\begin_inset Formula $R[L]$
\end_inset

.
\end_layout

\begin_layout Definition
Конечное множество концов цепей S-пар длины 2, начинающихся с 
\begin_inset Formula $R[L]$
\end_inset

 будет называться 
\emph on
множеством S-порождённых
\emph default
 
\begin_inset Formula $R[L]$
\end_inset

.
\end_layout

\begin_layout Theorem
Если алгоритм не останавливается на некоторых входных данных, то он порождает
 бесконечную цепь S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

.
\end_layout

\begin_layout Proof
Поскольку при работе с понятием бесконечности требуется некоторая строгость,
 дадим следующее определение.
\end_layout

\begin_deeper
\begin_layout Definition
Отмеченный многочлен 
\begin_inset Formula $R[l]$
\end_inset

 называется 
\emph on
генератором цепи S-пар
\emph default
, если существует бесконечное множество различных конечных цепей S-пар,
 начинающихся с 
\begin_inset Formula $R[l]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Если алгоритм не останавливается, то многочлен входного множества 
\begin_inset Formula $R[m]=((1,m),f_{m})$
\end_inset

 является генератором цепи S-пар, поскольку каждый многочлен 
\begin_inset Formula $R[l]$
\end_inset

, порождаемый в последнем не завершающемся вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 имеет индекс сигнатуры 
\begin_inset Formula $m$
\end_inset

 и является концом цепи S-пар
\begin_inset Formula $\{R[m],\ldots,R[l^{**}],R[l^{*}],R[l]\}$
\end_inset

.
\end_layout

\begin_layout Proof
Теперь предположим, что про некоторый отмеченный многочлен 
\begin_inset Formula $R[l]$
\end_inset

 известно, что он является генератором цепи S-пар.
 Один из конечного множества S-порождённых 
\begin_inset Formula $R[l]$
\end_inset

 также должен являться генератором цепи S-пар, поскольку в противном случае
 число различных цепей, исходящих из 
\begin_inset Formula $R[l]$
\end_inset

, было бы ограничено конечной суммой конечных количеств цепей, выходящих
 из S-порождённых плюс конечным количеством цепей длины 2, выходящих из
 
\begin_inset Formula $R[l]$
\end_inset

.
 Поэтому, если отмеченный многочлен 
\begin_inset Formula $R[l]$
\end_inset

 является генератором цепи S-пар, среди его S-порождённых всегда может быть
 выбран другой генератор цепи S-пар.
 Таким образом может быть построена бесконечная цепь S-пар, начинающаяся
 
\begin_inset Formula $r_{1}$
\end_inset

 и состоящая из генераторов, что доказывает теорему.
\end_layout

\begin_layout Standard
Для следующей теоремы необходимо ввести порядок на частных, образованных
 мономами, путём транзитивного расширения порядка на мономах: 
\begin_inset Formula $\frac{m_{1}}{m_{2}}\succ_{q}\frac{m_{3}}{m_{4}}\Leftrightarrow m_{1}m_{4}\succ m_{3}m_{2}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:f_g_3_props"

\end_inset

Если алгоритм не останавливается на некоторых входных данных, то после некоторог
о конечного шага множество 
\begin_inset Formula $G$
\end_inset

 содержит индексы пары отмеченных многочленов 
\begin_inset Formula $f',f$
\end_inset

, причём 
\begin_inset Formula $f$
\end_inset

 сгенерирован после 
\begin_inset Formula $f'$
\end_inset

 и выполняются следующие 3 свойства:
\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\HM(f')|\HM(f),
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\frac{\HM(f')}{\Sig(f')}\succ_{q}\frac{\HM(f)}{\Sig(f)},
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\Sig(f')|\Sig(f).
\]

\end_inset


\end_layout

\begin_layout Proof
При работе с цепями S-пар является важным тот факт, что многочлен никогда
 не редуцируется дальше, после того как он был использован для создания
 S-пары в качестве старшей по сигнатуре части.
 Факт выполняется, поскольку индексы всех многочлены, которые ещё могут
 быть подвергнуты редукции находятся в множестве ToDo, а индексы многочленов,
 используемых как старшая часть S-пары, находятся в 
\begin_inset Formula $G$
\end_inset

 или в Done.
 Поэтому многочлен 
\begin_inset Formula $h_{n}$
\end_inset

, предшествующий многочлену 
\begin_inset Formula $h_{n+1}$
\end_inset

 в цепи S-пар, сохраняет одно и то же значение 
\begin_inset Formula $\poly(h_{n})$
\end_inset

 после того как был использован для создания какой-либо S-пары.
 И можно утверждать, что выполняется равенство 
\begin_inset Formula 
\[
\poly(h_{n+1})=c\frac{\Sig(h_{n+1})}{\Sig(h_{n})}\poly(h_{n})+g_{n},
\]

\end_inset

где 
\begin_inset Formula $g_{n}$
\end_inset

 -- многочлен, соответствующей младшей части S-пары, использованный при
 генерации 
\begin_inset Formula $h_{n+1}$
\end_inset

 из 
\begin_inset Formula $h_{n}$
\end_inset

, удовлетворяющее следующему:
\begin_inset Formula 
\begin{equation}
\HM(h_{n+1})\prec\HM\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)=\HM(g_{n}),\,\Sig(h_{n+1})=\Sig\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)\succ\Sig(g_{n}).\label{eq:spair-chain}
\end{equation}

\end_inset

Из первого неравенства в 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:spair-chain"

\end_inset

 получаем, что 
\begin_inset Formula $\frac{\HM(h_{n})}{\Sig(h_{n})}\succ_{q}\frac{\HM(h_{n+1})}{\Sig(h_{n+1})}$
\end_inset

, поэтому в цепи S-пар частные 
\begin_inset Formula $\frac{\HM(h_{i})}{\Sig(h_{i})}$
\end_inset

 строго убывают в смысле порядка на частных.
 Этот факт не может быть напрямую использован для доказательства конечности
 цепей, поскольку порядок на частных, в отличии от порядка на мономах, не
 даёт вполне упорядоченности: к примеру последовательность 
\begin_inset Formula $\frac{x}{x}\succ_{q}\frac{x}{x^{2}}\succ_{q}\cdots\succ_{q}\frac{x}{x^{n}}>_{q}\cdots$
\end_inset

 является бесконечно убывающей.
\end_layout

\begin_layout Proof
Существует две возможности для отношения между 
\begin_inset Formula $\HM$
\end_inset

 соседних элементов.
 Известно, что 
\begin_inset Formula $\Sig(h_{n})|\Sig(h_{n+1})$
\end_inset

, поэтому они или имеют равные сигнатуры, или 
\begin_inset Formula $\totaldeg(h_{n})<\totaldeg(h_{n+1})$
\end_inset

.
 В первом случае 
\begin_inset Formula $\HM(h_{n+1})\prec\HM(h_{n})$
\end_inset

 при равенстве полной степени, а во втором -- 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(h_{n+1})\succ\HM(h_{n})$
\end_inset

, поскольку полные степени 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\HM$
\end_inset

 отличаются
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
 Поэтому, последовательность
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\HM$
\end_inset

 элементов бесконечной цепи S-пар состоит из блоков с фиксированной полной
 степенью, где 
\begin_inset Formula $\HM$
\end_inset

 внутри блока строго убывают.
 Длины блоков могут быть равными единице, и полные степени блоков возрастают.
 Это приводит к следующим свойствам: цепь S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

 не может содержать элементов с равными 
\begin_inset Formula $\HM$
\end_inset

 и 
\begin_inset Formula $\HM(h_{i})|\HM(h_{j})$
\end_inset

 возможно только в случае 
\begin_inset Formula $i<j$
\end_inset

 и 
\begin_inset Formula $\totaldeg(h_{i})<\totaldeg(h_{j})$
\end_inset

.
\end_layout

\begin_layout Proof
Это позволяет использовать метод аналогичный используемому в Предложении
 14 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

: рассмотрим 
\begin_inset Formula $\HM$
\end_inset

 бесконечной цепи S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

.
 Они порождают бесконечную последовательность в 
\begin_inset Formula $\mathbb{T}$
\end_inset

, поэтому по лемме Диксона существует два многочлена, с 
\begin_inset Formula $\HM(h_{i})|\HM(h_{j})$
\end_inset

.
 Из предыдущего абзаца следует, что при этом 
\begin_inset Formula $i<j$
\end_inset

, а при помощи свойств цепи S-пар мы получаем, что 
\begin_inset Formula $\Sig(h_{i})|\Sig(h_{i+1})|\cdots|\Sig(h_{j})$
\end_inset

 и 
\begin_inset Formula $\frac{\HM(h_{i})}{\Sig(h_{i})}\succ_{q}\frac{\HM(h_{i+1})}{\Sig(h_{i+1})}\succ_{q}\cdots\succ_{q}\frac{\HM(h_{j})}{\Sig(h_{j})}$
\end_inset

, поэтому можно взять 
\begin_inset Formula $f'=h_{i}$
\end_inset

 и 
\begin_inset Formula $f=h_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
Последнее свойство о делимости сигнатур из утверждения теоремы является
 побочным эффектом от использования цепей S-пар и не используется в дальнейшем.
 При этом первые два свойства используются для построения сигнатурного редуктора.
\end_layout

\begin_layout Fact
Если никакие многочлены не были отброшены проверками критериев 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-b"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

, рассматриваемый алгоритм завершается.
\end_layout

\begin_layout Proof
Данное выше доказательство теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 не опирается на соответствие между порядком 
\begin_inset Formula $\succ_{P}$
\end_inset

 на сигнатурах и порядком 
\begin_inset Formula $\succ$
\end_inset

 на мономах многочленов.
 Но алгоритм F5 использует один и тот же порядок в обоих случаях, и теперь
 мы можем воспользоваться этим фактом и переформулировать отношение на частных
 мономов из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 в отношение на сигнатурах: 
\begin_inset Formula 
\[
\Sig(f)\succ_{P}t\cdot\Sig(f'),\mbox{ где }t=\frac{\HM(f)}{\HM(f')}\in\mathbb{T}.
\]

\end_inset

Это неравенство вместе с делимостью 
\begin_inset Formula $\HM$
\end_inset

 из утверждения теоремы показывает, что 
\begin_inset Formula $tf'$
\end_inset

 является редуктором для 
\begin_inset Formula $f$
\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 с точки зрения сигнатуры -- он проходит проверки 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-a"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-d"

\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 и его сигнатура меньше.
 При отсутствии проверки критериев 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-b"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

 это напрямую приводило бы к противоречию, так как в момент добавления 
\begin_inset Formula $f$
\end_inset

 в 
\begin_inset Formula $G$
\end_inset

 отмеченный многочлен 
\begin_inset Formula $f'$
\end_inset

 уже был там и процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 должна была бы редуцировать 
\begin_inset Formula $f$
\end_inset

 по 
\begin_inset Formula $f'$
\end_inset

.
\end_layout

\begin_layout Standard
Но существование критериев делает возможной ситуацию, в которой 
\begin_inset Formula $tf'$
\end_inset

 отбрасывается проверками 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-b"

\end_inset

 или 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

 процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Идея дальнейших рассуждений состоит в том, чтобы показать что в этом случае
 может быть найден другой сигнатурный редуктор 
\begin_inset Formula $f$
\end_inset

, который не будет отброшен проверками и таким образом прийти к противоречию.
 Последующие главы работы посвящены этому.
\end_layout

\begin_layout Subsubsection
S-пары с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset


\end_layout

\begin_layout Standard
В этом и последующих разделах доказательства остановки 
\begin_inset Formula $g$
\end_inset

 подразумевается некоторым фиксированным отмеченным многочленом с индексом
 сигнатуры 
\begin_inset Formula $m$
\end_inset

, индекс которого добавлен на некоторой итерации алгоритма в Done.
 Мы будем анализировать состояние алгоритма в момент непосредственно предшествую
щий добавлению 
\begin_inset Formula $g$
\end_inset

 в Done в вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 с 
\begin_inset Formula $i=m$
\end_inset

.
 Рассмотрим в этот момент конечное множество 
\begin_inset Formula $G_{m}\cup$
\end_inset

Done.
 Оно состоит из чисел, являющихся позициями отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, поэтому его элементы могут быть упорядочены в соответствии с позицией
 в 
\begin_inset Formula $R$
\end_inset

 и оно окажется записанным в виде упорядоченной последовательности целых
 чисел 
\begin_inset Formula $G_{g}=\{b_{1},\ldots,b_{N}\}$
\end_inset

 с 
\begin_inset Formula $b_{j}<b_{j+1}$
\end_inset

.
 Необходимо отметить, что этот порядок соответствует порядку отмеченных
 многочленов в последовательности, получаемой склеиванием массивов правил
 
\begin_inset Formula $\mbox{Rule}[m]:\mbox{Rule}[m-1]:\cdots:\mbox{Rule}[1]$
\end_inset

, поскольку добавление нового многочлена в 
\begin_inset Formula $R$
\end_inset

 всегда сопровождается добавлением соответствующего правила.
 Но этот порядок может отличаться от порядка в котором многочлены добавлялись
 в множество 
\begin_inset Formula $G_{m}\cup$
\end_inset

Done, поскольку многочлены одной полной степени добавляются в Done в порядке
 возрастания сигнатуры, при том что добавление многочленов одной полной
 степени в 
\begin_inset Formula $R$
\end_inset

 производится в довольно случайном порядке в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Далее для простоты мы будем говорить о отмеченных многочленах 
\begin_inset Formula $b_{j}$
\end_inset

 в 
\begin_inset Formula $G_{g}$
\end_inset

, подразумевая что 
\begin_inset Formula $G_{g}$
\end_inset

 является не упорядоченным списком позиций, а упорядоченным списком отмеченных
 многочленов, расположенных на этих позициях.
 В этой терминологии можно сказать, что все входные многочлены 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 присутствуют в 
\begin_inset Formula $G_{g}$
\end_inset

, поскольку они присутствуют в 
\begin_inset Formula $G_{m}$
\end_inset

 в момент его создания.
\end_layout

\begin_layout Standard
S-пары могут обрабатываться в алгоритме различным путями, но главный факт,
 описывающий порядок их обработки выражается следующими свойствами, соответствую
щими свойствам, использованным в Теореме 21 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

, но рассматриваются на произвольной итерации алгоритма, а не после его
 остановки.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exist-gg-repr"

\end_inset

К моменту добавления 
\begin_inset Formula $g$
\end_inset

 в Done каждая S-пара элементов 
\begin_inset Formula $G_{g}$
\end_inset

, сигнатура которой меньше 
\begin_inset Formula $\Sig(g)$
\end_inset

, удовлетворяет одному из трёх свойств:
\end_layout

\begin_layout Enumerate
S-пара имеет часть, которая была отброшена критерием проверки нормальной
 формы 
\begin_inset Formula $\varphi$
\end_inset

 (в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 или в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

).
 Такие S-пары будут называться 
\emph on
S-парами с частью, удовлетворяющей критерию F5
\emph default
.
 
\end_layout

\begin_layout Enumerate
S-пара имеет часть, которая была отброшена проверкой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 (в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 или в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

).
 Такие S-пары будут называться 
\emph on
S-парами с частью, удовлетворяющей критерию Перезаписи
\emph default
.
\end_layout

\begin_layout Enumerate
S-пара не была отброшена, поэтому её S-многочлен был сигнатурно редуцирован
 по некоторым элементам 
\begin_inset Formula $G_{g}$
\end_inset

 и результат был добавлен как элемент 
\begin_inset Formula $G_{g}$
\end_inset

.
 Такие S-пары будут называться 
\emph on
S-парами с известным 
\begin_inset Formula $G_{g}$
\end_inset

-представлением
\emph default
.
\end_layout

\begin_layout Proof
S-пары элементов 
\begin_inset Formula $G_{g}$
\end_inset

 обрабатываются в алгоритме двумя основными путями.
 Основной путь используется для S-пар, полная степень которых больше чем
 полная степень породивших их многочленов.
 Такие S-пары обрабатываются в следующем порядке:
\end_layout

\begin_deeper
\begin_layout Itemize
в процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 они рассматриваются функцией 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 при перемещении элементов 
\begin_inset Formula $G_{i}$
\end_inset

 из 
\begin_inset Formula $R_{d}=Done$
\end_inset

 и при обработке входного многочлена 
\begin_inset Formula $f_{i}$
\end_inset


\end_layout

\begin_layout Itemize
функция 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 или отбрасывает пару после проверки нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 или добавляет пару в 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Itemize
S-пара извлекается из 
\begin_inset Formula $P$
\end_inset

 и передаётся в функцию 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset


\end_layout

\begin_layout Itemize
функция 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 или отбрасывает пару после проверки 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 или добавляет S-многочлен в 
\begin_inset Formula $F_{d}=ToDo$
\end_inset


\end_layout

\begin_layout Itemize
на некоторой итерации процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 берёт S-многочлен из ToDo, производит некоторые сигнатурные редукции и
 добавляет результат в Done.
\end_layout

\end_deeper
\begin_layout Proof
Второй путь обработки используется для S-пар, соответствующих редукциям,
 запрещённым алгоритмом -- соответствующие S-пары порождаются многочленами
 
\begin_inset Formula $R[l^{*}]$
\end_inset

 и 
\begin_inset Formula $R[l_{*}]$
\end_inset

, такими что 
\begin_inset Formula $\HM(R[l^{*}])|\HM(R[l_{*}])$
\end_inset

, и S-многочлен им соответствующий имеет вид 
\begin_inset Formula $\overline{u_{l}}\cdot\poly(R[l^{*}])-1\cdot\poly(R[l_{*}])$
\end_inset

.
 Такая ситуация возможна, если для элементов 
\begin_inset Formula $G_{g}$
\end_inset

 редукция 
\begin_inset Formula $R[l_{*}]$
\end_inset

 по 
\begin_inset Formula $R[l^{*}]$
\end_inset

 была запрещена сравнением сигнатур в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 или проверками в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Для этого случая порядок 
\begin_inset Quotes fld
\end_inset

обработки
\begin_inset Quotes frd
\end_inset

 S-пары такой:
\end_layout

\begin_deeper
\begin_layout Itemize
часть S-пары 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset

 проверяется в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-a"

\end_inset

 выполнено, поскольку 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(R[l^{*}])|\HM(R[l_{*}])$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 Она может быть отброшена другими проверками:
\end_layout

\begin_deeper
\begin_layout Itemize
отбрасывание пунктом 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-b"

\end_inset

 соответствует проверке нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 для 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset


\end_layout

\begin_layout Itemize
отбрасывание пунктом 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

 соответствует проверке 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 для 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset


\end_layout

\begin_layout Itemize
отбрасывание пунктом 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-d"

\end_inset

 означает, что один из многочленов 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset

 и 
\begin_inset Formula $1\cdot R[l_{*}]$
\end_inset

 может быть перезаписано другим, поэтому, если S-пара не была отброшена
 проверкой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

, данный тип отбрасывания означает, что часть S-пары 
\begin_inset Formula $1\cdot R[l_{*}]$
\end_inset

 не проходит проверку 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
S-пары, не отброшенные в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращаются в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Сравнение сигнатур в 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 запрещает редукцию 
\begin_inset Formula $R[l_{*}]$
\end_inset

 по 
\begin_inset Formula $R[l^{*}]$
\end_inset

 и помещает вычисленный S-многочлен, соответствующий S-паре, в множество
 ToDo
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 добавляет этот многочлен в ToDo
\end_layout

\begin_layout Itemize
последний шаг совпадает для обоих путей обработки S-пар: на некоторой итерации
 процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 берёт S-многочлен из ToDo, производит некоторые сигнатурные редукции и
 добавляет результат в Done.
\end_layout

\end_deeper
\begin_layout Proof
Из путей обработки S-пар видно, что после окончания обработки каждая S-пара
 или редуцирована и добавлена в Done или одна из частей S-пары была отброшена
 проверкой нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 или критерием 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

.
 Некоторые S-пары могут оказываться на путях обработки несколько раз, к
 примеру это происходит на итерации в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 со значением 
\begin_inset Formula $d$
\end_inset

, не изменившимся с прошлой итерации.
 Если S-пара была отброшена при первой попытке обработки, то она будет точно
 также отброшена и на следующей попытке.
 Если первая обработка добавила редуцированный многочлен в Done, то пара
 будет отбрасываться при следующих попытках обработки проверкой
\family typewriter
 
\family default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 за счёт этого многочлена.
 Поэтому все попытки обработки, кроме первой, не дают ничего нового.
\end_layout

\begin_layout Proof
Путь обработки не является одной процедурой, и в случае, если алгоритм не
 останавливается, некоторые S-пары всегда находятся в середине обработки,
 при этом или соответствующая S-пара находится в очереди 
\begin_inset Formula $P$
\end_inset

 или S-многочлен в очереди ToDo.
 Поэтому необходимо понять, обработка каких S-пар уже завершилась в рассматривае
мый нами момент.
 Элементы 
\begin_inset Formula $P$
\end_inset

 и ToDo извлекаются в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 в порядке возрастания сигнатур.
 S-пары с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset

, могут быть разделены на 3 класса:
\end_layout

\begin_deeper
\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)>\sigidx(\Sig(g))=1$
\end_inset

.
 Они обрабатывались на предыдущих вызовах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

.
\end_layout

\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)<\totaldeg(\Sig(g))$
\end_inset

.
 Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, который обрабатывает 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)=\totaldeg(\Sig(g)),w\prec\Sig(g)$
\end_inset

.
 Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

, который обрабатывает 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
S-пары из этих классов не могут находиться в середине пути обработки, потому
 что в рассматриваемом состоянии алгоритма обработка только что завершена
 для 
\begin_inset Formula $g$
\end_inset

, поэтому ни 
\begin_inset Formula $P$
\end_inset

 ни ToDo не содержат необработанных элементов с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset

.
 Осталось показать, что для всех S-пар из утверждения теоремы обработка
 начиналась хотя бы один раз.
 Это просто проверить для первых двух классов: обработка соответствующих
 S-пар была начата по крайней мере один раз путём вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 непосредственно перед тем, как наибольший из порождающих S-пару был добавлен
 в 
\begin_inset Formula $G$
\end_inset

.
 Для S-пар третьего класса ситуация зависит от полной степени её порождающих.
 Если оба порождающих S-пары имеют полную степень 
\begin_inset Formula $<\totaldeg(g)$
\end_inset

, то её обработка была начата в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 аналогично S-парам первых двух классов.
 Но некоторые S-пары третьего класса могут иметь старший по сигнатуре порождающи
й 
\begin_inset Formula $R[l]$
\end_inset

, такой что 
\begin_inset Formula $\totaldeg(R[l])=\totaldeg(g),\,\Sig(R[l])\prec\Sig(g)$
\end_inset

.
 Они обрабатываются вторым из рассмотренных путей обработки S-пар, поэтому
 обработка таких S-пар ещё не стартовала к моменту последнего вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

.
 Однако, их обработка начинается внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 до изучаемого нами момента: процедура выбирает многочлены из ToDo в порядке
 возрастания сигнатуры, поэтому 
\begin_inset Formula $R[l]$
\end_inset

 редуцируется перед 
\begin_inset Formula $g$
\end_inset

 и в процессе редукции 
\begin_inset Formula $R[l]$
\end_inset

 непосредственно перед добавлением 
\begin_inset Formula $R[l]$
\end_inset

 в Done вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 начинает обработку всех таких S-пар.
\end_layout

\begin_layout Standard
Понятия 
\emph on
удовлетворять критерию F5 
\emph default
и 
\emph on
удовлетворять критерию Перезаписи
\emph default
 могут быть расширены на произвольные умноженные на моном отмеченные многочлены
 
\begin_inset Formula $sh,\, h\in G_{g}$
\end_inset

:
\end_layout

\begin_layout Definition
Умноженный на моном отмеченный многочлен  
\begin_inset Formula $sr_{i},\, r_{i}\in G_{g}$
\end_inset

 называется 
\emph on
удовлетворяющим критерию F5
\emph default
, если 
\begin_inset Formula $\varphi(s\Sig(r_{i}))\ne s\Sig(r_{i})$
\end_inset

, где 
\begin_inset Formula $\varphi$
\end_inset

 -- оператор нормальной формы по отношению к 
\begin_inset Formula $G_{index(r_{i})-1}$
\end_inset

.
\end_layout

\begin_layout Standard
Это определение эквивалентно тому, что 
\begin_inset Formula $sr_{i}$
\end_inset

 является ненормализованным отмеченным многочленом с точки зрения определения
 2 в части 5 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

.
\end_layout

\begin_layout Definition
Умноженный на моном отмеченный многочлен 
\begin_inset Formula $sr_{i},\, r_{i}\in G_{g}$
\end_inset

 называется 
\emph on
удовлетворяющим критерию Перезаписи
\emph default
, если 
\begin_inset Formula $\exists j>i$
\end_inset

 такое что 
\begin_inset Formula $\Sig(r_{j})|s\Sig(r_{i})$
\end_inset

.
\end_layout

\begin_layout Standard
В случае, если 
\begin_inset Formula $sr_{i}$
\end_inset

 является частью S-пары, эти определения эквиваленты проверкам, производимым
 в алгоритме, в том смысле, что часть S-пары отбрасывается алгоритмом тогда
 и только тогда, когда она удовлетворяет данному определению как умноженный
 на моном отмеченный многочлен.
 Для обоих критериев выполняется важное свойство, утверждающее, что если
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $sr_{i}$
\end_inset

 удовлетворяет критерию, то и дополнительно домноженный многочлен 
\begin_inset Formula $s_{1}sr_{i}$
\end_inset

 также ему удовлетворяет.
\end_layout

\begin_layout Subsubsection
Представления
\end_layout

\begin_layout Standard
Для описания способов, которыми многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан как элемент идеала 
\begin_inset Formula $\left(G_{g}\right)$
\end_inset

 мы будем использовать сигнатурные представления над 
\begin_inset Formula $G_{g}$
\end_inset

, называемые также сигнатурными 
\begin_inset Formula $G_{g}$
\end_inset

-представлениями.
\end_layout

\begin_layout Paragraph
Примеры
\end_layout

\begin_layout Example
Первый важный пример 
\begin_inset Formula $G_{g}$
\end_inset

-представления тривиален: отмеченный многочлен из 
\begin_inset Formula $G_{g}$
\end_inset

 равен сумме одного слагаемого -- самого себя с единичным коэффициентом:
 
\begin_inset Formula 
\[
b_{j}=1\cdot b_{j}.
\]

\end_inset


\end_layout

\begin_layout Standard
Это 
\begin_inset Formula $G_{g}$
\end_inset

-представление сигнатурно.
 Запрет на наличие в представлении нескольких элементов, имеющих одинаковый
 моном 
\begin_inset Formula $t_{k}$
\end_inset

 и многочлен 
\begin_inset Formula $b_{i_{k}}$
\end_inset

 гарантирует, что все элементы представления, отличающиеся только коэффициентом
 из поля 
\begin_inset Formula $c_{k}$
\end_inset

 скомбинированы вместе путём суммирования коэффициентов из поля.
 Поэтому выражения вида 
\begin_inset Formula $b_{j}=-1\cdot b_{j}+2\cdot b_{j}$
\end_inset

 и 
\begin_inset Formula $b_{j}=2x\cdot b_{k}+1\cdot b_{j}-2x\cdot b_{k}$
\end_inset

 не являются корректными 
\begin_inset Formula $G_{g}$
\end_inset

-представлениями.
\end_layout

\begin_layout Example
Отмеченный многочлен 
\begin_inset Formula $b_{j}\in G_{g}$
\end_inset

, домноженный на произвольный многочлен 
\begin_inset Formula $h$
\end_inset

 также имеет простое 
\begin_inset Formula $G_{g}$
\end_inset

-представление, получающееся из записи 
\begin_inset Formula $h$
\end_inset

 в виде суммы термов: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $h=\sum_{k}m_{k},\, m_{k}\in\mathcal{K}\times\mathbb{T}$
\end_inset

.
 Это 
\begin_inset Formula $G_{g}$
\end_inset

-представление имеет форму 
\begin_inset Formula 
\begin{equation}
b_{j}h=\sum_{k}m_{k}\cdot b_{j}\label{eq:repr-ex-2}
\end{equation}

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
и также является сигнатурным.
\end_layout

\begin_layout Standard
Отмеченный многочлен может иметь бесконечное множество различных представлений:
 к любому представлению можно добавить элементы, соответствующие сизигии,
 сгруппировать элементы с одновременно равными мономами и многочленами и
 получить другое корректное представление.
 Это будет представление того же многочлена, поскольку сумма многочленов,
 соответствующих элементам сизигии равна 0.
\end_layout

\begin_layout Example
Произведение двух многочленов из 
\begin_inset Formula $G_{g}$
\end_inset

 имеет 2 представления вида 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:repr-ex-2"

\end_inset

, которые отличаются прибавлением сизигии:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
b_{j}b_{i}=\sum_{k}m_{i_{k}}\cdot b_{j}=\sum_{k}m_{i_{k}}\cdot b_{j}+0=\sum_{k}m_{i_{k}}\cdot b_{j}+\left(\sum_{k}m_{j_{k}}\cdot b_{i}-\sum_{k}m_{i_{k}}\cdot b_{j}\right)=\sum_{k}m_{j_{k}}\cdot b_{i},
\]

\end_inset

где 
\begin_inset Formula $m_{i_{k}}$
\end_inset

 -- термы 
\begin_inset Formula $b_{i}$
\end_inset

, а 
\begin_inset Formula $m_{j_{k}}$
\end_inset

 -- термы 
\begin_inset Formula $b_{j}$
\end_inset

.
\end_layout

\begin_layout Example
Нулевой многочлен имеет пустое представление и представление, соответствующее
 каждой сизигии:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
0=\sum_{\varnothing}\mbox{(empty sum)}=\sum_{k}m_{j_{k}}\cdot b_{i}+\sum_{k}(-m_{i_{k}})\cdot b_{j},
\]

\end_inset

где 
\begin_inset Formula $m_{i_{k}}$
\end_inset

 и 
\begin_inset Formula $m_{j_{k}}$
\end_inset

 взяты из предыдущего примера.
 Все непустые представления нулевого многочлена не сигнатурны.
\end_layout

\begin_layout Standard
Другой важный пример 
\begin_inset Formula $G_{g}$
\end_inset

-представлений получается из определений сигнатуры и идеала.
 Все отмеченные многочлены, вычисляемые алгоритмом, принадлежат идеалу 
\begin_inset Formula $\left(f_{1},\ldots,f_{m}\right)$
\end_inset

.
 Поэтому любой отмеченный многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан в виде 
\begin_inset Formula $\sum_{i}f_{i}g_{i}$
\end_inset

, где 
\begin_inset Formula $g_{i}$
\end_inset

 -- однородные многочлены.
 Все входные многочлены 
\begin_inset Formula $f_{i}$
\end_inset

 принадлежат 
\begin_inset Formula $G_{g}$
\end_inset

, 
\end_layout

\begin_layout Standard
поэтому 
\begin_inset Formula $f_{i}g_{i}$
\end_inset

 имеют 
\begin_inset Formula $G_{g}$
\end_inset

-представления вида 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:repr-ex-2"

\end_inset

.
\end_layout

\begin_layout Example
Сумма этих представлений даёт следующее сигнатурное представление: 
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot b_{i_{k}},\, m_{k}\in\mathcal{K}\times\mathbb{T},\, b_{i_{k}}\in\left\{ f_{1},\ldots,f_{m}\right\} \subset G_{g}.
\]

\end_inset


\end_layout

\begin_layout Definition
Частный случай 
\begin_inset Formula $G_{g}$
\end_inset

-представления, при котором 
\begin_inset Formula $b_{i_{k}}$
\end_inset

 ограничены лишь входными многочленами, будет называться 
\emph on
входным представлением
\emph default
.
\end_layout

\begin_layout Standard
Входные представления всегда имеют единственный элемент максимальной сигнатуры.
 Произвольные 
\begin_inset Formula $G_{g}$
\end_inset

-представления не всегда обладают этим свойством, поскольку могут иметь
 несколько разных элементов с одинаковой максимальной сигнатурой, так как
 для них возможна ситуация 
\begin_inset Formula $m_{1}\Sig(b_{i_{1}})=m_{2}\Sig(b_{i_{2}})$
\end_inset

 при 
\begin_inset Formula $i_{1}\ne i_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее утверждение устанавливает связь между входными представлениями
 и понятием сигнатуры:
\end_layout

\begin_layout Claim
Отмеченный многочлен 
\begin_inset Formula $p$
\end_inset

 с известной сигнатурой 
\begin_inset Formula $\Sig(p)$
\end_inset

 имеет входное представление, состоящее из элемента 
\begin_inset Formula $c\Sig(p)\cdot f_{index(p)}$
\end_inset

 и некоторых других элементов с меньшими сигнатурами.
\end_layout

\begin_layout Proof
Утверждение вытекает из условия корректности в определении отмеченного многочлен
а.
\end_layout

\begin_layout Standard
Теорема 1 из 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 утверждает, что все многочлены, порождаемые алгоритмом, допустимы, а определени
е допустимости ссылается на функцию 
\begin_inset Formula $v$
\end_inset

, которая соответствует суммированию элементов входного представления --
 поэтому в силу этой теоремы все элементы 
\begin_inset Formula $R$
\end_inset

 удовлетворяют условию корректности допустимых многочленов, и мы будем применять
 предыдущее утверждение ко всем таким многочленам.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example-of-having-gg-repr"

\end_inset

Последний пример восходит к S-парам с известным 
\begin_inset Formula $G_{g}$
\end_inset

-представлением.
 S-многочлен, порождённый 
\begin_inset Formula $b_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $b_{l_{*}}$
\end_inset

 из 
\begin_inset Formula $G_{g}$
\end_inset

, имеет вид 
\begin_inset Formula $p=\overline{u_{l}}\poly(b_{l^{*}})-\underline{u_{l}}\poly(b_{l_{*}})$
\end_inset

.
 Из процесса редукции вытекает, что 
\begin_inset Formula $p$
\end_inset

 сигнатурно редуцируется и результат добавляется в 
\begin_inset Formula $G_{g}$
\end_inset

 как некоторый отмеченный многочлен 
\begin_inset Formula $b_{l}$
\end_inset

.
 Отсюда его 
\begin_inset Formula $G_{g}$
\end_inset

-представление имеет вид:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot b_{n_{k}}+1\cdot b_{l},
\]

\end_inset

где сигнатуры элементов 
\begin_inset Formula $m_{k}\cdot b_{n_{k}}$
\end_inset

 меньше чем 
\begin_inset Formula $\Sig(b_{l})=\Sig(p)$
\end_inset

.
 Значение 
\begin_inset Formula $l$
\end_inset

 -- позиция 
\begin_inset Formula $b_{l}$
\end_inset

 в упорядоченном списке 
\begin_inset Formula $G_{g}$
\end_inset

.
 В данном представлении 
\begin_inset Formula $l$
\end_inset

 больше чем 
\begin_inset Formula $l^{*}$
\end_inset

 и 
\begin_inset Formula $l_{*}$
\end_inset

, поскольку соответствующий отмеченный многочлен 
\begin_inset Formula $b_{l}$
\end_inset

 был добавлен в 
\begin_inset Formula $R$
\end_inset

 в момент подсчёта S-многочлена в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 или 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

, поэтому многочлены 
\begin_inset Formula $b_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $b_{l_{*}}$
\end_inset

, использованные для его создания не отброшенной S-пары, уже присутствовали
 в 
\begin_inset Formula $R$
\end_inset

 к тому моменту, а порядок 
\begin_inset Formula $G_{g}$
\end_inset

 соответствует порядку добавления элементов в 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Paragraph
Порядок на представлениях
\end_layout

\begin_layout Definition
Для введения порядка на 
\begin_inset Formula $G_{g}$
\end_inset

-представлениях мы начнём с 
\emph on
порядка на элементах представления
\emph default
 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

: будем говорить, что 
\begin_inset Formula $c_{i}t_{i}\cdot b_{i}\gtrdot_{1}c_{j}t_{j}\cdot b_{j}$
\end_inset

 если выполняется один из следующих случаев:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $t_{i}\Sig(b_{i})\succ_{P}t_{j}\Sig(b_{j})$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
\end_inset

 и 
\begin_inset Formula $i<j$
\end_inset

 (сравнение позиций -- в обратную сторону).
\end_layout

\end_deeper
\begin_layout Standard
Этот порядок основан лишь на сравнение сигнатур и позиций отмеченных многочленов
 в упорядоченном списке 
\begin_inset Formula $G_{g}$
\end_inset

, но не зависит от коэффициента из поля.
 Единственный случай, в котором два элемента не могут быть упорядочены --
 одновременное равенство сигнатур 
\begin_inset Formula $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
\end_inset

 и позиций в списке 
\begin_inset Formula $i=j$
\end_inset

.
 Равенство позиций означает равенство многочленов 
\begin_inset Formula $b_{i}=b_{j}$
\end_inset

, что вместе с равенством сигнатур даёт 
\begin_inset Formula $t_{i}=t_{j}$
\end_inset

.
 Поэтому любые два элемента, принадлежащие одному корректному 
\begin_inset Formula $G_{g}$
\end_inset

 представлению являются сравнимыми с точки зрения порядка 
\begin_inset Formula $\lessdot_{1}$
\end_inset

, поскольку они имеют различные 
\begin_inset Formula $\left(t_{k},b_{k}\right)$
\end_inset

 по определению.
 Ниже приведены некоторые примеры сравнений элементов по 
\begin_inset Formula $\lessdot_{1}$
\end_inset

 для списка 
\begin_inset Formula $G_{g}=\left\{ b_{1},\, b_{2},\, b_{3}\right\} $
\end_inset

 из 3-х элементов с порядком на сигнатурах 
\begin_inset Formula $x\mathbf{F}_{i}\succ y\mathbf{F}_{i}$
\end_inset

 и сигнатурами 
\begin_inset Formula $\Sig(b_{1})=\mathbf{F}_{1},\Sig(b_{2})=\mathbf{F}_{2},\Sig(b_{3})=x\mathbf{F}_{1}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $y\cdot b_{1}\gtrdot_{1}100y\cdot b_{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части  
\begin_inset Formula $\succ_{P}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $x\cdot b_{1}\gtrdot_{1}y\cdot b_{1}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части 
\begin_inset Formula $\succ_{P}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $-x\cdot b_{1}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
и
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $2x\cdot b_{1}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 не сравнимы, поскольку сигнатуры и позиции в списке равны
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}\cdot b_{1}\lessdot_{1}y\cdot b_{3}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\prec_{P}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot_{1}x\cdot b_{3}$
\end_inset

 поскольку сигнатуры равны, а позиция в списке отмеченного многочлена левой
 части равна 1, что меньше чем позиция многочлена правой части, равная 3.
\end_layout

\begin_layout Standard
Для расширения этого порядка на 
\begin_inset Formula $G_{g}$
\end_inset

-представления целиком будем рассматривать 
\emph on
упорядоченную форму
\emph default
 представления, состоящую из всех его элементов, записанных в 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-убывающий список.
 Эта форма может быть использована для проверки на равенство, поскольку
 представления равны тогда и только тогда, когда равны их упорядоченные
 формы.
\end_layout

\begin_layout Definition
При помощи упорядоченных форм введём 
\emph on
порядок на 
\begin_inset Formula $G_{g}$
\end_inset

-представлениях
\emph default
: представление 
\begin_inset Formula $\sum_{k}m'_{k}\cdot b_{i'_{k}}$
\end_inset

 является 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем 
\begin_inset Formula $\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

, если упорядоченные формы для первого и второго представления удовлетворяют
 лексикографически расширенному на формы отношению 
\begin_inset Formula $\lessdot_{1}$
\end_inset

.
 Для особого случая, когда упорядоченные формы отличаются лишь длиной, более
 короткая форма будет называться 
\begin_inset Formula $\lessdot$
\end_inset

-меньшей.
 Если наибольшие различные элементы в упорядоченных формах двух представлений
 отличаются лишь коэффициентов поля, то представления являются не сравнимыми.
\end_layout

\begin_layout Standard
Далее даны некоторые примеры этого порядка для того же, трёх-элементного
 списка 
\begin_inset Formula $G_{g}$
\end_inset

.
 Все 
\begin_inset Formula $G_{g}$
\end_inset

-представления записаны в упорядоченных формах:
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}+xy\cdot b_{1}+y^{2}b_{1}\gtrdot x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}$
\end_inset

 поскольку 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $xy\cdot b_{1}\gtrdot_{1}y^{2}\cdot b_{1}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}\gtrdot x^{2}\cdot b_{1}$
\end_inset

 поскольку правая часть является началом левой
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 поскольку 
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot_{1}xy\cdot b_{1}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}\gtrdot y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 поскольку 
\begin_inset Formula $xy\cdot b_{1}\gtrdot_{1}y\cdot b_{3}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 и 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $2y\cdot b_{3}+y^{2}\cdot b_{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 не сравнимы, поскольку наибольшие различные элементы -- это 
\begin_inset Formula $y\cdot b_{3}$
\end_inset

 и 
\begin_inset Formula $2y\cdot b_{3}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Standard
Порядок на представлениях совместим с понятием сигнатурности представления:
\end_layout

\begin_layout Theorem
Если для пары представлений отмеченного многочлена 
\begin_inset Formula $p$
\end_inset

 выполняется отношение 
\begin_inset Formula $\sum_{k}m'_{k}\cdot b_{i'_{k}}\lessdot\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 и правое представление сигнатурно, то и левое представление сигнатурно.
\end_layout

\begin_layout Proof
Теорема легко следует из того, что сигнатуры элементов 
\begin_inset Formula $\lessdot$
\end_inset

-меньшего представления не могут быть 
\begin_inset Formula $\succ_{P}$
\end_inset

-больше, чем максимальная сигнатура 
\begin_inset Formula $\gtrdot$
\end_inset

-большего представления.
\end_layout

\begin_layout Standard
Важным фактом, позволяющим брать 
\begin_inset Formula $\lessdot$
\end_inset

-минимальный элемент, является вполне упорядоченность:
\end_layout

\begin_layout Theorem
Представления вполне упорядочены порядком 
\begin_inset Formula $\lessdot$
\end_inset

.
\end_layout

\begin_layout Proof
Количество различных отмеченных многочленов, входящих в элементы представления,
 конечно, поскольку оно равно 
\begin_inset Formula $|G_{g}|$
\end_inset

 для некоторого фиксированного 
\begin_inset Formula $g$
\end_inset

.
 Поэтому существование бесконечной 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-убывающей последовательности элементов представлений привело бы к существованию
 бесконечной 
\begin_inset Formula $\succ_{P}$
\end_inset

-убывающей последовательности сигнатур.
 Учитывая вполне упорядоченность сигнатур по 
\begin_inset Formula $\prec_{P}$
\end_inset

 мы получаем доказательство вполне упорядоченности элементов представлений
 по 
\begin_inset Formula $\lessdot{}_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
Прямое доказательство вполне упорядоченности представлений по 
\begin_inset Formula $\lessdot$
\end_inset

 на основе вполне упорядоченности их элементов по 
\begin_inset Formula $\lessdot_{1}$
\end_inset

 не является очень сложным, однако дабы не вдаваться в детали, используем
 теорему 2.5.5 книги 
\begin_inset CommandInset citation
LatexCommand cite
key "Baader.Nipkow98Term"

\end_inset

.
 Она утверждает вполне упорядоченность конечных наборов с порядком, являющимся
 лексикографическим расширением порядка на элементах набора.
 Это применимо к представлениям, так как они являются наборами своих элементов.
\end_layout

\begin_layout Paragraph
Последовательность представлений
\end_layout

\begin_layout Standard
Идея этой части состоит в построении конечной последовательности строго
 
\begin_inset Formula $\lessdot$
\end_inset

-убывающих сигнатурных 
\begin_inset Formula $G_{g}$
\end_inset

-представлений для некоторого отмеченного многочлена 
\begin_inset Formula $mh,\, m\in\mathcal{K}\times\mathbb{T},\, h\in G_{g}$
\end_inset

 со свойством 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

.
 Первым сигнатурным представлением в последовательности является 
\begin_inset Formula $mh=m\cdot h$
\end_inset

, а последнее представление имеет вид 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 со свойствами, выполняющимися для 
\begin_inset Formula $\forall k$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m_{k}b_{i_{k}}$
\end_inset

 не удовлетворяет критерию F5.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m_{k}b_{i_{k}}$
\end_inset

 не удовлетворяет критерию Перезаписи.
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\HM(m_{k}b_{i_{k}})\leqslant\HM(mh)$
\end_inset


\end_layout

\begin_layout Standard
Доказательство существования такой последовательности довольно похоже на
 доказательство Теоремы 21 из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 и основано на том, что если некоторое сигнатурное представление 
\begin_inset Formula $mh$
\end_inset

 содержит не удовлетворяющий одному из свойств элемент 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

, то может быть найдено 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее представление.
 Метод построения отличается для разных свойств, однако схема замены одинакова:
\end_layout

\begin_layout Itemize
выбирается некоторый элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 в представлении 
\begin_inset Formula $mh$
\end_inset

.
 Следует отметить, что 
\begin_inset Formula $K'$
\end_inset

 может как совпадать, так и отличаться от 
\begin_inset Formula $K$
\end_inset


\end_layout

\begin_layout Itemize
строится некоторое представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 для этого элемента
\end_layout

\begin_layout Itemize
показывается, что построенное представление 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\end_layout

\begin_layout Standard
Построение такого представления для 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 позволяет применить следующую лемму:
\end_layout

\begin_layout Lemma
Если элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 сигнатурного представления 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 имеет представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

, 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

, то 
\begin_inset Formula $mh$
\end_inset

 имеет сигнатурное представление, 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
\end_layout

\begin_layout Proof
Заменим элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 в представлении 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 на 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 и скомбинируем коэффициенты при элементах с одновременно одинаковыми мономами
 и многочленами, получив таким образом изменённое представления для 
\begin_inset Formula $mh$
\end_inset

.
 Оно будет 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 поскольку: все элементы 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-большие 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 идентичны в исходном и изменённом представлениях; элемент 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 содержится в исходном, но не в изменённом представлении; все остальные
 элементы в представлениях являются 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-меньшими, чем 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поэтому они не играют роли при сравнении.
 Сравнение выполняется даже в случае, когда при комбинировании коэффициентов
 все элементы обнулились.
 Этот случай может возникнуть, если исходное представление было равно 
\begin_inset Formula $mh=m_{K'}\cdot b_{i_{K'}}+\sum_{l}(-m_{l})\cdot b_{i_{l}}$
\end_inset

, что привело к изменённому представлению вообще не содержащему элементов:
 
\begin_inset Formula $mh=0$
\end_inset

.
 Оно является 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем любое непустое представление.
\end_layout

\begin_layout Standard
Теперь покажем, что представление элемента по вышеуказанной схеме может
 быть построено, если исходное представление содержит элемент, не удовлетворяющи
й по крайней мере одному из свойств.
\end_layout

\begin_layout Lemma
Если сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 содержит элемент, не удовлетворяющий свойству 1, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 обладающий 
\begin_inset Formula $G_{g}$
\end_inset

-представлением 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

.
\end_layout

\begin_layout Standard
Элемент, не обладающий первым свойством, удовлетворяет критерию F5, что
 позволяет позволяет использовать соображение о том, что 
\begin_inset Formula $m_{K}\Sig(b_{i_{K}})$
\end_inset

 не является его сигнатурой 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 аналогично теореме 20 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 Для этого случая берётся 
\begin_inset Formula $K'=K$
\end_inset

.
\end_layout

\begin_layout Proof
Рассмотрим входное представление 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 с сигнатурой 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимального элемента, равной 
\begin_inset Formula $m_{K}\Sig(b_{i_{K}})=(s_{0},j_{0})\in\mathbf{T}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{equation}
m_{K}b_{i_{K}}=c_{0}s_{0}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.\label{eq:input-repr-case1}
\end{equation}

\end_inset

Из удовлетворения критерия F5 следует, что 
\begin_inset Formula $s_{0}$
\end_inset

 может быть представлено как 
\begin_inset Formula $s_{0}=s_{1}\HM(f_{j_{1}}),\, j_{1}<j_{0}$
\end_inset

, откуда 
\begin_inset Formula $s_{0}f_{j_{0}}=s_{1}f_{j_{0}}f_{j_{1}}-s_{1}(f_{j_{1}}-\HM(f_{j_{1}}))f_{j_{0}}$
\end_inset

.
 На основе этого выражения можно получить другое представление для 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

, обозначая за 
\begin_inset Formula $m_{0i}$
\end_inset

 упорядоченные термы 
\begin_inset Formula $f_{j_{0}}$
\end_inset

, за 
\begin_inset Formula $m_{1i}$
\end_inset

 -- упорядоченные термы 
\begin_inset Formula $f_{j_{1}}$
\end_inset

 и за 
\begin_inset Formula $N_{0,}N_{1}$
\end_inset

 число термов в этих многочленах:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
m_{K}b_{i_{K}}=\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}+\sum_{i=2}^{N_{1}}-c_{0}s_{1}m_{1i}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.
\]

\end_inset

Это представление 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

 поскольку сигнатуры всех его элементов меньше чем 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(s_{0},j_{0})$
\end_inset

.
 Для элементов третьей суммы 
\begin_inset Formula $\sum_{l}m_{l}\cdot f_{i_{l}}$
\end_inset

 это следует из 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, где эти элементы являются меньшими элементами входного представления.
 Для элементов первой суммы 
\begin_inset Formula $\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}$
\end_inset

 это следует из неравенства индексов сигнатур 
\begin_inset Formula $j_{1}<j_{0}$
\end_inset

.
 А для второй суммы используем совпадение порядка на сигнатурах и на термах:
 все термы 
\begin_inset Formula $m_{1i},\, i\geqslant2$
\end_inset

 меньше, чем 
\begin_inset Formula $m_{11}$
\end_inset

, поэтому и выполняется неравенство для сигнатур: 
\begin_inset Formula $s_{1}(m_{1i},j_{0})\prec_{P}s_{1}(m_{11},j_{0})=(s_{0},j_{0})$
\end_inset

.
 
\end_layout

\begin_layout Lemma
Если сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 содержит элемент, не удовлетворяющий свойству 2, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 обладающий 
\begin_inset Formula $G_{g}$
\end_inset

-представлением 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Standard
Для элементов, не удовлетворяющих критерию Перезаписи 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее представление строится методом, аналогичным Предложению 17 из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 В этом случае также берётся 
\begin_inset Formula $K'=K$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим, что сигнатура 
\begin_inset Formula $\Sig(m_{K}b_{i_{K}})=(s_{0},j_{0})$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 и она перезаписывается отмеченным многочленом 
\begin_inset Formula $b_{i'}$
\end_inset

 из 
\begin_inset Formula $R$
\end_inset

.
 Поскольку представление сигнатурно, мы имеем 
\begin_inset Formula $\Sig(b_{i'})\preccurlyeq_{P}(s_{0},j_{0})\preccurlyeq_{P}\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

.
 Поэтому 
\begin_inset Formula $b_{i'}$
\end_inset

 обрабатывался в процедуре 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 раньше 
\begin_inset Formula $g$
\end_inset

.
 Значит 
\begin_inset Formula $b_{i'}$
\end_inset

 был редуцирован и результат его редукции или был нулевым или присутствует
 в 
\begin_inset Formula $G_{g}$
\end_inset

, поэтому он может использоваться как многочлен элемента 
\begin_inset Formula $G_{g}$
\end_inset

-представления.
 Из критерия Перезаписи известно, что 
\begin_inset Formula $i'>i_{K}$
\end_inset

 и существует 
\begin_inset Formula $s'\in\mathbb{T}$
\end_inset

, такое что 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $s'\Sig(b_{i'})=(s_{0},j_{0})$
\end_inset

.
 Для 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 есть входное представление 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset

 а для 
\begin_inset Formula $s'b_{i'}$
\end_inset

 входным представлением является:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
s'b_{i'}=c's_{0}\cdot f_{j_{0}}+\sum_{l'}m_{l'}\cdot f_{i_{l'}}.
\]

\end_inset

Преобразованием этого выражения получим 
\begin_inset Formula $G_{g}$
\end_inset

-представление для 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{0}s_{0}f_{j_{0}}$
\end_inset

:
\end_layout

\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
c_{0}s_{0}f_{j_{0}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}.
\]

\end_inset

Используя его для замены первого элемента в 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset

 получим желаемый результат:
\begin_inset Formula 
\[
m_{K}b_{i_{K}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}+\sum_{l}m_{l}\cdot f_{i_{l}}
\]

\end_inset

Он 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$
\end_inset

 поскольку элементы обоих сумм имеют сигнатуры, меньшие 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(s_{0},j_{0})$
\end_inset

, а для первого элемента, если 
\begin_inset Formula $b_{i'}$
\end_inset

 не нулевой, имеем 
\begin_inset Formula $\Sig(c'^{-1}c_{0}s'\cdot b_{i'})=\Sig(m_{K}\cdot b_{i_{K}})=(s_{0},j_{0})$
\end_inset

 с 
\begin_inset Formula $i'>i_{K}$
\end_inset

, откуда применяя правило 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-сравнения для равных сигнатур и различных позиций в списке, получаем, что
 элемент 
\begin_inset Formula $c'^{-1}c_{0}s'\cdot b_{i'}$
\end_inset

 также 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

.
 Если же 
\begin_inset Formula $b_{i'}=0$
\end_inset

, то он отбрасывается, и желаемое представление состоит только из оставшихся
 2-х сумм.
\end_layout

\begin_layout Lemma
Если все элементы сигнатурного представления 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 удовлетворяют свойствам 1 и 2, но один из них не удовлетворяет свойству
 3, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

, имеющий представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

.
\end_layout

\begin_layout Proof
Существует по крайней мере один элемент 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

, не удовлетворяющий свойству 3.
 Обозначим за 
\begin_inset Formula $m_{\max}$
\end_inset

 максимальный 
\begin_inset Formula $\HM$
\end_inset

 отмеченных многочленов, соответствующих элементам представления, и за 
\begin_inset Formula $H_{\max}$
\end_inset

 список элементов, на котором 
\begin_inset Formula $m_{\max}$
\end_inset

 достигается.
 Возьмём в качестве 
\begin_inset Formula $K'$
\end_inset

 номер элемента представления, являющегося 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимальным в 
\begin_inset Formula $H_{\max}$
\end_inset

.
 Имеем 
\begin_inset Formula $\HM(m_{K'}b_{i_{K'}})=m_{\max}\succcurlyeq\HM(m_{K}b_{i_{K}})\succ\HM(mh)$
\end_inset

, поэтому 
\begin_inset Formula $\HM$
\end_inset

 суммы всех элементов, кроме 
\begin_inset Formula $K'$
\end_inset

-го равен 
\begin_inset Formula $\HM(mh-m_{K'}b_{i_{K'}})=\HM(m_{K'}b_{i_{K'}})=m_{\max}$
\end_inset

, поэтому существует другой элемент 
\begin_inset Formula $K''$
\end_inset

, обладающий 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(m_{K''}b_{i_{K''}})=m_{\max}$
\end_inset

.
 Отсюда 
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}\in H_{\max}$
\end_inset

 и 
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}\lessdot_{1}m_{K'}\cdot b_{i_{K'}}$
\end_inset

 поскольку 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимален в 
\begin_inset Formula $H_{\max}$
\end_inset

.
\end_layout

\begin_layout Proof
Равенство 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(m_{K''}b_{i_{K''}})=\HM(m_{K'}b_{i_{K'}})$
\end_inset

 означает, что S-пара 
\begin_inset Formula $b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $b_{i_{K''}}$
\end_inset

 имеет вид 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $[m'^{-1}m_{\max},\, m'^{-1}m_{K'},\, b_{i_{K'}},\, m'^{-1}m_{K''},\, b_{i_{K''}}]$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 где 
\begin_inset Formula $m'=\mbox{gcd}(m_{K'},m_{K''})$
\end_inset

.
 Пусть 
\begin_inset Formula $q$
\end_inset

 -- соответствующий S-многочлен.
 Тогда 
\begin_inset Formula $m'\Sig(q)\preccurlyeq_{P}\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 поскольку 
\begin_inset Formula $m'\Sig(q)=\Sig(m_{K'}b_{i_{K'}})$
\end_inset

 и представление сигнатурно.
 Части S-многочлена 
\begin_inset Formula $m'^{-1}m_{K'}b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $m'^{-1}m_{K''}b_{i_{K''}}$
\end_inset

 не удовлетворяют критериям F5 и Перезаписи, поскольку они же, умноженные
 на 
\begin_inset Formula $m'$
\end_inset

 равны 
\begin_inset Formula $m_{K'}b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $m_{K''}b_{i_{K''}}$
\end_inset

 -- отмеченным многочленам, соответствующим элементам, про которые известно,
 что они не удовлетворяют критериям по предположению леммы.
 Из 
\begin_inset Formula $m'\Sig(q)\prec\Sig(g)$
\end_inset

 имеем 
\begin_inset Formula $\Sig(q)\prec\Sig(g)$
\end_inset

, а значит можно применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-gg-repr"

\end_inset

 и получить, что 
\begin_inset Formula $(b_{i_{K'}},b_{i_{K''}})$
\end_inset

 -- S-пара с 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
известным
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $G_{g}$
\end_inset

-представлением, что означает существование представления, описанного в
 примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example-of-having-gg-repr"

\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
q=1\cdot b_{i'}+\sum_{l}m_{l}\cdot b_{i_{l}},
\]

\end_inset

причём выполняются свойства, показанные после примера: 
\begin_inset Formula $\Sig(q)=\Sig(b_{i'})$
\end_inset

, 
\begin_inset Formula $\forall l\,\Sig(q)\succ_{P}\Sig(m_{l}b_{i_{l}})$
\end_inset

 и 
\begin_inset Formula $i'>K'$
\end_inset

.
\end_layout

\begin_layout Proof
С другой стороны по определению S-многочлена мы имеем 
\begin_inset Formula $m'q=c_{0}m_{K'}b_{i_{K'}}-c_{1}m_{K''}b_{i_{K''}}$
\end_inset

, откуда получаем следующее представление:
\begin_inset Formula 
\[
m_{K'}b_{i_{K'}}=c_{0}^{-1}c_{1}m_{K''}\cdot b_{i_{K''}}+c_{0}^{-1}m'\cdot b_{i'}+\sum_{l}c_{0}^{-1}m'm_{l}\cdot b_{i_{l}}.
\]

\end_inset

Оно 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

: 
\end_layout

\begin_layout Proof
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}$
\end_inset

 уже сравнивалось с 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\end_layout

\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $m'\cdot b_{i'}$
\end_inset

 имеет ту же сигнатуру, но больший номер позиции 
\begin_inset Formula $i'>i_{K'}$
\end_inset


\end_layout

\begin_layout Proof
последняя сумма состоит из элементов с сигнатурами, меньшими чем 
\begin_inset Formula $m'\Sig(b_{i'})=\Sig(m_{K'}\cdot b_{i_{K'}})$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-smaller-signature-safe-representation"

\end_inset

Или сигнатурное представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 удовлетворяет свойствам 1-3 или существует другое сигнатурное представление
 
\begin_inset Formula $mh=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
\end_layout

\begin_layout Proof
Теорема немедленно следует из комбинации четырёх предыдущих лемм.
\end_layout

\begin_layout Standard
Это привод нас к следующему ключевому результату:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exists-Gg-repr"

\end_inset

Для любого отмеченного многочлена 
\begin_inset Formula $mh,\, m\in\mathcal{K}\times\mathbb{T},\, h\in G_{g}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 существует удовлетворяющее свойствам 1-3 сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Proof
Начнём с представления 
\begin_inset Formula $mh=m\cdot h$
\end_inset

 и будем заменять текущее представление на 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-smaller-signature-safe-representation"

\end_inset

 до тех пор пока текущее представление не будет удовлетворять свойствам
 1-3.
 Конечность процесса гарантируется вполне упорядоченностью представлений
 по 
\begin_inset Formula $\lessdot$
\end_inset

.
\end_layout

\begin_layout Standard
Этот результат представляет интерес сам по себе, однако для целей доказательства
 остановки нужно лишь одно следствие из него:
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:all-needed-for-terminaton"

\end_inset

Рассмотрим произвольный многочлен 
\begin_inset Formula $f$
\end_inset

 без ограничений на его сигнатуру.
 Если существует сигнатурный редуктор 
\begin_inset Formula $f'\in G_{g}$
\end_inset

 для 
\begin_inset Formula $f$
\end_inset

 с 
\begin_inset Formula $\Sig(f')\frac{\HM(f)}{\HM(f')}\prec_{P}\Sig(g)$
\end_inset

 то 
\begin_inset Formula $G_{g}$
\end_inset

 содержит сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

, который не отбрасывается критериями F5 и перезаписи.
\end_layout

\begin_layout Proof
Пусть 
\begin_inset Formula $mf',\, m=\frac{\HM(f)}{\HM(f')}\in\mathcal{K}\times\mathbb{T},\, f'\in G_{g}$
\end_inset

 умноженный редуктор с 
\begin_inset Formula $\Sig(mf')\prec_{P}\Sig(g)$
\end_inset

.
 Из предыдущей теоремы мы можем найти удовлетворяющее свойствам 1-3 представлени
е 
\begin_inset Formula $mf'=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
 Свойство 3 означает отсутствие элементов с 
\begin_inset Formula $\HM$
\end_inset

, большим чем у 
\begin_inset Formula $mf'$
\end_inset

, откуда, поскольку сумма всех элементов этого представления имеет 
\begin_inset Formula $\HM$
\end_inset

 равный 
\begin_inset Formula $\HM(mf')$
\end_inset

, существует элемент 
\begin_inset Formula $K$
\end_inset

, на котором достигается равенство 
\begin_inset Formula $\HM$
\end_inset

: 
\begin_inset Formula $\HM(m_{K}\cdot b_{i_{K}})=\HM(mf')=\HM(f)$
\end_inset

.
 Поскольку представление сигнатурно, имеем 
\begin_inset Formula $\Sig(m_{K}\cdot b_{i_{K}})\preccurlyeq_{P}\Sig(mf')\prec_{P}\Sig(f)$
\end_inset

, а значит 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 и выполнение свойств 1-2 гарантирует, что 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 не отбрасывается критериями.
\end_layout

\begin_layout Subsubsection
Обнаружение противоречия с учётом критериев
\end_layout

\begin_layout Standard
Теперь мы можем вернуться к результату теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

, утверждающей, что в случае.
 если алгоритм не останавливается, существуют многочлены 
\begin_inset Formula $f',f$
\end_inset

, с индексами в 
\begin_inset Formula $G_{m}$
\end_inset

 такие что 
\begin_inset Formula $\HM(f')|\HM(f)$
\end_inset

, 
\begin_inset Formula $\frac{\HM(f')}{\Sig(f')}\succ_{q}\frac{\HM(f)}{\Sig(f)}$
\end_inset

.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Используя этот результат и последнее следствие мы построим два многочлена,
 приводящие к противоречию в случае отсутствия остановки алгоритма
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:always-exist-ok-reductor"

\end_inset

Если алгоритм не останавливается на некоторых входных данных, то найдётся
 шаг, после которого конечное множество 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G_{m}\cup$
\end_inset

Done
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 содержит пару отмеченных многочленов 
\begin_inset Formula $f'_{1},f$
\end_inset

, для которых выполняется:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $f'_{1}$
\end_inset

 было добавлено в 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G_{m}\cup$
\end_inset

Done
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 до 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{1}f'_{1}$
\end_inset

 не удовлетворяет критериям F5 и Перезаписи, где 
\begin_inset Formula $t_{1}=\frac{\HM(f)}{\HM(f'_{1})}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $f'_{1}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Пусть 
\begin_inset Formula $f',f$
\end_inset

 -- многочлены из теоремы
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 и
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $t=\frac{\HM(f)}{\HM(f')}$
\end_inset

.
 Индекс многочлена 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $f$
\end_inset

 лежит в 
\begin_inset Formula $G$
\end_inset

, поэтому построенная выше теория о представлениях может быть рассмотрена
 применительно к случаю 
\begin_inset Formula $g$
\end_inset

 равного 
\begin_inset Formula $f$
\end_inset

, и можно говорить о множестве 
\begin_inset Formula $G_{f}$
\end_inset

 и 
\begin_inset Formula $G_{f}$
\end_inset

-представлениях.
 Поскольку
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $tf'$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 -- мы имеем 
\begin_inset Formula $\Sig(f')t\prec\Sig(f)$
\end_inset

 и следствие 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:all-needed-for-terminaton"

\end_inset

 может быть применено для нахождения сигнатурного редуктора 
\begin_inset Formula $t_{1}f'_{1}$
\end_inset

 для 
\begin_inset Formula $f$
\end_inset

, который не удовлетворяет критериям.
 Помимо этого известно, что он принадлежит 
\begin_inset Formula $G_{f}$
\end_inset

, поэтому выполняется и первое свойство: в процессе работы алгоритма 
\begin_inset Formula $f'_{1}$
\end_inset

 был добавлен в 
\begin_inset Formula $G_{m}\cup$
\end_inset

Done раньше 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Theorem
Алгоритм F5, описанный в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, останавливается на любых входных данных.
\end_layout

\begin_layout Proof
Покажем, что существование многочленов 
\begin_inset Formula $f'_{1},f$
\end_inset

 из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 приводит к противоречию.
 Рассмотрим вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 после которого многочлен 
\begin_inset Formula $f$
\end_inset

 был добавлен в Done.
 Этот вызов вернул многочлен 
\begin_inset Formula $f$
\end_inset

 как первую половину значения, возвращаемого 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

, что означает что предшествующий вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 вернул пустое множество.
 Это значит, что для каждого многочлена в 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G_{m}\cup$
\end_inset

Done, в том числе
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $f'_{1}$
\end_inset

, хотя бы одно из условий 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-a"

\end_inset

 - 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-d"

\end_inset

 не выполнилось.
 Это невозможно, поскольку:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-a"

\end_inset

удовлетворяется, так как 
\begin_inset Formula $f'_{1}$
\end_inset

 -- редуктор для 
\begin_inset Formula $f$
\end_inset

 по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-b"

\end_inset

и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

 удовлетворяются, поскольку 
\begin_inset Formula $\frac{\HM(f)}{\HM(f'_{1})}f'_{1}$
\end_inset

 не удовлетворяет критериям F5 и Перезаписи по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-d"

\end_inset

удовлетворяется, поскольку 
\begin_inset Formula $f'_{1}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
Упрощение F5
\end_layout

\begin_layout Standard
Приведённая исходная формулировка алгоритма F5 сильно разнесена по процедурам,
 что приводит к довольно сложному порядку обработки S-пар, описанному в
 доказательстве остановки.
 Для построения более простого аналога будем действовать следующим образом:
 сформулируем некоторые свойства, которыми обладает алгоритм F5, и попытаемся
 построить наиболее простой алгоритм, обладающий этими же свойствами.
 Такой подход не позволяет сделать заключение ни о корректности построенного
 алгоритма, ни об его эквивалентности F5, поэтому его корректность будет
 доказана отдельно.
\end_layout

\begin_layout Standard
Определим, какими свойствами должна обладать старшая часть S-пары, чтоб
 быть рассмотренной в алгоритме.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:high-sp-part"

\end_inset

Если 
\begin_inset Formula $\sigma$
\end_inset

 -- сигнатура старшей части некоторой S-пары, она не отбрасывается в F5
 тогда и только тогда, когда не удовлетворяет критерию F5 и образована многочлен
ом максимальным по индексу в 
\begin_inset Formula $R$
\end_inset

 из множества многочленов с 
\begin_inset Formula $\Sig(R[r])|\sigma$
\end_inset

, взятого на момент обработки S-многочлена сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
Проверки в процедурах 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:CritPair"

\end_inset

 и 
\begin_inset Formula $ $
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "par:Spol"

\end_inset

 приводят к тому что рассматриваются S-пары, со старшей частью, не отбрасываемой
 критериями F5 и перезаписи.
 Если S-пара отбрасывается критерием F5, то все S-пары будут им отбрасываться,
 поскольку известно, что многочлен такой сигнатуры имеет сигнатурное представлен
ие, в котором все элементы имеют меньшую сигнатуру, и поэтому редуцируется
 к нулю относительно текущего множества 
\begin_inset Formula $G\cup$
\end_inset

Done.
 Если же часть S-пары 
\begin_inset Formula $u\cdot R[r]$
\end_inset

 отбрасывается критерием перезаписи, то существует элемент 
\begin_inset Formula $r'>r,\Sig(R[r'])|u\Sig(R[r])$
\end_inset

.
 То есть по сигнатуре 
\begin_inset Formula $\sigma$
\end_inset

 и множеству 
\begin_inset Formula $R$
\end_inset

 на момент обработки S-многочлена сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

, можно определить единственно возможную не перезаписываемую часть S-пары
 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

, что доказывает утверждение.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:low-sp-part"

\end_inset

Если старшая часть 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

 некоторой S-пары, появляющейся в алгоритме F5, не отбрасывается, то будет
 редуцирована ровно одна S-пара с такой старшей частью, при этом младшая
 часть будет образована многочленом 
\begin_inset Formula $R[r_{3}]$
\end_inset

 из множества 
\begin_inset Formula $R$
\end_inset

 на момент обработки S-многочлена сигнатуры 
\begin_inset Formula $\Sig\left(u_{1}\cdot R[r_{1}]\right)$
\end_inset

, таким что 
\begin_inset Formula $\Sig(u_{3}\cdot R[r_{3}])\preccurlyeq_{P}\Sig(u_{*}\cdot R[r_{*}])$
\end_inset

 для всех 
\begin_inset Formula $u_{*},r_{*}$
\end_inset

, удовлетворяющих 
\begin_inset Formula $\HM(u_{*}\cdot R[r_{*}])=\HM(u_{1}\cdot R[r_{1}])$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим что в алгоритме обрабатываются две пары с различными младшими
 частями 
\begin_inset Formula $(u_{1}\cdot R[r_{1}],u'_{2}\cdot R[r'_{2}])$
\end_inset

 и 
\begin_inset Formula $(u_{1}\cdot R[r_{1}],u''_{2}\cdot R[r''_{2}])$
\end_inset

.
 Тогда S-пара 
\begin_inset Formula $R[r'_{2}]$
\end_inset

 и 
\begin_inset Formula $R[r''_{2}]$
\end_inset

 имеет вид 
\begin_inset Formula $(\frac{u'_{2}}{v}\cdot R[r'_{2}],\frac{u''_{2}}{v}\cdot R[r''_{2}])$
\end_inset

, 
\begin_inset Formula $ $
\end_inset

была рассмотрена и отброшена или редуцирована.
 Если она была отброшена критериями, то они же отбросят 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 или 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

.
 Если она была редуцирована, то результат редукции будет иметь сигнатуру,
 перезаписывающую 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 или 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

.
 В обоих случаях одна из младших частей будет отброшена, что показывает
 единственность не отбрасываемой S-пары со старшей частью 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

.
\end_layout

\begin_layout Proof
Для доказательства существования рассмотрим обрабатываемую в алгоритме S-пару
 с сокращаемым мономом 
\begin_inset Formula $t$
\end_inset

, младшей частью 
\begin_inset Formula $u_{2}\cdot R[r_{2}]$
\end_inset

 и не отброшенной старшей частью 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

.
 Поскольку сигнатура 
\begin_inset Formula $u_{2}\cdot R[r_{2}]$
\end_inset

 меньше текущей обрабатываемой, к 
\begin_inset Formula $u_{2}\cdot R[r_{2}]$
\end_inset

 можно применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exists-Gg-repr"

\end_inset

 и выбрать из этого представления по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset

 элемент 
\begin_inset Formula $u_{3}\cdot R[r_{3}]$
\end_inset

 с 
\begin_inset Formula $\Sig(u_{3}\cdot R[r_{3}])\preccurlyeq_{P}\Sig(u_{2}\cdot R[r_{2}])$
\end_inset

 и 
\begin_inset Formula $\HM(u_{3}\cdot R[r_{3}])=\HM(u_{2}\cdot R[r_{2}])$
\end_inset

, проходящий критерии.
 При этом может оказаться, что 
\begin_inset Formula $r_{3}=r_{2}.$
\end_inset


\end_layout

\begin_layout Proof
Сокращаемый моном 
\begin_inset Formula $t'$
\end_inset

 S-пары многочленов 
\begin_inset Formula $R[r_{1}]$
\end_inset

 и 
\begin_inset Formula $R[r_{3}]$
\end_inset

 делит 
\begin_inset Formula $t$
\end_inset

.
 Предположим, что он имеет меньшую полную степень -- в этом случае соответствующ
ая S-пара была бы уже рассмотрена.
 Она не была бы отброшена, поскольку дополнительно домноженные на 
\begin_inset Formula $\frac{t}{t'}$
\end_inset

 её части имеют вид 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

 и 
\begin_inset Formula $u_{3}\cdot R[r_{3}]$
\end_inset

 проходят критерии.
 В силу этого она была бы редуцирована, дав в результате многочлен сигнатуры
 делящей 
\begin_inset Formula $\Sig\left(u_{1}\cdot R[r_{1}]\right)$
\end_inset

, который привёл бы к отбрасыванию 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

 по критерию перезаписи, что невозможно.
 Поэтому 
\begin_inset Formula $t'=t$
\end_inset

, что доказывает существование не отбрасываемой алгоритмом S-пары 
\begin_inset Formula $(u_{1}\cdot R[r_{1}],u_{3}\cdot R[r_{3}])$
\end_inset

, а из свойства 
\begin_inset Formula $\Sig(u_{3}\cdot R[r_{3}])\preccurlyeq_{P}\Sig(u_{2}\cdot R[r_{2}])$
\end_inset

 вытекает утверждаемая теоремой минимальность сигнатуры.
\end_layout

\begin_layout Standard
Из доказанных теорем вытекает следующее заключение, описывающее работу алгоритма
 с S-парами.
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "clm:how-sigs"

\end_inset

По любой сигнатуре 
\begin_inset Formula $\sigma$
\end_inset

 и множеству 
\begin_inset Formula $R$
\end_inset

 можно единственным образом определить потенциально проходящую критерии
 S-пару сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
 Старшая часть S-пары определяется по сигнатуре согласно теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:high-sp-part"

\end_inset

, откуда по сокращаемому моному можно однозначно определить младшую часть
 S-пары по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:low-sp-part"

\end_inset

.
 При этом если алгоритм F5 хотя бы один раз создал S-пару с подходящей старшей
 частью для сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

 -- то для этой сигнатуры существует проходящая критерии S-пара и алгоритм
 будет проводить редукцию этой S-пары.
 Описанные S-пары покрывают все S-пары, редуцируемые алгоритмом.
\end_layout

\begin_layout Standard
Теперь рассмотрим работу алгоритма при редукции.
 При выборе редуктора процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 может вернуть как многочлен, выступающий в роли редуктора, так и многочлен
 большей сигнатуры, используемый при создании S-пары.
 Покажем, что порядок обхода множества 
\begin_inset Formula $G$
\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 не играет роли.
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "clm:how-reds"

\end_inset

К моменту вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 не более чем один многочлен из 
\begin_inset Formula $R$
\end_inset

 может быть сигнатурным редуктором, удовлетворяющего критериям.
 При этом, если множество сигнатурных редукторов непусто, удовлетворять
 критериям будет многочлен с наименьшей домноженной сигнатурой.
\end_layout

\begin_layout Proof
Предположим наличие двух потенциальных редукторов, записываемых в домноженном
 виде как 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 и 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

.
 У них равные 
\begin_inset Formula $\HM$
\end_inset

 и сигнатуры, меньшие текущей рассматриваемой, поэтому можно рассмотреть
 их S-пару и поступая аналогично доказательству единственности в теореме
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:low-sp-part"

\end_inset

 получить, что один из них не проходит критерии.
 Единственность доказана.
\end_layout

\begin_layout Proof
Второе утверждение немедленно вытекает из теорем 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exists-Gg-repr"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset


\end_layout

\begin_layout Standard
Таким образом получается, что правило выбора проходящего критерии редуктора
 идентично правилу выбора подходящей критерии младшей части S-пары.
\end_layout

\begin_layout Standard
Одной из особенностей исходного алгоритма F5, отличающей его от большинства
 порождённых на его основе является генерация S-пар одновременно с процессом
 редукции в случае, если 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 вернула редуктор, не являющийся сигнатурным редуктором.
 Оказывается, что этого можно не делать: если при поиске редукторов для
 многочлена 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $R[r{}_{1}]$
\end_inset

 в множестве 
\begin_inset Formula $G$
\end_inset

 одновременно присутствуют сигнатурный редуктор 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 и редуктор 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

, не являющийся сигнатурным, то добавление S-пары 
\begin_inset Formula $R[r{}_{2}'']$
\end_inset

 и 
\begin_inset Formula $R[r{}_{1}]$
\end_inset

 является излишним, поскольку её младшая часть 
\begin_inset Formula $R[r{}_{1}]$
\end_inset

 имеет большую сигнатуру, чем имеющий тот же старший моном домноженный многочлен
 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

, а значит добавленной ранее S-пары 
\begin_inset Formula $R[r{}_{2}'']$
\end_inset

 и 
\begin_inset Formula $R[r'_{2}]$
\end_inset

 достаточно.
 Более строгое доказательство этого факта дано в Предложении 6 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

.Добавление S-пар после того как сигнатурные редукции закончились остаётся
 необходимым.
\end_layout

\begin_layout Standard
Перечисленные утверждения позволяют предположить что упрощённая версия F5
 может быть сформулирована в следующем виде:
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:SimplifiedF5"

\end_inset

SimplifiedF5
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $((1,i),f_{i})$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $G_{i-1}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера некоторого идеала 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $P$
\end_inset

 -- упорядоченный список старших частей S-пар отмеченных многочленов, 
\begin_inset Formula $p$
\end_inset

 -- некоторая старшая часть S-пары, 
\begin_inset Formula $h\in H$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $r$
\end_inset

 -- индекс элементов в 
\begin_inset Formula $R$
\end_inset

, используемый при итерировании
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default

\begin_inset Formula $G_{i}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера идеала 
\begin_inset Formula $\left(\left\{ poly(R[r])|r\in G_{i-1}\right\} \cup f_{i}\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}=G_{i-1}\cup\left\{ i\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow$
\end_inset


\shape default
 Отсортированные по сигнатуре старшие части S-пар, образуемых 
\family typewriter
{
\family sans

\begin_inset Formula $(R[i],R[r])|r\in G_{i-1}$
\end_inset

}
\end_layout

\begin_layout Enumerate

\family sans
\series bold
while 
\series default

\begin_inset Formula $P\ne\varnothing$
\end_inset

 
\series bold
do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $p\leftarrow P[1]$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\setminus\left\{ p\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if 
\begin_inset Formula $p$
\end_inset

 
\family sans
\series default
является подходящей старшей частью S-пары для своей сигнатуры в терминах
 утверждения 
\begin_inset CommandInset ref
LatexCommand ref
reference "clm:how-sigs"

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $h\leftarrow$
\end_inset

 
\family sans
многочлен, получаемый перемножением 
\family default

\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $h\leftarrow$
\end_inset

 
\family sans
пока в 
\begin_inset Formula $G$
\end_inset

 есть сигнатурные редукторы для 
\family default

\begin_inset Formula $h$
\end_inset


\family sans
, редуцировать его относительно сигнатурного редуктора наименьшей домноженной
 степени в терминах утверждения 
\begin_inset CommandInset ref
LatexCommand ref
reference "clm:how-reds"

\end_inset


\end_layout

\begin_layout Enumerate
Добавить 
\begin_inset Formula $h$
\end_inset

 в конец 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\cup$
\end_inset


\shape default
 старшие части S-пар, образуемых 
\family typewriter
{
\family sans

\begin_inset Formula $(R[\#R],R[r])|r\in G_{i}$
\end_inset

}
\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}\leftarrow G_{i}\cup\left\{ \#R\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
Отсортировать 
\begin_inset Formula $P$
\end_inset

 по возрастанию сокращаемого монома 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $G_{i}$
\end_inset


\end_layout

\begin_layout Standard
Данный алгоритм не совсем эквивалентен F5, поскольку может иметь отличный
 от него порядок добавления элементов в 
\begin_inset Formula $R$
\end_inset

, что влияет на работу правил перезаписи, выражаемых в этом алгоритме в
 правиле проверки старшей части S-пары.
 
\end_layout

\begin_layout Standard
Мы также оставляем открытым вопрос корректности этого алгоритма, рассматривая
 в следующем разделе вместо него другой алгоритм, в котором правило проверки
 старшей части S-пары сформулировано в терминах старших мономов и сигнатур
 и не использует порядок добавления.
 Сравнение этих двух правил описано в главе 7 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

, однако не является необходимым для формулировки доказательства нижеследующего
 алгоритма.
\end_layout

\begin_layout Section
Простой алгоритм, основанный на сигнатурах
\end_layout

\begin_layout Standard
Предлагаемый ниже алгоритм формулируется в виде шага инкрементального алгоритма
 вычисления базиса Грёбнера.
 Поскольку случаи 
\begin_inset Formula $f=0\Rightarrow\left(G\cup f\right)=\left(G\right)$
\end_inset

 и 
\begin_inset Formula $\exists k\ne0\, k\in\mathcal{K}\cap G\Rightarrow\left(G\right)=\left(G\cup f\right)=\mathcal{P}=\left(1\right)$
\end_inset

 не представляют вычислительной сложности, далее предполагается что 
\begin_inset Formula $f\neq0$
\end_inset

 и 
\begin_inset Formula $G=\left\{ g_{1},\dots,g_{m}\right\} ,g_{i}\notin\mathcal{K}$
\end_inset

.
 Заметим, что в отличии от исходного алгоритма F5, однородность входных
 многочленов не требуется.
\end_layout

\begin_layout Subsection
Определения
\end_layout

\begin_layout Standard
Множество сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 для одноэтапного случая может быть расширено нулём по аналогии с 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

: 
\begin_inset Formula $\mathbf{T}_{0}\eqdef\mathbf{T}\cup\{0\}$
\end_inset

.
 При этом заданный на 
\begin_inset Formula $\mathbf{T}$
\end_inset

 порядок расширяется с сохранением линейно-упорядоченности так, что ноль
 оказывается наименьшим элементом.
\end_layout

\begin_layout Standard
Введём несколько определений, применимых для понятия сигнатуры из множества
 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $\tau_{0}$
\end_inset

, соответствующего 
\begin_inset Formula $\mathbf{T}_{0}$
\end_inset

 или 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

, и линейного порядка 
\begin_inset Formula $\prec_{\tau0}$
\end_inset

 на нём.
 В этом множестве определено умножение на ненулевые мономы 
\begin_inset Formula $\mathbb{T}$
\end_inset

, сохраняющее порядок, а также умножение на элементы 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

, не сохраняющее порядок.
\end_layout

\begin_layout Standard
Ключевым понятием для данного алгоритма является порядок на отмеченных многочлен
ах, определяемый по аналогии с порядками 
\begin_inset Formula $\prec_{p}$
\end_inset

 из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 и 
\begin_inset Formula $\prec_{l}$
\end_inset

 из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

:
\end_layout

\begin_layout Definition
Зададим частичный порядок 
\begin_inset Formula $\GVWl$
\end_inset

 на множестве отмеченных многочленов 
\begin_inset Formula $H$
\end_inset

: 
\begin_inset Formula 
\[
h_{1}=(\sigma_{1},p_{1})\GVWl h_{2}=(\sigma_{2},p_{2})\equivdef\HM(p_{1})\sigma_{2}\prec_{\tau0}\HM(p_{2})\sigma_{1},
\]

\end_inset


\end_layout

\begin_layout Definition
где последнее неравенство рассматривается в 
\begin_inset Formula $\tau_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Для неравных элементов 
\begin_inset Formula $(\sigma_{1},p_{1})\ne(\sigma_{2},p_{2})$
\end_inset

 выполняется ровно одно из отношений 
\begin_inset Formula $<_{H},>_{H}$
\end_inset

 во всех случаях кроме следующих:
\end_layout

\begin_layout Itemize
Один из них равен 
\begin_inset Formula $(0,0)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $p_{1}=p_{2}=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma_{1}=\sigma_{2}=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $(\sigma_{1},p_{1})=(t\sigma_{2},tp_{2})$
\end_inset


\end_layout

\begin_layout Standard
В указанных случаях элементы несравнимы.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "remark:follows-from-lessH"

\end_inset

Из определения следует, что 
\begin_inset Formula $(\sigma_{1},p_{1})<_{H}(\sigma_{2},p_{2})$
\end_inset

 возможно только тогда, когда 
\begin_inset Formula $0\ne\HM(p_{2})\sigma_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
Согласно этому определению элементы с нулевым старшим мономом оказываются
 нестрогими экстремумами:
\begin_inset Formula 
\[
\forall\sigma_{1},\sigma_{2},p_{2}\,\left(\sigma_{1},0\right)\not\GVWg\left(\sigma_{2},p_{2}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Для случая инкрементального алгоритма с порядком 
\begin_inset Formula $\prec_{0}$
\end_inset

 элементы с нулевой сигнатурой -- также нестрогие экстремумы:
\begin_inset Formula 
\[
\forall\sigma_{2},p_{1},p_{2}\in\mathbb{T}_{0}\,\left(0,p_{1}\right)\not\GVWl\left(\sigma_{2},p_{2}\right).
\]

\end_inset


\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset

.
 Тогда 
\begin_inset Formula $h_{1}\GVWg h_{2}\Leftrightarrow h_{1}\GVWg th_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Выводится из того, что умножение на 
\begin_inset Formula $t$
\end_inset

 одного из сравниваемых отмеченных многочленов приводит к умножению на 
\begin_inset Formula $t$
\end_inset

 обоих частей в определении 
\begin_inset Formula $\GVWg$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,\HM(h_{1})|\HM(h_{2}),\HM(h_{2})\neq0$
\end_inset

.
 Тогда сигнатурная редукция 
\begin_inset Formula $h_{2}$
\end_inset

 по 
\begin_inset Formula $h_{1}$
\end_inset

 возможна если и только если 
\begin_inset Formula $h_{1}\GVWg h_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Следует из того что оба утверждения равносильны неравенству 
\begin_inset Formula $\Sig(h_{2})\succ_{\tau}\Sig(h_{1})\frac{\HM(h_{2})}{\HM(h_{1})}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее определение эквивалентно определению согласованности порядков
 из 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

:
\end_layout

\begin_layout Definition
Порядок на сигнатурах 
\begin_inset Formula $\prec_{\tau}$
\end_inset

 называется 
\emph on
согласованным с порядком на мономах
\emph default
 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall t_{1},t_{2}\in\mathbb{T},\sigma\in\tau\, t_{1}\prec t_{2}\Longleftrightarrow t_{1}\sigma\prec_{\tau}t_{2}\sigma$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:precP_compatible"

\end_inset

Порядок 
\begin_inset Formula $\prec_{P}$
\end_inset

 согласован с порядком 
\begin_inset Formula $\prec$
\end_inset

.
\end_layout

\begin_layout Proof
Пусть 
\begin_inset Formula $\sigma=(s,i)\in\mathbf{T}$
\end_inset

.
 Тогда
\begin_inset Formula 
\[
t_{1}\sigma\prec_{P}t_{2}\sigma\Longleftrightarrow\left(t_{1}s,i\right)\prec_{P}\left(t_{2}s,i\right)\Longleftrightarrow t_{1}s\prec t_{2}s\Longleftrightarrow t_{1}\prec t_{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Все конкретные порядки на сигнатурах, рассматриваемые в данной работе являются
 согласованными с порядком на мономах.
 Поэтому во всех последующих утверждениях на порядок 
\begin_inset Formula $\prec_{\tau}$
\end_inset

 накладывается требование согласованности.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1}\in H$
\end_inset

 -- результат сигнатурной редукции 
\begin_inset Formula $h_{1}'$
\end_inset

 по некоторому многочлену.
 Тогда 
\begin_inset Formula $h_{1}\GVWl h_{1}'$
\end_inset

.
\end_layout

\begin_layout Proof
Следует из 
\begin_inset Formula $\Sig(h_{1})=\Sig(h_{1}')$
\end_inset

 и уменьшения 
\begin_inset Formula $\HM$
\end_inset

 при редукции: 
\begin_inset Formula $\HM(h_{1})\prec_{0}\HM(h_{1}').$
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:greater-or-smaller"

\end_inset

Пусть 
\begin_inset Formula $h_{1}\GVWl h_{2}$
\end_inset

 отмеченные многочлены.
 Тогда 
\begin_inset Formula $\forall h_{3}\in H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

 выполняется хотя бы одно из двух неравенств: 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

 или 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Из условия леммы известно, что
\begin_inset Formula 
\begin{equation}
\HM(h_{1})\Sig(h_{2})\prec_{\tau}\HM(h_{2})\Sig(h_{1})\label{eq:gvw-order-3}
\end{equation}

\end_inset

откуда по замечанию 
\begin_inset CommandInset ref
LatexCommand ref
reference "remark:follows-from-lessH"

\end_inset

 
\begin_inset Formula $\HM(h_{2})\neq0,\Sig(h_{1})\neq0$
\end_inset

.
 Поэтому, если 
\begin_inset Formula $\HM(h_{3})=0$
\end_inset

, имеем 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

, а если 
\begin_inset Formula $\Sig(h_{3})=0$
\end_inset

 -- то 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

.
 Иначе можно домножить неравенство 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:gvw-order-3"

\end_inset

 на ненулевой элемент 
\begin_inset Formula $\HM(h_{3})\Sig(h_{3})$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
\HM(h_{3})\Sig(h_{3})\HM(h_{1})\Sig(h_{2})\prec_{\tau0}\HM(h_{3})\Sig(h_{3})\HM(h_{2})\Sig(h_{1}).\label{eq:left-or-right-monom}
\end{equation}

\end_inset

Поскольку 
\begin_inset Formula $\succ_{\tau0}$
\end_inset

 -- линейный порядок, 
\begin_inset Formula $\HM(h_{3})^{2}\Sig(h_{2})\Sig(h_{1})\in\mathbb{T}_{0}$
\end_inset

 будет или 
\begin_inset Formula $\succ_{\tau0}$
\end_inset

 левой или 
\begin_inset Formula $\prec_{\tau0}$
\end_inset

 правой части неравенства 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:left-or-right-monom"

\end_inset

, и после сокращения даст эквивалентное утверждению леммы неравенство.
\end_layout

\begin_layout Subsection
Алгоритм
\end_layout

\begin_layout Standard
Сформулируем шаг инкрементального алгоритма базиса Грёбнера, подразумевая
 под 
\begin_inset Formula $<_{H}$
\end_inset

 отношение отмеченных многочленов, индуцированное порядком 
\begin_inset Formula $\prec_{0}$
\end_inset

 на сигнатурах 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:SimpleSignatureGroebner"

\end_inset


\family typewriter
SimpleSignatureGroebner
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход: многочлены 
\begin_inset Formula $\{g_{1},\dots,g_{m}\}$
\end_inset

, образующие базис Грёбнера, многочлен 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 -- подмножества 
\begin_inset Formula $H$
\end_inset

, 
\begin_inset Formula $(\sigma,p')\in H$
\end_inset

 -- отмеченный многочлен текущего шага до редукции, 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- он же после редукции, 
\begin_inset Formula $r,b$
\end_inset

 -- элементы 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(g_{1},\dots,g_{m},f\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\{\left(\HM(g_{1}),0\right),\left(\HM(g_{2}),0\right),\dots,\left(\HM(g_{m}),0\right),(0,g_{1}),(0,g_{2}),\dots,(0,g_{m})\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\sigma,p')\leftarrow(1,f)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do forever:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-before-reduce"

\end_inset


\begin_inset Formula $p\leftarrow$
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

((
\begin_inset Formula $\sigma,p'),R$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-after-reduce"

\end_inset


\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-from-B"

\end_inset


\begin_inset Formula $B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\Sig(r)|\Sig(b)\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if 
\begin_inset Formula $B\neq\varnothing$
\end_inset

: 
\series default

\begin_inset Formula $(\sigma,p')\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec_{0}$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate

\series bold
else: break
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)\,|\, r\in R,\poly(r)\ne0\}$
\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:ReduceCheckingSignatures"

\end_inset


\family typewriter
\series medium
ReduceCheckingSignatures
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход: 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $R$
\end_inset

 -- подмножество 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $r$
\end_inset

 -- элемент 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат: 
\begin_inset Formula $p$
\end_inset

 -- многочлен, сигнатурно редуцированный по 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $\exists r\in R\, r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 сигнатурно редуцировать 
\begin_inset Formula $p$
\end_inset

 по 
\begin_inset Formula $\GVWg$
\end_inset

-максимальному элементу 
\begin_inset Formula $r$
\end_inset

 среди указанных в условии цикла
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Lemma
Все пары из 
\begin_inset Formula $\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

 в алгоритме -- элементы 
\begin_inset Formula $H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Proof
Элементы, формируемые до начала главного цикла, являются рассмотренными
 в примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:labeled-polys"

\end_inset

 отмеченными многочленами.
 Все остальные отмеченные многочлены в алгоритме формируются или умножением
 на 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

 или редукцией с сохранением сигнатуры, поэтому они корректны и лежат в
 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Условия циклов, расширяющих 
\begin_inset Formula $B$
\end_inset

, таковы, что в
\series bold
 
\series default

\begin_inset Formula $B$
\end_inset

 нет ни нулевых сигнатур, ни нулевых старших мономов.
 Поэтому 
\begin_inset Formula $\sigma$
\end_inset

 никогда не обращается в 0 и нулевые сигнатуры в 
\begin_inset Formula $R$
\end_inset

 лишь у элементов 
\begin_inset Formula $(0,g_{1}),...,(0,g_{m}).$
\end_inset

 Нулевой старший моном может быть у любого многочлена, добавляемого в 
\begin_inset Formula $R$
\end_inset

, а нулевых многочленов с одновременно нулевой сигнатурой в 
\begin_inset Formula $R$
\end_inset

 нет.
\end_layout

\begin_layout Subsection
Остановка алгоритма
\end_layout

\begin_layout Standard
Дадим теоретическое обоснование представленного алгоритма.
 Для этого покажем его остановку и корректность результата.
 Данные результаты показаны без использования фактов, полученных ранее при
 доказательстве остановки F5, поскольку приведённый алгоритм позволяет дать
 значительно более простое обоснование без ссылок на них.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:exist-reductor"

\end_inset

В любой момент работы алгоритма любой отмеченный многочлен из 
\begin_inset Formula $B$
\end_inset

 может быть редуцирован с сохранением сигнатуры по некоторому элементу 
\begin_inset Formula $R.$
\end_inset


\end_layout

\begin_layout Proof
Отмеченные многочлены добавляются в 
\begin_inset Formula $B$
\end_inset

 таким образом, чтобы иметь хотя бы один подходящий редуктор.
 
\begin_inset Formula $(\sigma,p)\in R$
\end_inset

 является таким редуктором при добавлении в первом цикле 
\series bold
for
\series default
, 
\begin_inset Formula $r\in R$
\end_inset

 -- во втором.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-small"

\end_inset

До редукции многочлена 
\begin_inset Formula $p'$
\end_inset

, то есть на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-before-reduce"

\end_inset

 любой итерации алгоритма, сигнатуры элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $
\end_inset

 не делят 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
На первой итерации алгоритма это выполняется, поскольку 
\begin_inset Formula $\sigma=1$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

 не содержит элементы с сигнатурами, делящими 1.
 На последующих итерациях это выполнено, поскольку если бы в 
\begin_inset Formula $R$
\end_inset

 существовали такие элементы, то 
\begin_inset Formula $\left(\sigma,p'\right)$
\end_inset

 был бы убран из 
\begin_inset Formula $B$
\end_inset

 в предыдущей итерации на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-big"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, старшие мономы элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $
\end_inset

 не делят 
\begin_inset Formula $\HM(p)$
\end_inset

.
\end_layout

\begin_layout Proof
Вытекает из того, что цикл в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 останавливается по достижении 
\begin_inset Formula $p$
\end_inset

, для которого такие элементы в 
\begin_inset Formula $R$
\end_inset

 не существуют.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:adds-really-new"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, элементы 
\begin_inset Formula $R$
\end_inset

 не могут одновременно иметь старшие мономы, делящие 
\begin_inset Formula $\HM(p)$
\end_inset

, и сигнатуры, делящие 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor"

\end_inset

 будет произведена хотя бы одна редукция 
\begin_inset Formula $p'$
\end_inset

, поэтому 
\begin_inset Formula $(\sigma,p')\GVWg(\sigma,p)$
\end_inset

.
 Отсюда по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:greater-or-smaller"

\end_inset

 для 
\begin_inset Formula $\forall r\in R$
\end_inset

 имеем 
\begin_inset Formula $r\GVWg(\sigma,p)$
\end_inset

 или 
\begin_inset Formula $r\GVWl(\sigma,p')$
\end_inset

.
 Выполнение одного из неравенств позволяет применить одну из лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-small"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:SSG-stop"

\end_inset

Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 останавливается
\end_layout

\begin_layout Proof
Для доказательства остановки нужно показать, что все циклы 
\series bold
do
\series default
 выполняются лишь конечное число раз.
 В 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 при ненулевых 
\begin_inset Formula $p$
\end_inset

 на каждой итерации 
\begin_inset Formula $\HM(p)$
\end_inset

 уменьшается по 
\begin_inset Formula $\prec_{0}$
\end_inset

, что возможно лишь конечное число раз.
 При обнулении 
\begin_inset Formula $p$
\end_inset

 он завершится в силу 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $(\sigma,0)$
\end_inset

.
\end_layout

\begin_layout Proof
На каждом шаге основного цикла пополняется множество 
\begin_inset Formula $R\subset\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

.
 Оно может быть разбито как 
\begin_inset Formula $R_{*0}\cup R_{0*}\cup R_{**},$
\end_inset

 где 
\begin_inset Formula $R_{*0}\subset\mathbb{T}\times\left\{ 0\right\} ,R_{0*}\subset\left\{ 0\right\} \times\mathcal{P}\setminus\left\{ 0\right\} ,R_{**}\subset\mathbb{T}\times\mathcal{P}\setminus\left\{ 0\right\} $
\end_inset

.
 
\begin_inset Formula $R_{0*}$
\end_inset

 не пополняется в силу 
\begin_inset Formula $\sigma\neq0$
\end_inset

.
 Для 
\begin_inset Formula $R_{*0}$
\end_inset

 и 
\begin_inset Formula $R_{**}$
\end_inset

 применим подход, основанный на понятии идеалов моноидов, предложенном в
 
\begin_inset CommandInset citation
LatexCommand cite
key "KreuzerRobbianoBook1"

\end_inset

 как ``monoid ideal''.
 Рассмотрим следующие множества, являющиеся идеалами моноидов: 
\begin_inset Formula $L_{*0}=\left(\left\{ \sigma\,|\,(\sigma,0)\in R_{*0}\right\} \right)\subset\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $L_{**}=\left(\left\{ (\sigma,t)\,|\,\exists(\sigma,p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$
\end_inset

.
 В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new"

\end_inset

 добавляемые в 
\begin_inset Formula $R$
\end_inset

 элементы расширяют на каждом шаге 
\begin_inset Formula $L_{*0}$
\end_inset

 или 
\begin_inset Formula $L_{**}$
\end_inset

.
 Поскольку моноиды 
\begin_inset Formula $\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\mathbb{T}\times\mathbb{T}$
\end_inset

 изоморфны 
\begin_inset Formula $\mathbb{N}^{n}$
\end_inset

 и 
\begin_inset Formula $\mathbb{N}^{2n}$
\end_inset

, к их идеалам может быть применена лемма Диксона, которая и утверждает,
 что расширение может происходить лишь конечное число раз.
\end_layout

\begin_layout Subsection
Корректность результата
\end_layout

\begin_layout Standard
Следующее определение расширяет понятие S-базиса из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

:
\end_layout

\begin_layout Definition
Назовём 
\begin_inset Formula $R\subset H$
\end_inset


\emph on
 S-базисом
\emph default
 (соответственно 
\emph on
S
\begin_inset Formula $_{\sigma}$
\end_inset

-базисом
\emph default
) идеала отмеченных многочленов 
\begin_inset Formula $I\subset H$
\end_inset

, если все элементы 
\begin_inset Formula $I$
\end_inset

 (соответственно 
\begin_inset Formula $\left\{ h\in I\,|\,\Sig(h)\prec_{0}\sigma\right\} $
\end_inset

)
\emph on
 
\emph default
имеют сигнатурное представление
\emph on
 
\emph default
над 
\begin_inset Formula $R$
\end_inset


\emph on
.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:s-basis-and-no-reductions"

\end_inset

Пусть 
\begin_inset Formula $\sigma\succ_{0}0,R=\left\{ r_{i}\right\} $
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис и выбраны 
\begin_inset Formula $h_{1},h_{2}\in H,\Sig(h_{i})=\sigma$
\end_inset

, которые нельзя сигнатурно редуцировать по 
\begin_inset Formula $R$
\end_inset

.
 Тогда 
\begin_inset Formula $\HM(h_{1})=\HM(h_{2})$
\end_inset

 и у 
\begin_inset Formula $h_{1}$
\end_inset

 есть сигнатурное представление над 
\begin_inset Formula $R\cup\left\{ h_{2}\right\} $
\end_inset

.
\end_layout

\begin_layout Proof
Из определения 
\begin_inset Formula $H$
\end_inset

 имеем 
\begin_inset Formula $\exists u_{i}\in\mathcal{P}\,\HM(u_{i})=\sigma,u_{i}f\equiv\poly(h_{i})\pmod{\left(G\right)},i=1,2.$
\end_inset

 Значит некоторой линейной комбинации 
\begin_inset Formula $\poly(h_{i})$
\end_inset

 сопоставляется 
\begin_inset Formula $\prec_{0}\sigma$
\end_inset

 сигнатура: 
\begin_inset Formula 
\[
\exists K\in\mathcal{K},v\in\mathcal{P}\,\HM(v)=\sigma'\prec_{0}\sigma,vf\equiv\poly(h_{1})-K\poly(h_{2})\pmod{\left(G\right)},
\]

\end_inset

то есть 
\begin_inset Formula $\left(\sigma',p'\right)=\left(\sigma',\poly(h_{1})-K\poly(h_{2})\right)\in H$
\end_inset

.
 Из определения S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базиса и 
\begin_inset Formula $\sigma'\prec_{0}\sigma$
\end_inset

 вытекает 
\begin_inset Formula $\exists r_{j}\in R,t\in\mathbb{T}\,\Sig(tr_{j})\preccurlyeq_{0}\sigma',\HM(tr_{j})=\HM(p')$
\end_inset

.
 Отсюда 
\begin_inset Formula $\HM(h_{i})\neq\HM(p'),i=1,2$
\end_inset

, иначе 
\begin_inset Formula $r_{j}$
\end_inset

 редуцировало бы 
\begin_inset Formula $h_{i}$
\end_inset

 сигнатурно.
 Значит, 
\begin_inset Formula $\HM(h_{i})$
\end_inset

 сокращаются при вычитании с 
\begin_inset Formula $\mathcal{K}$
\end_inset

-коэффициентом, что даёт 
\begin_inset Formula $\HM(h_{1})=\HM(h_{2})$
\end_inset

.
 Сигнатурное представление 
\begin_inset Formula $h_{1}$
\end_inset

 получается добавлением 
\begin_inset Formula $K\cdot\poly(h_{2})$
\end_inset

 к сигнатурному представлению 
\begin_inset Formula $\left(\sigma',p'\right)$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:S-basis-is-a-basis"

\end_inset

Если 
\begin_inset Formula $R$
\end_inset

 -- S-базис идеала 
\begin_inset Formula $I$
\end_inset

, то 
\begin_inset Formula $\{\poly(r)\,|\, r\in R\}$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

.
\end_layout

\begin_layout Proof
Для 
\begin_inset Formula $\forall p\in I$
\end_inset

 можно взять некоторый 
\begin_inset Formula $h=\left(\sigma,p\right)\in H$
\end_inset

 и применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-r-sigma"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен инвариант: для 
\begin_inset Formula $\forall\sigma\in\mathbb{T},\sigma\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, найдутся 
\begin_inset Formula $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\Sig(t_{\sigma}r_{\sigma})=\sigma$
\end_inset

 и 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 не редуцируется сигнатурно по 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Множество 
\begin_inset Formula $R_{\sigma}=\left\{ r\in R\,|\,\Sig(r)|\sigma\right\} $
\end_inset

 непусто, так как содержит добавленный на первой итерации элемент 
\begin_inset Formula $r_{0}$
\end_inset

 с 
\begin_inset Formula $\Sig(r_{0})=1$
\end_inset

.
 Обозначим за 
\begin_inset Formula $r_{\sigma}$
\end_inset

 его 
\begin_inset Formula $\GVWl$
\end_inset

-минимальный элемент; положим 
\begin_inset Formula $t_{\sigma}=\frac{\sigma}{\Sig(r_{\sigma})}$
\end_inset

.
 Предположим, что 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 может быть редуцирован с сохранением сигнатуры относительно некоторого
 
\begin_inset Formula $r_{1}\in R$
\end_inset

.
 Отсюда следует, что 
\begin_inset Formula $r_{1}\GVWg r_{\sigma}$
\end_inset

, а также что они не нулевые.
 Значит на той же итерации, когда в 
\begin_inset Formula $R$
\end_inset

 был добавлен последний из 
\begin_inset Formula $\{r_{\sigma},r_{1}\}$
\end_inset

, в множество 
\begin_inset Formula $B$
\end_inset

 был добавлен многочлен 
\begin_inset Formula $t'r_{\sigma}$
\end_inset

, где 
\begin_inset Formula $t'=\frac{\LCM(\HM(r_{1}),\HM(r_{\sigma}))}{\HM(r_{\sigma})}$
\end_inset

, причём 
\begin_inset Formula $t'|t_{\sigma}$
\end_inset

.
 Отсюда 
\begin_inset Formula $\Sig(t'r_{\sigma})|\Sig(t_{\sigma}r_{\sigma})=\sigma\Rightarrow\Sig(t'r_{\sigma})\preccurlyeq\sigma\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

.
 В силу этого неравенства на сигнатуры получается, что 
\begin_inset Formula $t'r_{\sigma}$
\end_inset

 уже не может быть элементом 
\begin_inset Formula $B$
\end_inset

, а значит был выкинут на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 одной из итераций, то есть 
\begin_inset Formula $\exists r_{2}\in R\, r_{2}\GVWl t'r_{\sigma},\Sig(r_{2})|\Sig(t'r_{\sigma})$
\end_inset

.
 Это невозможно, поскольку влечёт 
\begin_inset Formula $r_{2}\GVWl r_{\sigma},r_{2}\in R_{\sigma}$
\end_inset

, что противоречит 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $r_{\sigma}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:has-s-repr"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен инвариант: 
\begin_inset Formula $\forall h\in H,\Sig(h)\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, имеет сигнатурное представление над 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим нарушение инварианта на какой-то итерации и рассмотрим 
\begin_inset Formula $\prec_{0}$
\end_inset

-минимальную 
\begin_inset Formula $\sigma$
\end_inset

, для которой непусто 
\begin_inset Formula $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\Sig(h)=\sigma\}$
\end_inset

.
 Тогда 
\begin_inset Formula $R$
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис.
 Для 
\begin_inset Formula $\forall g\in\left(G\right)$
\end_inset

 соответствующие отмеченные многочлены 
\begin_inset Formula $\left(0,g\right)$
\end_inset

 имеют сигнатурные представления над 
\begin_inset Formula $\{(0,g_{1}),...,(0,g_{m})\}\subset R$
\end_inset

, поэтому 
\begin_inset Formula $\sigma\succ_{0}0$
\end_inset

.
 Выберем 
\begin_inset Formula $v_{\sigma}$
\end_inset

 -- один из элементов 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\prec_{0}$
\end_inset

-наименьшим 
\begin_inset Formula $\HM$
\end_inset

.
 Он не может быть редуцирован с сохранением сигнатуры по 
\begin_inset Formula $R$
\end_inset

, поскольку результат редукции 
\begin_inset Formula $v_{1}$
\end_inset

 был бы элементом 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\HM(v_{1})\prec_{0}\HM(v_{\sigma})$
\end_inset

.
 Возьмём 
\begin_inset Formula $w_{\sigma}\eqdef t_{\sigma}r_{\sigma}$
\end_inset

 из инварианта теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-r-sigma"

\end_inset

 и применим лемму 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:s-basis-and-no-reductions"

\end_inset

 к 
\begin_inset Formula $v_{\sigma},w_{\sigma}$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

.
 Получим что 
\begin_inset Formula $v_{\sigma}$
\end_inset

 имеет сигнатурное представление над 
\begin_inset Formula $R\cup\{w_{\sigma}\}$
\end_inset

.
 Вхождения 
\begin_inset Formula $w_{\sigma}$
\end_inset

 в нём можно заменить на 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

, получив представление 
\begin_inset Formula $v_{\sigma}$
\end_inset

 над 
\begin_inset Formula $R$
\end_inset

, что приводит к противоречию.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 возвращает базис Грёбнера
\end_layout

\begin_layout Proof
К моменту остановки 
\begin_inset Formula $B=\varnothing$
\end_inset

, значит по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr"

\end_inset

 
\begin_inset Formula $R$
\end_inset

 -- S-базис, а значит и базис Грёбнера.
\end_layout

\begin_layout Subsection
Сравнение с аналогами
\end_layout

\begin_layout Standard
Представленный алгоритм принадлежит к семейству алгоритмов вычисления базисов
 Грёбнера, которые вычисляют S-базис и в той или иной степени являются развитием
 алгоритма F5.
 Одно из основных направлений его развития -- упрощение теоретических обосновани
й и расширение области применимости -- представлено в 
\begin_inset CommandInset citation
LatexCommand cite
key "F5InBBStyle,GermanF5Proof_ru,ZobninGeneralization_ru"

\end_inset

.
 Другое -- повышение эффективности путём ввода дополнительных критериев
 отбрасывания некоторых вычислений -- описывается в 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C,G2V,SignatureBasedGBs"

\end_inset

 и позволяет проводить вычисления так, чтобы до конца редуцировались лишь
 многочлены, являющиеся новыми элементами S-базиса или дающие новую сигнатуру
 нулевого многочлена, расширяющую идеал моноида, содержащий такие сигнатуры,
 называемые также 
\emph on
сигнатурами сизигий.

\emph default
 Обобщение с одновременным применением всех критериев в алгоритмах TRB-MJ
 и SB 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception,PracticalGB"

\end_inset

 позволяет добиться большей эффективности благодаря тому, что все отбрасывания
 применяются до проведения таких вычислительно трудоёмких операций, как
 редукция многочлена или подсчёт старшего монома S-пары, -- в результате
 не оказывается, что результаты каких-то вычислений были отброшены.
\end_layout

\begin_layout Standard
Определённое подтверждение эффективности приведённого алгоритма среди алгоритмов
, вычисляющих S-базис, заключается в отсутствии вычислений лишних элементов
 S-базиса.
\end_layout

\begin_layout Theorem
S-базис, вычисляемый 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

, -- минимален
\end_layout

\begin_layout Proof
Предположим, что S-базис не минимален.
 Это означает, что один из элементов 
\begin_inset Formula $\left(\sigma,p\right),p\ne0$
\end_inset

, добавленный в 
\begin_inset Formula $R$
\end_inset

 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 имеет сигнатурное представление над остальными элементами.
 Элементы, добавляемые в 
\begin_inset Formula $R$
\end_inset

 после него, имеют сигнатуры 
\begin_inset Formula $\succ_{0}\sigma$
\end_inset

, поэтому в таком представлении используются только элементы, добавленные
 в 
\begin_inset Formula $R$
\end_inset

 ранее.
 По теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset

 в этом представлении есть элемент 
\begin_inset Formula $m_{1}\cdot h_{1},h_{1}\in R$
\end_inset

 c 
\begin_inset Formula $\HM(h_{1})|\HM(p)$
\end_inset

.
 В силу сигнатурности 
\begin_inset Formula $m_{1}\Sig(h_{1})\preccurlyeq_{0}\sigma$
\end_inset

.
 При этом строгое неравенство невозможно в силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

, а равенство -- в силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new"

\end_inset

, что даёт противоречие.
\end_layout

\begin_layout Standard
Во всех упомянутых алгоритмах, включая исходный F5, формулируется два типа
 критериев отброса: критерии, связанные с сизигиями, называемые в этой работе
 также 
\begin_inset Quotes fld
\end_inset

критериями F5
\begin_inset Quotes frd
\end_inset

, и критерии перезаписи, корректность каждого из которых доказывается независимо.
 Описанный алгоритм несколько проще: он использует лишь единственный критерий
 отброса на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

, основанный на 
\begin_inset Formula $\GVWl$
\end_inset

-упорядочивании множества 
\begin_inset Formula $R$
\end_inset

, сохраняя при этом гарантию минимальности S-базиса.
 Однако вопрос наиболее эффективного способа выбора редуктора в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 является в какой-то степени открытым.
 Представленный в описании алгоритма способ выбора продиктован утверждением
 
\begin_inset CommandInset ref
LatexCommand ref
reference "clm:how-reds"

\end_inset

 о работе исходного алгоритма F5, и использует всё то же 
\begin_inset Formula $\GVWl$
\end_inset

-упорядочение 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
Также, даже в алгоритмах, не вычисляющих S-многочлены в процессе работы,
 теоретическое обоснование корректности алгоритма на них как правило опирается.
 Приведённое доказательство алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 не использует S-многочлены и доказывает алгебраические инварианты, выполняющиес
я в процессе работы алгоритма, что позволяет применять к нему почти без
 изменений простую алгебраическую интерпретацию из 
\begin_inset CommandInset citation
LatexCommand cite
key "ZobninGeneralization_ru"

\end_inset

.
\end_layout

\begin_layout Standard
Упрощение формулировки алгоритма по сравнению с аналогами повлекло значительное
 уменьшение времени на его написание и отладку на компьютере, как за счёт
 меньшего количества множеств, так и за счёт общего порядка 
\begin_inset Formula $<_{H}$
\end_inset

 для критериев отбрасывания и процедуры редукции.
 Простота реализации и нетребовательность к структурам данных позволяет
 за небольшое время внедрять эффективную версию алгоритма в любую систему
 компьютерной алгебры.
 Реализация, упоминаемая ниже, была создана автором за 8 часов, что на порядок
 меньше, чем время, затраченное поскольку автором на экспериментальные реализаци
и других алгоритмов в подобных условиях.
 
\end_layout

\begin_layout Standard
Алгоритм был реализован на С++ с использованием функций ядра программного
 комплекса Singular 3-1-4 и открытых наработок Кристиана Эдера (одного из
 авторов 
\begin_inset CommandInset citation
LatexCommand cite
key "SignatureBasedGBs"

\end_inset

) по реализации F5-подобных алгоритмов на этом ядре.
 Исходный код реализации содержится в функции ssg файла, доступного по адресу
 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc"

\end_inset


\end_layout

\begin_layout Standard
Эмпирическое сравнение данной реализации с другими алгоритмами вычисления
 базисов Грёбнера, реализованных Кристианом Эдером подтвердили следующие
 соображения:
\end_layout

\begin_layout Itemize
алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 корректно вычисляет базис Грёбнера;
\end_layout

\begin_layout Itemize
результат содержит не большее число многочленов, чем результат других инкремента
льных алгоритмов, возвращающих S-базис, что согласуется с утверждением о
 минимальности S-базиса;
\end_layout

\begin_layout Itemize
время работы алгоритма оказывается не больше, чем у других инкрементальных
 алгоритмов, основанных на сигнатурах.
\end_layout

\begin_layout Subsection
Одноэтапный вариант
\end_layout

\begin_layout Standard
В работе 
\begin_inset CommandInset citation
LatexCommand cite
key "Eder2012inhomogeneous"

\end_inset

 показано, что шаг большинства инкрементальных алгоритмов, основанных на
 сигнатурах, включая исходный F5, может быть легко модифицирован для использован
ия в виде одноэтапного алгоритма при использовании множества сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 и определённого порядка на нём, называемого порядком Schreyer.
 Однако, поскольку данный порядок не исчерпывает все возможные согласованные
 порядки на сигнатурах, мы сформулируем одноэтапную версию алгоритма для
 произвольного порядка 
\begin_inset Formula $\prec_{a}$
\end_inset

 на 
\begin_inset Formula $\mathbf{T}$
\end_inset

, согласованного с порядком на мономах, и покажем её корректность.
 Конкретные порядки будут рассмотрены позже.
 Как и в случае инкрементального алгоритма случаи, когда среди входных многочлен
ов 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 есть элемент из 
\begin_inset Formula $\mathcal{K}$
\end_inset

, не представляют интереса: если он ненулевой, то 
\begin_inset Formula $\left(f_{1},\ldots,f_{m}\right)=\left(1\right)=\mathcal{P}$
\end_inset

, а если нулевой, то его можно выкинуть из входного множества без влияния
 на результат.
 Поэтому далее предполагается, что алгоритм применяется только при 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} \cap\mathcal{K}=\varnothing$
\end_inset

.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:SingleStepSignatureGroebner"

\end_inset


\family typewriter
SingleStepSignatureGroebner
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход: многочлены 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

,
\family default
 согласованный с мономиальным порядка 
\begin_inset Formula $\prec_{a}$
\end_inset

 на 
\begin_inset Formula $\mathbf{T}$
\end_inset

, индуцированный им частичный порядок 
\begin_inset Formula $<_{H}$
\end_inset

 на 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 -- подмножества 
\begin_inset Formula $H$
\end_inset

, 
\begin_inset Formula $(\sigma,p')\in H$
\end_inset

 -- отмеченный многочлен текущего шага до редукции, 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- он же после редукции, 
\begin_inset Formula $r,b$
\end_inset

 -- элементы 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\cup_{1\leqslant i<j\leqslant m}\left\{ \left(\max_{\prec_{a}}\left(\left(\HM(f_{i}),j\right),\left(\HM(f_{j}),i\right)\right),0\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{((1,1),f_{1}),((1,2),f_{2}),\dots,((1,m),f_{m})\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $B\neq\varnothing$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\sigma,p')\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec_{a}$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-sigma-from-B-sstep"

\end_inset


\begin_inset Formula $B\leftarrow B\setminus\{b\in B,\Sig(b)=\sigma\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-before-reduce-sstep"

\end_inset


\begin_inset Formula $p\leftarrow$
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

((
\begin_inset Formula $\sigma,p'),R$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-after-reduce-sstep"

\end_inset


\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:-remove-from-B-sstep"

\end_inset


\begin_inset Formula $B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\Sig(r)|\Sig(b)\}$
\end_inset

, где под делимостью сигнатур, подразумевается делимость определённая для
 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)\,|\, r\in R,\poly(r)\ne0\}$
\end_inset


\end_layout

\begin_layout Standard

\series medium
Код процедуры 
\series default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset


\series medium
 не меняется по сравнению с инкрементальной версией, и выполняется для отмеченны
х многочленов с сигнатурами из 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
\end_layout

\begin_layout Standard
Как и алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

, представленная версия алгоритма оказывается похожей на несколько известных
 алгоритмов.
 Алгоритм GVW описан в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

 похожим псевдокодом, но имеет принципиальное отличие в работе: обобщённый
 критерий отбрасывания шага 
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-from-B-sstep"

\end_inset

 с учётом делимости сигнатур применяется там лишь для многочленов редуцировавших
ся к нулю, в то время как для остальных многочленов GVW применяет более
 слабый критерий на шаге 3b.iii, не гарантирующий получение минимального
 S-базиса.
 Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

 содержит неименованный 
\begin_inset Quotes fld
\end_inset

алгоритм 6
\begin_inset Quotes frd
\end_inset

, псевдокод которого также очень похож на приведённый.
 Его отличие с вычислительной точки зрения в состоит в том что 
\begin_inset Quotes fld
\end_inset

алгоритм 6
\begin_inset Quotes frd
\end_inset

 производит вычисление старших мономов S-многочленов до применения критериев.
 Это зачастую приводит к лишним вычислениям, поскольку вычисление старшего
 монома линейной комбинации многочленов в случае сокращения мономов может
 оказаться также трудоёмко как полное вычисление линейной комбинации, а
 результат этого вычисления алгоритм может отбросить по критериям.
\end_layout

\begin_layout Standard
С другой стороны, алгоритмы TRB-MJ и SB, описанные в
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception,PracticalGB"

\end_inset

, псевдокод которых формулируется менее похожим образом, по сути производят
 вычисления совпадающие с вычислениями алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 и также дают минимальный S-базис в качестве результата.
 Отличие приведённого здесь алгоритма проявляется не с точки зрения сложности
 вычислений, а сточки зрения обоснования -- унифицированная формулировка
 критерия отбрасывания на шаге 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:-remove-from-B-sstep"

\end_inset

 приводит к упрощению доказательства.
\end_layout

\begin_layout Lemma
Все пары из 
\begin_inset Formula $\mathbf{T}\times\mathcal{P}$
\end_inset

 в алгоритме -- отмеченные многочлены.
 При это среди элементов 
\begin_inset Formula $R$
\end_inset

 до первого выполнения шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 нет элементов с единичным мономом сигнатуры.
\end_layout

\begin_layout Proof
Элементы, формирующие 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 до начала главного цикла, являются рассмотренными в примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:labeled-polys"

\end_inset

 отмеченными многочленами.
 Все остальные отмеченные многочлены в алгоритме формируются или умножением
 на 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

 или редукцией с сохранением сигнатуры, поэтому они корректны и лежат в
 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Мономы сигнатуры элементов 
\begin_inset Formula $R$
\end_inset

 до шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 являются старшими мономами одного из исходных многочленов, и не являются
 единичными, поскольку 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} \cap\mathcal{K}=\varnothing$
\end_inset

.
\end_layout

\begin_layout Standard
Доказательства корректности и остановки основаны на той же схеме, что и
 доказательства для шага инкрементального алгоритма, однако сильно отличаются
 в деталях, поэтому приведём изменившиеся утверждения.
\end_layout

\begin_layout Subsubsection
Остановка
\end_layout

\begin_layout Standard
В отличии от леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor"

\end_inset

 в одноэтапном алгоритме возможность редукции утверждается лишь для многочленов
 с неединичными мономами сигнатуры.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:exist-reductor-not1-sstep"

\end_inset

В любой момент работы алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 любой отмеченный многочлен из 
\begin_inset Formula $B$
\end_inset

, моном сигнатуры которого не равен 1, может быть редуцирован с сохранением
 сигнатуры по некоторому элементу 
\begin_inset Formula $R.$
\end_inset


\end_layout

\begin_layout Proof
Отмеченные многочлены c не равным 1 мономом сигнатуры добавляются в 
\begin_inset Formula $B$
\end_inset

 таким образом, чтобы иметь хотя бы один подходящий редуктор.
 
\begin_inset Formula $(\sigma,p)\in R$
\end_inset

 является таким редуктором при добавлении в первом цикле 
\series bold
for
\series default
, 
\begin_inset Formula $r\in R$
\end_inset

 -- во втором.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-small-sstep"

\end_inset

До редукции многочлена 
\begin_inset Formula $p'$
\end_inset

, то есть на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-before-reduce-sstep"

\end_inset

 любой итерации алгоритма, сигнатуры элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $
\end_inset

 не делят 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
На первой итерации алгоритма это выполняется, поскольку все мономы сигнатур
 равны 1, а все элементы 
\begin_inset Formula $R$
\end_inset

 имеют сигнатуры, не равные 1.
 На последующих итерациях это выполнено, поскольку если бы в 
\begin_inset Formula $R$
\end_inset

 существовали такие элементы, то 
\begin_inset Formula $\left(\sigma,p'\right)$
\end_inset

 был бы убран из 
\begin_inset Formula $B$
\end_inset

 в предыдущей итерации на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-big-sstep"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 любой итерации алгоритма, старшие мономы элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $
\end_inset

 не делят 
\begin_inset Formula $\HM(p)$
\end_inset

.
\end_layout

\begin_layout Proof
Полностью идентично лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:adds-really-new-sstep"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, элементы 
\begin_inset Formula $R$
\end_inset

 не могут одновременно иметь старшие мономы, делящие 
\begin_inset Formula $\HM(p)$
\end_inset

, и сигнатуры, делящие 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
Для элементов с мономом сигнатуры, отличным от 1, В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor-not1-sstep"

\end_inset

 будет произведена хотя бы одна редукция 
\begin_inset Formula $p'$
\end_inset

, поэтому 
\begin_inset Formula $(\sigma,p')\GVWg(\sigma,p)$
\end_inset

.
 Отсюда по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:greater-or-smaller"

\end_inset

 для 
\begin_inset Formula $\forall r\in R$
\end_inset

 имеем 
\begin_inset Formula $r\GVWg(\sigma,p)$
\end_inset

 или 
\begin_inset Formula $r\GVWl(\sigma,p')$
\end_inset

.
 Выполнение одного из неравенств позволяет применить одну из лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-small-sstep"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big-sstep"

\end_inset

.
\end_layout

\begin_layout Proof
Для элементов с мономом сигнатуры 1 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 в 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $R$
\end_inset

 не может быть делящих сигнатуру элементов, поскольку все элементы добавленные
 изначально имеют не равные 1 мономы сигнатуры, а среди добавляемых позже
 элементов 
\begin_inset Formula $\left(\sigma,p\right)=\left(\left(1,\sigidx(\sigma)\right),p\right)$
\end_inset

 -- это первый элемент с индексом 
\begin_inset Formula $\sigidx(\sigma)$
\end_inset

, который не может иметь делителей сигнатуры .
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 останавливается
\end_layout

\begin_layout Proof
Для доказательства остановки нужно показать, что все циклы 
\series bold
do
\series default
 выполняются лишь конечное число раз.
 Остановка 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 показана в доказательстве теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:SSG-stop"

\end_inset

.
 На каждом шаге основного цикла 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 пополняется множество 
\begin_inset Formula $R\subset P=\mathbf{T}\times\mathcal{P}$
\end_inset

.
 Оно может быть разбито как 
\begin_inset Formula 
\[
\bigcup_{i=1,\dots,m}R_{i0}\cup R_{i*},
\]

\end_inset

 где 
\begin_inset Formula $R_{i0}\subset\left\{ (\sigma,i),\sigma\in\mathbb{T}\right\} \times\left\{ 0\right\} ,R_{i*}\subset\left\{ (\sigma,i),\sigma\in\mathbb{T}\right\} \times\mathcal{P}\setminus\left\{ 0\right\} $
\end_inset

.
 Для 
\begin_inset Formula $R_{i0}$
\end_inset

 и 
\begin_inset Formula $R_{i*}$
\end_inset

 применим подход, аналогичный теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:SSG-stop"

\end_inset

.
 Рассмотрим следующие множества, являющиеся идеалами моноидов: 
\begin_inset Formula $L_{i0}=\left(\left\{ \sigma\,|\,((\sigma,i),0)\in R_{i0}\right\} \right)\subset\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $L_{i*}=\left(\left\{ (\sigma,t)\,|\,\exists((\sigma,i),p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$
\end_inset

.
 В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new-sstep"

\end_inset

 добавляемые в 
\begin_inset Formula $R$
\end_inset

 элементы расширяют на каждом шаге одно из 
\begin_inset Formula $L_{i0}$
\end_inset

 или 
\begin_inset Formula $L_{i*}$
\end_inset

.
 Поскольку моноиды 
\begin_inset Formula $\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\mathbb{T}\times\mathbb{T}$
\end_inset

 изоморфны 
\begin_inset Formula $\mathbb{N}^{n}$
\end_inset

 и 
\begin_inset Formula $\mathbb{N}^{2n}$
\end_inset

, к их идеалам может быть применена лемма Диксона, которая и утверждает,
 что расширение может происходить лишь конечное число раз.
\end_layout

\begin_layout Subsubsection
Корректность
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-r-sigma-sstep"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

 выполнен инвариант: для 
\begin_inset Formula $\forall\sigma\in\mathbf{T},\sigma\prec_{a}$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, найдутся 
\begin_inset Formula $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\Sig(t_{\sigma}r_{\sigma})=\sigma$
\end_inset

 и 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 не редуцируется сигнатурно по 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
До начала итераций множество 
\begin_inset Formula $B$
\end_inset

 содержит элементы с сигнатурой 
\begin_inset Formula $\left(1,i\right)$
\end_inset

 для всех индексов сигнатуры 
\begin_inset Formula $i=1,\dots,m$
\end_inset

.
 В процессе работы алгоритма элемент c сигнатурой 
\begin_inset Formula $\left(1,i\right)$
\end_inset

 не может быть удалён из 
\begin_inset Formula $B$
\end_inset

 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

, поскольку 
\begin_inset Formula $R$
\end_inset

 изначально не содержит элементов с единичной сигнатурой, а для исключения
 такого элемента нужен элемент 
\begin_inset Formula $R$
\end_inset

 с такой же сигнатурой.
 Когда какой-то из элементов с сигнатурой 
\begin_inset Formula $\left(1,i\right)$
\end_inset

 исключается на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-sigma-from-B-sstep"

\end_inset

, то после этого производится его редукция и сохранение в 
\begin_inset Formula $R$
\end_inset

.
 Таким образом получается, что если 
\begin_inset Formula $\sigma\prec_{a}$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, то в 
\begin_inset Formula $R$
\end_inset

 есть элемент 
\begin_inset Formula $r_{0}$
\end_inset

 с 
\begin_inset Formula $\Sig(r_{0})=\left(1,\sigidx(\sigma)\right)$
\end_inset

 и можно утверждать что множество 
\begin_inset Formula $R_{\sigma}=\left\{ r\in R\,|\,\Sig(r)|\sigma\right\} $
\end_inset

 непусто, так как содержит элемент 
\begin_inset Formula $r_{0}$
\end_inset

.
\end_layout

\begin_layout Proof
Дальнейшее доказательство совпадает с окончанием доказательства теоремы
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-r-sigma"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:has-s-repr-sstep"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

 выполнен инвариант: 
\begin_inset Formula $\forall h\in H,\Sig(h)\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, имеет сигнатурное представление над 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим нарушение инварианта на какой-то итерации и рассмотрим 
\begin_inset Formula $\prec_{a}$
\end_inset

-минимальную 
\begin_inset Formula $\sigma$
\end_inset

, для которой непусто 
\begin_inset Formula $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\Sig(h)=\sigma\}$
\end_inset

.
 Тогда 
\begin_inset Formula $R$
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис.
 Из определения 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $V_{\sigma}$
\end_inset

 вытекает, что многочленов с нулевым 
\begin_inset Formula $\HM$
\end_inset

 в нём нет.
 Выберем 
\begin_inset Formula $v_{\sigma}$
\end_inset

 -- один из элементов 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\prec$
\end_inset

-наименьшим 
\begin_inset Formula $\HM$
\end_inset

.
 Он не может быть редуцирован с сохранением сигнатуры по 
\begin_inset Formula $R$
\end_inset

, поскольку результат редукции 
\begin_inset Formula $v_{1}$
\end_inset

 был бы элементом 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\HM(v_{1})\prec\HM(v_{\sigma})$
\end_inset

.
\end_layout

\begin_layout Proof
Дальнейшее доказательство совпадает с окончанием доказательства теоремы
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 возвращает базис Грёбнера
\end_layout

\begin_layout Proof
Доказательство полностью аналогично инкрементальному случаю: к моменту остановки
 
\begin_inset Formula $B=\varnothing$
\end_inset

, значит по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr-sstep"

\end_inset

 
\begin_inset Formula $R$
\end_inset

 -- S-базис, а значит и базис Грёбнера.
\end_layout

\begin_layout Subsection
Взвешенные порядки
\end_layout

\begin_layout Standard
Формулировка алгоритма приведённая выше не фиксировала конкретный порядок
 
\begin_inset Formula $\prec_{a}$
\end_inset

 на 
\begin_inset Formula $\mathbf{T}$
\end_inset

, требую лишь от него согласованность с мономиальным порядком.
 Определения и сравнение эффективности различных согласованных порядков
 можно найти в параграфе Term Orders работы
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

.
 Среди приведённых там порядков остановимся на двух: POT (position over
 term) и 
\series bold
g
\series default
2, называемом также порядком Schreyer 
\begin_inset CommandInset citation
LatexCommand cite
key "Eder2012inhomogeneous"

\end_inset

.
\end_layout

\begin_layout Standard
Порядок POT определён в начале этой работы как 
\begin_inset Formula $\prec_{P}$
\end_inset

 и является согласованным по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:precP_compatible"

\end_inset

.
 По сути его использование превращает многие одноэтапные алгоритмы в инкрементал
ьные, поскольку следующий входной многочлен не рассматривается до тех пор,
 пока не завершится вычисление для предыдущих.
 Алгоритм GVW с порядком 
\begin_inset Formula $\prec_{P}$
\end_inset

 превращается в алгоритм G2V из 
\begin_inset CommandInset citation
LatexCommand cite
key "G2V"

\end_inset

, а 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с порядком 
\begin_inset Formula $\prec_{P}$
\end_inset

 даёт в точности алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

.
\end_layout

\begin_layout Standard
Для второго порядка понадобится формулировка в обобщённом виде:
\end_layout

\begin_layout Definition
Взвешенным порядком на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 для одноэтапного вычисления с 
\begin_inset Formula $m$
\end_inset

 входными многочленами называется порядок 
\begin_inset Formula $\prec_{w}$
\end_inset

 с параметром 
\begin_inset Formula $w=(w_{1},\dots,w_{m})\in\mathbb{T}^{m}$
\end_inset

, определяемый как
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\left(t_{1},i_{1}\right)\prec_{w}\left(t_{2},i_{2}\right)\Longleftrightarrow\left[\begin{aligned} & t_{1}w_{i_{1}}\prec t_{2}w_{i_{2}}\\
 & t_{1}w_{i_{1}}=t_{2}w_{i_{2}},i{}_{1}<i_{2}
\end{aligned}
\right..
\]

\end_inset


\end_layout

\begin_layout Lemma
Взвешенный порядок с любым значением параметра является согласованным с
 мономиальным порядком 
\begin_inset Formula $\prec$
\end_inset


\end_layout

\begin_layout Proof
Пусть Пусть 
\begin_inset Formula $\sigma=(s,i)\in\mathbf{T}$
\end_inset

.
 Тогда 
\begin_inset Formula 
\[
t_{1}\sigma\prec_{w}t_{2}\sigma\Longleftrightarrow\left(t_{1}s,i\right)\prec_{w}\left(t_{2}s,i\right)\Longleftrightarrow t_{1}sw_{i}\prec t_{2}sw_{i}\Longleftrightarrow t_{1}\prec t_{2}
\]

\end_inset


\end_layout

\begin_layout Definition
Порядком Schreyer на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 для одноэтапного вычисления с входными многочленами 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 называется взвешенный порядок 
\begin_inset Formula $\prec_{w}$
\end_inset

 со значением параметра 
\begin_inset Formula $w=(\HM(f_{1}),\dots,\HM(f_{m}))$
\end_inset

.
 Этот порядок будем обозначать как 
\begin_inset Formula $\prec_{S}$
\end_inset

.
\end_layout

\begin_layout Standard
Эмпирические эксперименты в 
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

 показали, что одноэтапные алгоритмы вычислений базисов Грёбнера с порядком
 
\begin_inset Formula $\prec_{s}$
\end_inset

 в среднем оказываются как минимум не менее эффективными, чем вычисления
 с другими известными порядками на сигнатурах, совместимыми с порядком на
 мономах.
 Поэтому в качестве базового алгоритма вычисления базиса Грёбнера в следующей
 части будет рассматриваться алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с порядком 
\begin_inset Formula $\prec_{s}$
\end_inset

.
\end_layout

\begin_layout Part
Решение систем полиномиальных уравнений
\end_layout

\begin_layout Standard
Задачи решения систем уравнений, образованных многочленами 
\begin_inset Formula $f_{1},\ldots,f_{m}$
\end_inset

 из кольца
\begin_inset Formula $\mathcal{P}=\mathcal{K}\left[x_{1},\dots,x_{n}\right]$
\end_inset

, возникают в различных областях науки, в частности криптографии и алгоритмах
 компьютерного зрения.
 Для решения таких систем могут применяться общие методы решения систем
 уравнений заданных аналитическими функциями, в частности итерационные методы.
 Такие методы не всегда позволяют найти все решения рассматриваемой системы.
 Однако тот факт, что уравнения заданы многочленами, позволяет применять
 специализированные методы решения систем полиномиальных уравнений.
\end_layout

\begin_layout Standard
Наиболее простым методом этого типа является метод, основанный на вычислении
 базиса Грёбнера относительно лексикографического порядка на мономах с последующ
им последовательным исключением переменных путём решения одномерных задач.
 Этот метод рассматривается в 1-м параграфе главы 2 книги 
\begin_inset CommandInset citation
LatexCommand cite
key "UsingAlgebraicGeometry"

\end_inset

.
 Его недостатком является необходимость вычислять базис Грёбнера именно
 относительно лексикографического порядка, что может оказаться значительно
 более трудоёмкой задачей, нежели вычисление с другими мономиальными порядками.
\end_layout

\begin_layout Standard
Другой метод решения основан на собственных векторах линейного оператора
 в векторном пространстве 
\begin_inset Formula $\mathcal{A}=\mathcal{P}/\left(f_{1},\ldots,f_{m}\right)$
\end_inset

, задаваемого матрицей действий умножением, называемой также просто матрицей
 действий.
 Данный метод описывается и доказывается в предложении 4.7 главы 2 книги
 
\begin_inset CommandInset citation
LatexCommand cite
key "UsingAlgebraicGeometry"

\end_inset

.
 Его схема такова:
\end_layout

\begin_layout Enumerate
находится набор образующих радикала 
\begin_inset Formula $I'=\sqrt{I}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
строится базис Грёбнера 
\begin_inset Formula $G$
\end_inset

 идеала 
\begin_inset Formula $I=\left(f_{1},\ldots,f_{m}\right)$
\end_inset

 относительно произвольного мономиального порядка 
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:use-basis-for-radical"

\end_inset

образующие радикала находятся на основе нормальной формы относительно базиса
 Грёбнера 
\begin_inset Formula $G$
\end_inset

 с использованием метода описанного в параграфе 2 той же главы
\end_layout

\end_deeper
\begin_layout Enumerate
вычисляется матрица 
\begin_inset Formula $m_{F}$
\end_inset

 линейного оператора в пространстве 
\begin_inset Formula $\mathcal{A}=\mathcal{P}/I'$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
строится базис Грёбнера 
\begin_inset Formula $G'$
\end_inset

 идеала 
\begin_inset Formula $I'$
\end_inset

 относительно произвольного мономиального порядка
\end_layout

\begin_layout Enumerate
фиксируется базис 
\begin_inset Formula $B=\left\{ b_{1},\dots,b_{l}\right\} \subset\mathcal{A}$
\end_inset

, образованный мономами, не являющимися старшими мономами многочленов 
\begin_inset Formula $I'$
\end_inset

.
 Если оказывается, что множество таких мономов бесконечно, то множество
 решений системы содержит бесконечно много точек и рассматриваемый алгоритм
 неприменим к данному случаю.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:selecting-ci"

\end_inset

выбирается произвольный набор ненулевых случайных констант 
\begin_inset Formula $c_{1},\dots,c_{n}\in\mathcal{K}$
\end_inset


\end_layout

\begin_layout Enumerate
рассматривается оператор умножения на многочлен 
\begin_inset Formula $F=\sum_{i=1}^{n}c_{i}x_{i}\in\mathcal{P}$
\end_inset

 как линейный оператор в 
\begin_inset Formula $\mathcal{A}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:use-basis-for-matrix"

\end_inset

строится матрица этого оператора, являющаяся 
\begin_inset Formula $l\times l$
\end_inset

 матрицей с элементами из 
\begin_inset Formula $\mathcal{K}$
\end_inset

.
 При этом 
\begin_inset Formula $G'$
\end_inset

 используется для вычисления нормальной формы многочлена, являющейся однозначным
 представителем класса в 
\begin_inset Formula $\mathcal{A}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Находится 
\begin_inset Formula $l$
\end_inset

 различных собственных векторов матрицы 
\begin_inset Formula $m_{F}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
при помощи метода поиска собственных значений матрицы для 
\begin_inset Formula $\mathcal{K}$
\end_inset

 определяются собственные значения матрицы 
\begin_inset Formula $m_{F}$
\end_inset


\end_layout

\begin_layout Enumerate
если число различных собственных значений оказывается меньше 
\begin_inset Formula $l$
\end_inset

, выполняется возврат к шагу 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:selecting-ci"

\end_inset

, где выбираются другие случайные константы.
 На практике возникновение такой ситуации крайне маловероятно.
\end_layout

\begin_layout Enumerate
путём решения системы линейных уравнений над 
\begin_inset Formula $\mathcal{K}$
\end_inset

 находятся левые вектора-строки, отвечающие собственным значениям
\end_layout

\end_deeper
\begin_layout Enumerate
Находятся значения 
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

, соответствующие каждому собственному вектору
\end_layout

\begin_deeper
\begin_layout Enumerate
значения собственного вектора трактуются как значения базисных элементов
 
\begin_inset Formula $b_{1},\dots,b_{l}$
\end_inset

 в точке, являющейся решением исходной системы.
\end_layout

\begin_layout Enumerate
находятся значения 
\begin_inset Formula $x_{j}\in B$
\end_inset

 путём выбора их из найденных значений базисных элементов
\end_layout

\begin_layout Enumerate
находятся значения 
\begin_inset Formula $x_{i}\notin B$
\end_inset

 путём подстановки в многочлены 
\begin_inset Formula $p_{i}\in G',\HM(p_{i})=x_{i}$
\end_inset

 найденных значений
\begin_inset Formula $x_{j}\in B$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Приведённый алгоритм использует базис Грёбнера на шагах 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:use-basis-for-matrix"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:use-basis-for-radical"

\end_inset

 для нахождения нормальной формы и это единственное, что требуется от базиса.
 Таким образом описанный алгоритм не накладывает никакого ограничения на
 мономиальный порядок, относительно которого считается базис Грёбнера.
 Также допустимы модификации данного алгоритма, вычисляющие не базис Грёбнера,
 а краевой базис, строгое определение которого даётся в 
\begin_inset CommandInset citation
LatexCommand cite
key "NumericalPolynomialAlgebra"

\end_inset

, являющийся более общим понятием по сравнению с базисом Грёбнера.
 Работы 
\begin_inset CommandInset citation
LatexCommand cite
key "FastStablePolySolving,ComputingBorderBases"

\end_inset

 предлагают различные алгоритмы его вычисления, в частности оптимизированные
 для численных задач, однако эти алгоритмы не используют сигнатурных методов,
 показавших свою эффективность при вычислении базисов Грёбнера.
 
\end_layout

\begin_layout Section
Задачи с приближёнными входными данными
\end_layout

\begin_layout Standard
При этом, если вычисление проходит в 
\begin_inset Formula $\mathcal{K}=\mathbb{C}$
\end_inset

, входные данные могут быть заданы с некоторой погрешностью.
 Опишем рассматриваемую задачу более формально:
\end_layout

\begin_layout Standard
Приведём более строгую формулировку формулировку задачи, которую будем рассматри
вать.
\end_layout

\begin_layout Definition
Назовём интервалом 
\end_layout

\begin_layout Standard
Теперь можно построить формальный многочлен с такими коэффициентами.
\end_layout

\begin_layout Definition
Приближённым многочленом в 
\begin_inset Formula $\mathbb{C}$
\end_inset

 Для заданного конечного набора 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 многочленов в кольце многочленов 
\begin_inset Formula $\mathcal{P}=\mathbb{C}\left[x_{1},\dots,x_{n}\right]$
\end_inset

 определить конечность множества решений.
\end_layout

\begin_layout Standard
[Символический метод, приближённая арифметика, интервальная арифметика]
\end_layout

\begin_layout Standard
Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

 предлагает адаптацию алгоритмов Бухбергера и F5 для численного вычисления
 Базисов Грёбнера, однако имеет недостаток -- после обнаружения каждого
 из нулей, входная система модифицируется и алгоритм запускается заново,
 теряя таким образом все результаты, вычисленные ранее.
\end_layout

\begin_layout Section
Проблемы применения алгоритмов Базиса Грёбнера в интервальной арифметике
\end_layout

\begin_layout Standard
[Влияние нулей на процесс вычисления]
\end_layout

\begin_layout Subsection
Символические нули
\end_layout

\begin_layout Standard
[Пример того, когда ноль при любом значении параметра]
\end_layout

\begin_layout Subsection
Приближённые нули, порождаемые входными данными
\end_layout

\begin_layout Standard
[Пример того, когда ноль выражает существующую зависимость во входных данных.
 Примеры устранимой (
\begin_inset Formula $\varepsilon x+y+1$
\end_inset

) и неустранимой (
\begin_inset Formula $\varepsilon x+1$
\end_inset

) зависимости.
 Хорошо бы с определениями, если удастся сформулировать]
\end_layout

\begin_layout Subsection
Приближённые нули, порождаемые вычислениями
\end_layout

\begin_layout Standard
[Пример - во многом готов, адаптировать к SSG-Shreyer]
\end_layout

\begin_layout Standard
Рассмотрим задачу нахождения базиса Грёбнера с точки зрения порядка degrevlex(
\begin_inset Formula $x,y,z$
\end_inset

) для идеала, заданного многочленами с параметрами 
\begin_inset Formula $a$
\end_inset

 и 
\begin_inset Formula $b$
\end_inset

: 
\begin_inset Formula 
\[
g_{1}=y^{2}z+z^{2}+az
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{2}=xyz
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{3}=xy^{2}+bx+1
\]

\end_inset


\end_layout

\begin_layout Standard
Применим алгоритм Бухбергера:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{4}=S(g_{1},g_{2})=xz^{2}+axz
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
g_{5}=S(g_{1},g_{3})=-xz^{2}+(b-a)xz+z
\]

\end_inset


\end_layout

\begin_layout Standard
что после редукции по 
\begin_inset Formula $g_{4}$
\end_inset

 даёт:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(1-1)xz^{2}+(a+(b-a))xz+z=(a+(b-a))xz+z
\]

\end_inset


\end_layout

\begin_layout Standard
При вычислениях с ограниченной точностью или в интервальной арифметике выражения
 вида 
\begin_inset Formula $(a+(b-a))xz+z$
\end_inset

 с фиксированным значением параметра 
\begin_inset Formula $a$
\end_inset

 может произойти потеря точности в ведущем коэффициенте многочлена, особенно
 если абсолютная точность значения 
\begin_inset Formula $a$
\end_inset

 много меньше абсолютной точности значения значения 
\begin_inset Formula $b$
\end_inset

.
 Если же проводить вычисление базиса символически, и подставить конкретные
 значения параметров в результат -- точность полученного результата будет
 больше.
\end_layout

\begin_layout Section
Вычисления для борьбы с нулями
\end_layout

\begin_layout Standard
[Символические вычисления, вычисления над конечными полями с полной полиномиальн
ой сигнатурой, теорема из дипломной работы]
\end_layout

\begin_layout Subsection
Борьба с устранимыми нулями
\end_layout

\begin_layout Standard
[Идея Фожера о замене переменных, применение расширенного базиса к задаче
 решения системы; недостатки используемого Фожером подхода с перезапуском
 алгоритма при каждом обнаружении нуля]
\end_layout

\begin_layout Subsection
Использование взвешенного порядка
\end_layout

\begin_layout Standard
[Модификация алгоритма SSG для борьбы с устранимыми нулями путём добавления
 многочленов 
\begin_inset Formula $m_{i}-\varepsilon_{i}$
\end_inset

 с правильными сигнатурными весами]
\end_layout

\begin_layout Section
Заключение
\end_layout

\begin_layout Standard
[Построен алгоритм, позволяющий численно решать системы полиномиальных уравнений
, комбинирующий один из самых эффективных методов вычисления Базисов Грёбнера
 с методиками численной устойчивости]
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "f5_references"
options "gost/ugost2008ns"

\end_inset


\end_layout

\end_body
\end_document
