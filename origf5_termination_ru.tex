%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside,russian]{amsart}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{listings}
\usepackage[a4paper]{geometry}
\geometry{verbose}
\usepackage{color}
\usepackage{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}
\AtBeginDocument{\DeclareFontEncoding{T2A}{}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
  \theoremstyle{remark}
  \newtheorem{claim}[thm]{\protect\claimname}
  \theoremstyle{definition}
  \newtheorem{defn}[thm]{\protect\definitionname}
  \theoremstyle{plain}
  \newtheorem{fact}[thm]{\protect\factname}
  \theoremstyle{definition}
  \newtheorem{example}[thm]{\protect\examplename}
  \theoremstyle{plain}
  \newtheorem{lem}[thm]{\protect\lemmaname}
  \theoremstyle{plain}
  \newtheorem{cor}[thm]{\protect\corollaryname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\Sig}{\mathcal{S}}
\newcommand{\HM}{\mathrm{HM}}
\newcommand{\totaldeg}{\mathrm{deg}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\sigidx}{\mathrm{index}}

\makeatother

  \providecommand{\claimname}{\inputencoding{koi8-r}хФЧЕТЦДЕОЙЕ}
  \providecommand{\corollaryname}{\inputencoding{koi8-r}чЩЧПД}
  \providecommand{\definitionname}{\inputencoding{koi8-r}пРТЕДЕМЕОЙЕ}
  \providecommand{\examplename}{\inputencoding{koi8-r}рТЙНЕТ}
  \providecommand{\factname}{\inputencoding{koi8-r}жБЛФ}
  \providecommand{\lemmaname}{\inputencoding{koi8-r}мЕННБ}
\providecommand{\theoremname}{\inputencoding{koi8-r}фЕПТЕНБ}

\begin{document}

\title{Остановка Алгоритма F5}
\begin{abstract}
Алгоритм F5, предложенный Фожером, принимает в качестве входных данных
произвольное множество однородных многочленов и корректность результата
доказана для всех случаев, когда алгоритм останавливается. Однако
остановка алгоритма за конечное число шагов доказана лишь для случая,
когда на вход алгоритма подаётся регулярная последовательность многочленов.
В этой работе показано, что алгоритм останавливается на любых входных
данных без какого-либо использования регулярности. Схема доказательства
состоит из двух частей: в первой части показано, что если алгоритм
не останавливается, то рано или поздно он получит пару многочленов,
в которой первый может редуцировать второй. При этом, однако, не утверждается,
что такая редукция будет разрешена критериями, предложенными в F5.
Вторая часть показывает, что при существовании такой пары также будет
существовать пара в которой редукция разрешена всеми критериями. Существование
такой пары приводит к противоречию.
\end{abstract}

\author{Василий Галкин}


\address{МГУ}


\email{galkin-vv@ya.ru}

\maketitle

\section{Введение}

Алгоритм Фожера F5 известен как эффективный алгоритм вычисления базисов
Грёбнера, но одной из главных проблем в его практическом использовании
является отсутствие доказательства остановки для всех входных данных.
Первоисточник \cite{FaugereF5} и детальные исследования в \cite{F5-revisited}
показывают остановку алгоритма только для случая отсутствия редукций
к нулю, что с практической точки зрения означает доказательство для
тех случаев, когда входное множество многочленов представлено регулярной
последовательностью. Но для большинства входных последовательностей
их регулярность неизвестна, и доказанного факта оказывается недостаточно
для утверждения остановки реализации алгоритма на конкретных входных
данных. Один из подходов к решению проблемы -- добавление в алгоритм
дополнительных проверок и критериев, гарантирующих остановку алгоритма.
Этот подход даёт строгое доказательство остановки, однако получаемый
результат есть доказательство остановки модифицированной версии F5,
содержащей дополнительные проверки, которая в силу этого может быть
более сложна в реализации или иметь большее время работы на некоторых
входных данных. Этот подход применяется в работах \cite{Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG,Hashemi-ExtF5,ZobninGeneralization}.

Другой подход состоит в доказательстве остановки некоторого семейства
алгоритмов, основанных на идеях F5 с последующей попыткой переформулировать
F5 таким образом, чтоб он являлся представителем этого семейства.
Основная проблема этого подхода появляется в процессе переформулировки:
описание F5 в других терминах может привести к незаметному внесению
различий в поведение алгоритма, которые трудно заметить, но которые
требуют дополнительных рассуждений для доказательства эквивалентности
с F5. К примеру, \cite{2012GrbTermination} доказывает остановку алгоритма
F5GEN, который отличается от исходного F5 отсутствием проверки критериев
при выборе редуктора. Работа \cite{HuangConception} даёт доказательство
остановки алгоритма TRB-F5, который, как удалось осознать автору в
процессе плодотворных дискуссиях с Джоном Перри, имеет два существенных
отличия от F5. Первое отличие -- другая схема построения правил, приводящая
в конце концов к тому, что в процессе выполнения TRB-F5 правила в
массивах $Rule$ оказываются отсортированными по возрастания сигнатуры.
Второе отличие -- отсутствие в TRB-F5 применения оператора нормальной
формы $\varphi$ перед редукцией, что приводит к эффекту противоположному
отличиям F5 от F5GEN: алгоритм TRB-F5 при выборе редуктора проверяет
критерии для элементов с б\'{о}льшими индексами, которые в F5 используются
неявно в операторе нормальной формы и за счёт этого не подвергаются
проверки критериев. Автор полагает, что эти алгоритмы могут быть изменены
таким образом, чтоб в точности повторять поведение алгоритма F5, и
доказательство остановки может быть перенесено на изменённые версии.
Однако подход с алгоритмами, эквивалентными F5 имеет недостаток: он
усложняет понимание того, как теоремы, используемые для доказательства
остановки могут быть сформулированы в терминах поведения исходного
алгоритма F5.

Подход к доказательству остановки, предлагаемый в данной работе, применяется
к F5 без каких-либо модификаций. Первый шаг доказательства основан
на предлагаемой ниже идеи цепей S-пар. Второй шаг основывается на
методе, использованном в теореме 21 работы \cite{F5C} для доказательства
корректности алгоритма F5C: представление S-многочлена в виде суммы
домноженных многочленов из множества, вычисленного F5C может быть
модифицировано последовательностью замен S-пар и их отброшенных частей,
и за конечное число таких шагов приведено к состоянию, когда выполняются
определённые \flqq{}хорошие\frqq{} свойства.

Вторая часть этой статьи показывает, что предусловия этого метода
могут быть ослаблены для его применения к множеству на любом промежуточном
шаге вычислений F5, и что получаемые следствия могут быть усилены
для их использования в доказательстве остановки. Работа оформлена
как альтернативное доказательство остановки для алгоритма, описанного
в статье \cite{FaugereF5}, доступной на сайте её автора, поэтому
читатель предполагается хорошо знакомым с ней. Большинство используемой
терминологии, включая названия этапов алгоритма, взято оттуда.


\section{Потенциально бесконечные циклы в F5}


\subsection{Процедура \texttt{AlgorithmF5}: увеличение $d$}
\begin{claim}
\label{iterations-d_grow}Если при некоторых входных данных цикл \textbf{while}
внутри процедуры \texttt{AlgorithmF5} выполняется бесконечное число
раз, то значение $d$ неограниченно возрастает.\end{claim}
\begin{proof}
Предположим существование последовательности многочленов $\left\{ f_{1},\ldots,f_{m}\right\} $
в кольце $\mathcal{K}[x_{1},\ldots,x_{n}]$ для которой алгоритм F5
не завершается. Без ограничение общности будем считать что это самая
короткая последовательность такого рода -- алгоритм завершается на
более короткой последовательности $\left\{ f_{2},\ldots,f_{m}\right\} $.
Это означает, что не завершается последняя итерация цикла внутри \texttt{incrementalF5},
то есть не завершается последний вызов процедуры \texttt{AlgorithmF5}.
Для исследования данной ситуации необходимо понять, как ведёт себя
значение полной степени $d$ в процессе выполнения цикла внутри процедуры
\texttt{AlgorithmF5}. Обозначим за $d_{j}$ значение $d$ на $j$-ой
итерации цикла и положим $d_{0}=-1$. Простейшее свойство $d_{j}$
-- неубывание: $d_{j}\geqslant d_{j-1}$. Оно выполняется, поскольку
на $j-1$-ой итерации все многочлены в $R_{d}$ имеют степень $d_{j-1}$,
и поэтому все вновь создаваемые критические пары имеют степень не
менее $d_{j-1}$. Предположим теперь, что $j$ фиксированный номер
некоторой итерации. В начале итерации $j$ все критические пары степени
$d_{j}$ извлекаются из $P$. После вызова процедуры \texttt{Reduction}
в $P$ добавляются некоторые новые критические пары в цикле, итерирующем
по $R_{d}$. Существует возможность что некоторые из них будут иметь
полную степень равную $d_{j}$. Нижеследующие рассуждения призваны
показать, что все критические пары такой полной степени будут отброшены
на следующей итерации алгоритма и ни одна из них не породит S-многочлен.

Для каждой из критических пар $[t,u_{1},r_{1},u_{2,}r_{2}]$ порождённых
на итерации $j$ как минимум один из многочленов пары принадлежит
$R_{d}$ и не более чем один многочлен из пары мог принадлежать $G_{i}$
на момент начала итерации. Все многочлены $R_{d}$ генерируются процедурой
\texttt{Reduction} путём добавления по одному многочлену к множеству
$Done$. Поэтому, среди одного или двух многочленов критической пары,
принадлежащих $R_{d}$, мы можем выбрать многочлен $r_{k}$ добавленный
в $Done$ позже. Тогда про другой многочлен S-пары $r_{3-k}$ можно
утверждать, что он уже присутствовал в $G\cup Done$ к моменту добавления
$r_{k}$ в $Done$. Поэтому процедура \texttt{TopReduction} пыталась
редуцировать $r_{k}$ по $r_{3-k}$, но не сделала этого, поскольку
в функции \texttt{IsReducible} одна из проверок (a) - (d) запретила
это.

При этом для критических пар с полной степенью равной $d_{j}$ мы
имеем $u_{k}=1$, поскольку полная степень критической пары равна
полной степени её челна $r_{k}$. Это означает, что значение $u_{3-k}$
равно $\frac{\HM(r_{k})}{\HM(r_{3-k})}$, поэтому в \texttt{IsReducible}
правило (a) разрешает редукцию $r_{k}$ по $r_{3-k}$. Получается,
что только правила (b) - (d) могли запретить редукцию.

Предположим, что редукция была запрещена правилом (b). Это означает,
что в $G_{i+1}$ существует многочлен, редуцирующий $u_{3-k}\Sig(r_{3-k})$.
Для нашего случая отсюда следовало бы, что в функции \texttt{CritPair}
эквивалентная проверка $\varphi(u_{3-k}\Sig(r_{3-k}))=u_{3-k}\Sig(r_{3-k})$
запретила бы создание критической пары. Получается, что правило (b)
также не могло запретить редукцию.

Предположим, что редукция была запрещена правилом (c). Это означает
существование перезаписи для домноженного редуктора. В нашем случае
это значит, что \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
показала наличие перезаписи в процессе выполнения \texttt{TopReduction},
и будет продолжать возвращать значение \flqq{}Истина\frqq{} на всех
последующих этапах алгоритма, поскольку перезаписывающие многочлены
не могут исчезнуть.

Предположим, что редукция была запрещена правилом (d). Псевдокод в
\cite{FaugereF5} несколько неясен в этом месте, но исходный код процедуры
\texttt{FindReductor}, приложенный к \cite{F5-revisited} достаточно
ясен и утверждает, что редуктор отбрасывается, если одновременно моном
и индекс сигнатуры совпадают для редуктора и редуцируемого многочлена
(в коде \texttt{r{[}k0{]}{[}1{]}} -- моном сигнатуры, а \texttt{r{[}k0{]}{[}2{]}}
-- её индекс):

\begin{lstlisting}[basicstyle={\ttfamily},tabsize=4]
if (ut eq r[k0][1]) and (r[j][2] eq r[k0][2]) then
	// discard reductor by criterion (d)
	continue;
end if;
\end{lstlisting}
В нашем случае это обозначает, что сигнатуры $r_{k}$ и $u_{3-k}r_{3-k}$
равны. Значит вызов \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
будет возвращать \flqq{}Истину\frqq{} после добавления правила,
соответствующего $r_{k}$, поскольку $u_{3-k}\cdot r_{3-k}$ перезаписывается
$1\cdot r_{k}$. Получается, что как и в случае с правилом (c), \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
возвращает \flqq{}Истину\frqq{} при выполнении \texttt{TopReduction}
и позже.

Теперь рассмотрим функцию \texttt{Spol}, выполняемую для некоторой
S-пары полной степени $d_{j}$, сгенерированной на итерации $j$.
Она выполняется внутри $j+1$ итерации цикла в \texttt{AlgorithmF5},
то есть уже после того, как закончилось выполнение \texttt{TopReduction}
для $r_{k}$. Поэтому для случаев (c) и (d) вызов \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
внутри \texttt{Spol} вернёт \flqq{}Истину\frqq{}. Значит на итерации
$j+1$ ни одна из S-пар полной степени $d_{j}$ не добавит многочлена
в $F$.

Итого, получено: 
\begin{itemize}
\item первая возможность относительного расположения $d_{j+1}$ и $d_{j}$
-- их равенство: $d_{j+1}=d_{j}$. В этом случае $F$ оказывается
пустым на итерации $j+1$, и, таким образом, $P$ не содержит ни одной
пары с полной степенью $d_{j}$ после того как итерация $j+1$ завершится.
Значит $d_{j+2}>d_{j+1}$. 
\item Другая возможность относительного расположения -- строгое возрастание
$d_{j+1}>d_{j}$.
\end{itemize}
Вместе эти факты дают $\forall j\,\, d_{j+2}>d_{j}$, что доказывает
утверждение \ref{iterations-d_grow}.
\end{proof}

\subsection{Процедура \texttt{Reduction}: конечность $ToDo$}
\begin{claim}
\label{Every_cycle_iteration_finish}Каждая итерация цикла внутри
процедуры \texttt{AlgorithmF5} останавливается, в частности останавливаются
все вызовы процедуры \texttt{Reduction}.\end{claim}
\begin{proof}
Факт остановки известен для вызовов \texttt{AlgorithmF5}, соответствующих
многочленам $f_{2},\dots,f_{m}$, поэтому будет рассматриваться лишь
один оставшийся вызов \texttt{AlgorithmF5}, обрабатывающий первый
элемент входного набора многочленов $f_{1}$. Вначале покажем несколько
общих утверждений о многочленах в множествах $ToDo$ и $Rule$ в процессе
$j$-ой итераций цикла внутри этого вызова \texttt{AlgorithmF5}. Старшая
по сигнатуре часть S-пары всех критических пар, добавляемых функцией
\texttt{CritPair} вначале выполнения \texttt{AlgorithmF5}, обладает
индексом сигнатуры, равным $1$. Все прочие критические пары порождаются
с индексом сигнатуры, соответствующим некоторому отмеченному многочлену,
перемещённому из множества $ToDo$ в множество $Done$. В свою очередь
все элементы $ToDo$ создаются или на основе критических пар или внутри
процедуры \texttt{TopReduction}. Многочлены, генерируемые \texttt{TopReduction}
имеют сигнатуру, превышающую сигнатуру многочлена, который редуцирует
данный вызов процедуры, и который является элементом $ToDo$. Поэтому
многочлен или критическая пара с индексом сигнатуры, отличным от 1
не могут появиться в рассматриваемом вызове \texttt{AlgorithmF5}.
С другой стороны, все многочлены в $ToDo$ имеют одну и ту же полную
степень $d_{j}$. Вместе с единичностью индексов это позволяет заключить,
что полная степень мономов сигнатур равна $d_{j}-\totaldeg(f_{1})$
для всех элементов $ToDo$.

Каждое добавление элемента в массив $Rule$ соответствует добавлению
в множество $ToDo$. Поэтому, элементы добавляемые в $Rule$ на итерации
$j$ имеют полную степень равную $d_{j}$. Вспоминая неубывание $d_{j}$
получаем, что на $j$-ой итерации все элементы $Rule$ с индексом
сигнатуры 1 имеют полную степень $\leqslant d_{j}$ и полную степень
монома сигнатуры $\leqslant d_{j}-\totaldeg(f_{1})$. Также это даёт
информацию о порядке элементов $Rule$ с сигнатурой 1: их полная степень
не убывает.
\begin{defn}
Редукция отмеченного многочлена $r_{k}$ по отмеченному многочлену
$r_{m}$ называется\emph{ сигнатурной редукцией,} если $\Sig(r_{k})\succ t\cdot\Sig(r_{m})$,
где $t=\frac{\HM(r_{k})}{\HM(r_{m})}$ -- моном, на который умножается
редуктор. Редуктор, соответствующий такой редукции называется \emph{сигнатурным
редуктором}. 
\end{defn}
Алгоритм производит только сигнатурные редукции: процедура \texttt{TopReduction}
производит редукцию по неотброшенному редуктору, если он сигнатурный,
и добавляет элемент в $ToDo$ в противном случае. Элементы $ToDo$
обрабатываются в порядке возрастания сигнатур, поэтому ни один из
элементов $G\cup Done$ не может иметь сигнатуры, превышающей сигнатуру
многочлена $r_{k}$, редуцируемого в \texttt{TopReduction}. Рассмотрим
неотброшенный проверками редуктор $r_{m}$. Если он имеет полную степень
$\totaldeg(r_{m})=\totaldeg(r_{k})$, мы получаем свойства $t=1$
и $\Sig(r_{k})\succ\Sig(r_{m})$, гарантирующие что редукция по нему
будет сигнатурной. Случай $\Sig(r_{k})=\Sig(r_{m})$ невозможен, поскольку
такие редукторы отбрасываются в правиле (d) процедуры \texttt{IsReducible}.
Таким образом, ситуация $\Sig(r_{k})\prec t\cdot\Sig(r_{m})$ возможна
только при $\totaldeg(r_{m})<\totaldeg(r_{k})$ и все добавления в
$ToDo$ в процессе \texttt{TopReduction} соответствуют этому случаю.
Моном сигнатуры многочлена, добавляемого таким образом, равен $t\cdot\Sig(r_{m})$
и тот факт что $r_{m}$ не был отброшен проверкой правила \texttt{Rewritten?}
внутри \texttt{IsReducible} гарантирует, что ни одного многочлена
с сигнатурой $t\Sig(r_{m})$ не было порождено, потому что иначе такой
многочлен имел бы связанное с ним правило в $Rule$ с большей полной
степенью, чем правило, соответствующее $r_{m}$, и $r_{m}$ был бы
отброшен в \texttt{IsReducible}. 

Мы хотим показать, что единственная возможность отсутствия остановки
алгоритма соответствует случая неограниченного возрастания $d_{j}$.
Мы показали, что отсутствие остановки алгоритма происходит в случае,
когда не завершается вызов \texttt{AlgorithmF5}, и что он не может
зациклиться обрабатывая бесконечное число итераций итерации с одним
и тем же значением $d$. Остаются два варианта: неограниченное возрастание
$d$ и зацикливание внутри одной из итераций с фиксированным значением.
Далее показано, что такое зацикливание невозможно. Процедура \texttt{AlgorithmF5}
содержит 3 цикла помимо главного:
\begin{itemize}
\item \textbf{for}-цикл внутри \texttt{Spol} завершается, поскольку число
его итераций ограничено числом критических пар к моменту начала выполнения
цикла;
\item \textbf{for}-цикл внутри \texttt{AlgorithmF5} проходит по элементам
$R_{d}$ и также завершается, поскольку число элементов $R_{d}$ зафиксировано
к моменту начала выполнения цикла;
\item наиболее сложный случай соответствует \textbf{while}-циклу внутри
\texttt{процедуры Reduction}, который выполняется до тех пор, пока
множество $ToDo$ не станет пустым. Множество $ToDo$ изначально заполняется
процедурой \texttt{Spol} и потом дополняется новыми элементами в процессе
выполнения \texttt{TopReduction}. Процедура \texttt{Spol} порождает
конечное число элементов, поскольку она завершается, а все элементы
добавляемые \texttt{TopReduction} имеют различные сигнатуры индекса
1, поэтому их число ограничено числом различных сигнатур полной степени
$d_{j}-\totaldeg(f_{1})$, поэтому в $ToDo$ добавляется лишь конечное
число элементов. Теперь мы покажем, что все типы шагов, происходящих
внутри \texttt{Reduction} могут быть выполнены лишь конечное число
раз:

\begin{itemize}
\item шаг, на котором \texttt{IsReducible} возвращает пустое множество,
соответствует переносу элемента множества $ToDo$ в $Done$ и число
таких шагов ограничено числом элементов, добавляемых в $ToDo$
\item шаг, на котором \texttt{IsReducible} возвращает не сигнатурный редуктор,
соответствует добавлению нового элемента в $ToDo$ и число таких шагов
ограничено числом возможных добавлений
\item шаг, на котором \texttt{IsReducible} возвращает сигнатурный редуктор,
соответствует редукции одного из элементов $ToDo$. Это может произойти
лишь конечное число раз, поскольку в $ToDo$ добавляется конечное
число многочленов и не может существовать бесконечной цепочки редукций
для одного многочлена, поскольку в процессе редукции его старший моном
$\HM$ строго $\prec$-убывает, а множество мономов вполне упорядочено
по $\prec$.
\end{itemize}
\end{itemize}
Мы получили, что все циклы внутри процедуры \texttt{AlgorithmF5},
кроме главного, завершаются, что доказывает утверждение \ref{Every_cycle_iteration_finish}.
\end{proof}
Отсюда получается следующий факт о поведении алгоритма в ситуации,
когда он не завершается:
\begin{claim}
\label{d-does-grow}Если алгоритм не завершается на некоторых входных
данных, то значение $d$ неограниченно возрастает в процессе итераций.\end{claim}
\begin{proof}
Следует из комбинирования утверждений \ref{iterations-d_grow} и \ref{Every_cycle_iteration_finish}.
\end{proof}

\section{Цепи S-пар}

Утверждение \ref{d-does-grow} показывает, что в случае отсутствия
остановки работа алгоритма приводит к появлению бесконечной последовательности
ненулевых отмеченных многочленов с неограниченно возрастающей полной
степенью, добавляемых в $G_{i}$. То есть, в этом случае алгоритм
порождает бесконечную последовательность отмеченных многочленов $\left\{ r_{1},r_{2},\ldots,r_{m},\ldots,r_{l},\ldots\right\} $,
в которой $r_{1},\ldots,r_{m}$ соответствуют $m$ исходным многочленам,
а остальные были получены в процедурах \texttt{Spol} и \texttt{TopReduction}.
В обоих случаях новый элемент $r_{l}$ порождается как S-многочлен
двух уже ранее добавленных в последовательность многочленов. Будем
обозначать за $l^{*}$ и $l_{*}$ позиции многочленов, использовавшихся
для генерации $l$-го многочлена последовательности и за $\overline{u_{l}}$,
$\underline{u_{l}}$ мономы, на которые они умножались. При этом $l^{*}$
соответствует части с большей сигнатурой: $\poly(r_{l})=\overline{u_{l}}\poly(r_{l^{*}})-\underline{u_{l}}\poly(r_{l_{*}})$
и $\Sig(r_{l})=\overline{u_{l}}\Sig(r_{l^{*}})\succ\underline{u_{l}}\Sig(r_{l_{*}})$.
Значение $\poly(r_{l})$ может меняться в процедуре \texttt{TopReduction}
на многочлен с меньшим $\HM$, но $\Sig(r_{l})$ нигде далее не меняется
после добавления многочлена в последовательность. Далее, будем пытаться
найти бесконечную подпоследовательность $\left\{ r_{k_{1}},r_{k_{2}},\ldots,r_{k_{n}},\ldots\right\} $
в этой последовательности, обладающую свойством, что $r_{k_{n}}$
является S-многочленом $r_{k_{n-1}}=r_{k_{n}^{*}}$ и некоторого другого
многочлена меньшей сигнатуры. то есть $\Sig(r_{k_{n}})=\overline{u_{k_{n}}}\Sig(r_{k_{n-1}})$
и 
\begin{equation}
\Sig(r_{k_{n-1}})|\Sig(r_{k_{n}}).\label{eq:s-pair-chain-def}
\end{equation}

\begin{defn}
Конечную или бесконечную последовательность, соседние элементы которой
удовлетворяют свойству \ref{eq:s-pair-chain-def} будем называть \emph{цепью
S-пар}.
\end{defn}
Каждый порождаемый многочлен $r_{l}$ имеет конечную цепь S-пар, оканчивающуюся
этим многочленом. Эта цепь может быть последовательно построена, начиная
с последнего элемента$r_{l}$, если на каждом шаге переходить от текущего
многочлена $r_{n}$ к многочлену $r_{n^{*}}$, который использовался
при генерации $r_{n}$ как S-многочлена. Результирующая цепь S-пар
имеет вид $\{r_{q},\ldots,r_{l^{**}},r_{l^{*}},r_{l}\}$, где все
многочлены имеют одинаковый индекс сигнатуры $q=\sigidx(r_{l})$ и
первый элемент является входным многочленом этого индекса.

Первое свойство цепей S-пар основано на критерии перезаписи и заключается
в следующей теореме.
\begin{thm}
Любой отмеченный многочлен может являться начальным элементом лишь
конечного числа различных цепей S-пар длины 2.\end{thm}
\begin{proof}
Алгоритм \texttt{AlgorithmF5} считает S-полиномы в двух местах: процедуре
\texttt{SPol} и процедуре \texttt{TopReduction}. Важно заметить, что
в обоих случаях проверка \texttt{Rewritten?} для части S-полинома
с большей сигнатурой выполняется непосредственно перед созданием S-многочлена.
В первом случае такая проверка производится в самой \texttt{SPol},
а в \texttt{TopReduction} проверка присутствует в вызове \texttt{IsReducible}.
И в обоих случаях получаемый S-многочлен немедленно добавляется в
список $Rule$ последним элементом. Поэтому, в момент построения S-многочлена
с сигнатурой $s$ можно утверждать, что старая часть S-пары соответствует
последнему из правил с сигнатурой, делящей $s$ -- она даже может
быть найдена исходя лишь из списка $Rule$ и сигнатуры $s$ без знания
какой-либо ещё информации об алгоритме.

Рассмотрим произвольный отмеченный многочлен $r_{L}$ с сигнатурой
$\Sig(r_{L})=s$ и упорядоченное по порядку добавления подмножество
$\{r_{l_{1}},\ldots,r_{l_{i}},\ldots\}$ отмеченных многочленов с
сигнатурами удовлетворяющими условию $\Sig(r_{l_{i}})=v_{i}\Sig(r_{L})$.
С точки зрения делимости любая из потенциально бесконечного числа
пар $\{r_{L},r_{l_{i}}\}$ может быть цепью S-пар длины 2. Но идеал
$\left(v_{i}\right)$ в $T$ является конечно порождённым по лемме
Диксона, поэтому после некоторого шага $i_{0}$ будет выполняться$\forall i>i_{0}\,\exists j\leqslant i_{0}$
такое что $v_{j}|v_{i}$. Поэтому при $\forall i>i_{0}$ последовательность
$\{r_{L},r_{l_{i}}\}$ не может являться цепью S-пар, поскольку $\Sig(r_{L})\cdot v_{i}$
перезаписывается $\Sig(r_{l_{j}})\cdot\frac{v_{i}}{v_{j}}$ и существует
не более чем $i_{0}$ цепей S-пар длины 2, начинающихся с многочлена
$r_{L}$.\end{proof}
\begin{defn}
Конечное множество концов цепей S-пар длины 2, начинающихся с $r_{L}$
будет называться \emph{множеством S-порождённых} $r_{L}$.\end{defn}
\begin{thm}
Если алгоритм не останавливается на некоторых входных данных, то он
порождает бесконечную цепь S-пар $\{h_{i}\}$.\end{thm}
\begin{proof}
Поскольку при работе с понятием бесконечности требуется некоторая
строгость, дадим следующее определение.
\begin{defn}
Отмеченный многочлен $r_{l}$ называется \emph{генератором цепи S-пар},
если существует бесконечное множество различных конечных цепей S-пар,
начинающихся с $r_{l}$.
\end{defn}
Если алгоритм не останавливается, то многочлен входного множества
$r_{1}=(f_{1},1F_{1})$ является генератором цепи S-пар, поскольку
каждый многочлен, порождаемый в последнем не завершающемся вызове
\texttt{AlgorithmF5} имеет индекс сигнатуры 1 и является концом цепи
S-пар$\{r_{1},\ldots,r_{l^{**}},r_{l^{*}},r_{l}\}$.

Теперь предположим, что про некоторый отмеченный многочлен $r_{l}$
известно, что он является генератором цепи S-пар. Один из конечного
множества S-порождённых $r_{l}$ также должен являться генератором
цепи S-пар, поскольку в противном случае число различных цепей, исходящих
из $r_{l}$, было бы ограничено конечной суммой конечных количеств
цепей, выходящих из S-порождённых плюс конечным количеством цепей
длины 2, выходящих из $r_{l}$. Поэтому, если отмеченный многочлен
$r_{l}$ является генератором цепи S-пар, среди его S-порождённых
всегда может быть выбран другой генератор цепи S-пар. Таким образом
может быть построена бесконечная цепь S-пар, начинающаяся $r_{1}$
и состоящая из генераторов, что доказывает теорему.
\end{proof}
Для следующей теоремы необходимо ввести порядок на частных, образованных
мономами, путём транзитивного расширения порядка на мономах: $\frac{m_{1}}{m_{2}}>_{q}\frac{m_{3}}{m_{4}}\Leftrightarrow m_{1}m_{4}>m_{3}m_{2}$.
\begin{thm}
\label{thm:f_g_3_props}Если алгоритм не останавливается на некоторых
входных данных, то после некоторого конечного шага множество $G$
содержит пару отмеченных многочленов $f',f$, причём $f$ сгенерирован
после $f'$ и выполняются следующие 3 свойства:

\[
\HM(f')|\HM(f),
\]


\[
\frac{\HM(f')}{\Sig(f')}>_{q}\frac{\HM(f)}{\Sig(f)},
\]


\[
\Sig(f')|\Sig(f).
\]
\end{thm}
\begin{proof}
При работе с цепями S-пар является важным тот факт, что многочлен
никогда не редуцируется дальше, после того как он был использован
для создания S-пары в качестве старей по сигнатуре части. Факт выполняется,
поскольку все многочлены, которые ещё могут быть подвергнуты редукции
находятся в множестве $ToDo$, а все многочлены, используемые как
старшая часть S-пары, находятся в $G$ или в $Done$. Поэтому можно
утверждать, что многочлен $h_{n}$, предшествующий многочлену$h_{n+1}$
в цепи S-пар, сохраняет одно и то же значение $\poly(h_{n})$ после
того как был использован для создания какой-либо S-пары. и можно утверждать,
что
\[
\poly(h_{n+1})=c\frac{\Sig(h_{n+1})}{\Sig(h_{n})}\poly(h_{n})+g_{n},
\]
где $g_{n}$ многочлен, соответствующей младшей части S-пары, использованный
при генерации $h_{n+1}$ из $h_{n}$, и удовлетворяет следующему:
\begin{equation}
\HM(h_{n+1})<\HM\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)=\HM(g_{n}),\,\Sig(h_{n+1})=\Sig\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)\succ\Sig(g_{n}).\label{eq:spair-chain}
\end{equation}
Из первого неравенства в \ref{eq:spair-chain} получаем, что $\frac{\HM(h_{n})}{\Sig(h_{n})}>_{q}\frac{\HM(h_{n+1})}{\Sig(h_{n+1})}$,
поэтому в цепи S-пар частные $\frac{\HM(h_{i})}{\Sig(h_{i})}$ строго
убывают в смысле порядка на частных. Этот факт не может быть напрямую
использован для доказательства конечности цепей, поскольку порядок
на частных, в отличии от порядка на мономах, не даёт вполне упорядоченности:
к примеру последовательность $\frac{x}{x}>_{q}\frac{x}{x^{2}}>_{q}\cdots>_{q}\frac{x}{x^{n}}>_{q}\cdots$
является бесконечно убывающей.

Существует две возможности для отношения между $\HM$ соседних элементов.
Известно, что $\Sig(h_{n})|\Sig(h_{n+1})$, поэтому они или имеют
равные сигнатуры, или $\totaldeg(h_{n})<\totaldeg(h_{n+1})$. В первом
случае $\HM(h_{n+1})<\HM(h_{n})$ при равенстве полной степени, а
во втором -- $\HM(h_{n+1})>\HM(h_{n})$, поскольку полные степени
$\HM$ отличаются. Поэтому, последовательность$\HM$ элементов бесконечной
цепи S-пар состоит из блоков с фиксированной полной степенью, где
$\HM$ внутри блока строго убывают. Длтны блоков могут быть равными
единице, и полные степени блоков возрастают. Это приводит к следующим
свойствам: цепь S-пар $\{h_{i}\}$ не может содержать элементов с
равными $\HM$ и $\HM(h_{i})|\HM(h_{j})$ возможно только в случае
$i<j$ и $\totaldeg(h_{i})<\totaldeg(h_{j})$.

Это позволяет использовать метод аналогичный используемому в Предложении
14 работы \cite{TheF5Revised}: рассмотрим $\HM$ бесконечной цепи
S-пар $\{h_{i}\}$. Они порождают бесконечную последовательность в
$T$, поэтому по лемме Диксона существует два многочлена, с $\HM(h_{i})|\HM(h_{j})$.
Из предыдущего абзаца следует, что при этом $i<j$, а при помощи свойств
цепи S-пар мы получаем, что $\Sig(h_{i})|\Sig(h_{i+1})|\cdots|\Sig(h_{j})$
и $\frac{\HM(h_{i})}{\Sig(h_{i})}>_{q}\frac{\HM(h_{i+1})}{\Sig(h_{i+1})}>_{q}\cdots>_{q}\frac{\HM(h_{j})}{\Sig(h_{j})}$,
поэтому можно взять $f'=h_{i}$ и $f=h_{j}$.
\end{proof}
Последнее свойство о делимости сигнатур из утверждения теоремы является
побочным эффектом от использования цепей S-пар и не используется в
дальнейшем. При этом первые два свойства используются для построения
сигнатурного редуктора.
\begin{fact}
Если никакие многочлены не были отброшены проверками критериев (b)
и (c) в \texttt{IsReducible}, рассматриваемый алгоритм завершается.\end{fact}
\begin{proof}
Данное выше доказательство теоремы \ref{thm:f_g_3_props} не опирается
на соответствие между порядками на сигнатурах и мономах многочленов.
Но алгоритм F5 использует один и тот же порядок в обоих случаях, и
теперь мы можем воспользоваться этим фактом и переформулировать отношение
на частных мономов из теоремы \ref{thm:f_g_3_props} в отношение на
сигнатурах: 
\[
\Sig(f)\succ t\cdot\Sig(f'),\mbox{ где }t=\frac{\HM(f)}{\HM(f')}\in T.
\]
Это неравенство вместе с делимостью $\HM$ из утверждения теоремы
показывает, что $tf'$ является редуктором для $f$ в \texttt{TopReduction}
с точки зрения сигнатуры -- он проходит проверки (a) и (d) внутри
\texttt{IsReducible} и его сигнатура меньше. При отсутствии проверки
критериев (b) и (c) это напрямую приводило бы к противоречию, так
как в момент добавления $f$ в $G$ отмеченный многочлен $f'$ уже
был там и процедура \texttt{TopReduction} должна была бы редуцировать
$f$ по $f'$.
\end{proof}
Но существование критериев делает возможной ситуацию, в которой $tf'$
отбрасывается проверками (b) или (c) процедуры \texttt{IsReducible}.
Идея дальнейших рассуждений состоит в том, чтоб показать что в этом
случае может быть найден другой сигнатурный редуктор $f$, который
не будет отброшен проверками и таким образом прийти к противоречию.
Последующие главы работы посвящены этому.


\section{S-пары с сигнатурами, меньшими $\Sig(g)$}

В этой и последующих частях $g$ подразумевается некоторым фиксированным
многочленом с индексом сигнатуры 1, добавленный на некоторой итерации
алгоритма в $Done$. Мы будем анализировать состояние алгоритма в
момент непосредственно предшествующий добавлению $g$ в $Done$ в
вызове \texttt{AlgorithmF5} с $i=1$. Рассмотрим в этот момент конечное
множество отмеченных многочленов $G_{1}\cup Done$. Оно состоит из
чисел, являющихся позиций отмеченных многочленов в $R$, поэтому его
элементы могут быть упорядочены в соответствии с позицией в $R$ и
оно окажется записанным в виде упорядоченной последовательности целых
чисел $G_{g}=\{b_{1},\ldots,b_{N}\}$ с $b_{j}<b_{j+1}$. Необходимо
отметить, что этот порядок соответствует порядку отмеченных многочленов
в последовательности, получаемой склеиванием массивов правил $Rule[m]:Rule[m-1]:\cdots:Rule[1]$,
поскольку добавление нового многочлена в $R$ всегда сопровождается
добавлением соответствующего правила. Но этот порядок может отличаться
от порядка в котором многочлены добавлялись в множество $G_{1}\cup Done$,
поскольку многочлены одной полной степени добавляются в $Done$ в
порядке возрастания сигнатуры, при том что добавление многочленов
одной полной степени в $R$ производится в довольно случайном порядке
в процедурах \texttt{Spol} и \texttt{TopReduction}. Далее для простоты
мы будем говорить о отмеченных многочленах $b_{j}$ в $G_{g}$, подразумевая
что $G_{g}$ является не упорядоченным списком позиций, а упорядоченным
списком отмеченных многочленов, расположенных на этих позициях. В
этой терминологии можно сказать, что все входные многочлены $\left\{ f_{1},\ldots,f_{m}\right\} $
присутствуют в $G_{g}$, поскольку они присутствуют в $G_{1}$ в момент
его создания.

S-пары могут обрабатываться в алгоритме различным путями, но главный
факт, описывающий порядок их обработки выражается следующими свойствами,
соответствующими свойствам, использованным в Теореме 21 работы \cite{F5C},
но рассматриваются на произвольной итерации алгоритма, а не после
его остановки.
\begin{thm}
\label{thm:Exist-gg-repr}К моменту добавления $g$ в $Done$ каждая
S-пара элементов $G_{g}$, сигнатура которой меньше $\Sig(g)$ удовлетворяет
одному из трёх свойств:\end{thm}
\begin{enumerate}
\item S-пара имеет часть, которая была отброшена критерием проверки нормальной
формы $\varphi$ (в \texttt{CritPair} или в \texttt{IsReducible}).
Такие S-пары будут называться \emph{S-парами с частью, удовлетворяющей
критерию F5}. 
\item S-пара имеет часть, которая была отброшена проверкой \texttt{Rewritten?}
(в \texttt{SPol} или в \texttt{IsReducible}). Такие S-пары будут называться
\emph{S-парами с частью, удовлетворяющей критерию Перезаписи}.
\item S-пара не была отброшена, поэтому её S-многочлен был сигнатурно редуцирован
по некоторым элементам $G_{g}$ и результат был добавлен как элемент
$G_{g}$. Такие S-пары будут называться \emph{S-парами с известным
$G_{g}$-представлением}.\end{enumerate}
\begin{proof}
S-пары элементов $G_{g}$ обрабатываются в алгоритме двумя основными
путями. Основной путь используется для S-пар, полная степень которых
больше чем полная степень породивших их многочленов. Такие S-пары
обрабатываются в следующем порядке:
\begin{itemize}
\item в процедуре \texttt{AlgorithmF5} они рассматриваются функцией \texttt{CritPair}
при перемещении элементов $G_{i}$ из $R_{d}=Done$ и при обработке
входного многочлена $r_{i}$
\item функция \texttt{CritPair} или отбрасывает пару после проверки нормальной
формы $\varphi$ или добавляет пару в $P$
\item S-пара извлекается из $P$ и передаётся в функцию \texttt{SPol}
\item функция \texttt{SPol} или отбрасывает пару после проверки \texttt{Rewritten?}
или добавляет S-многочлен в $F=ToDo$
\item на некоторой итерации процедура \texttt{Reduction} берёт S-многочлен
из $ToDo$, производит некоторые сигнатурные редукции и добавляет
результат в $Done$.
\end{itemize}
Второй путь обработки используется для S-пар, соответствующих редукциям,
запрещённым алгоритмом -- соответствующие S-пары порождаются многочленами
$r_{l^{*}}$ и $r_{l_{*}}$, такими что $\HM(r_{l^{*}})|\HM(r_{l_{*}})$,
и S-многочлен им соответствующий имеет вид $\overline{u_{l}}\cdot\poly(r_{l^{*}})-1\cdot\poly(r_{l_{*}})$.
Такая ситуация возможна, если для элементов $G_{g}$ редукция $r_{l_{*}}$
по $r_{l^{*}}$ была запрещена сравнением сигнатур в \texttt{TopReduction}
или проверками в \texttt{IsReducible}. Для этого случая порядок \flqq{}обработки\frqq{}
S-пары такой:
\begin{itemize}
\item часть S-пары $\overline{u_{l}}\cdot r_{l^{*}}$ проверяется в \texttt{IsReducible}.
(a) выполнено, поскольку $\HM(r_{l^{*}})|\HM(r_{l_{*}})$. Она может
быть отброшена другими проверками:

\begin{itemize}
\item отбрасывание пунктом (b) соответствует проверке нормальной формы $\varphi$
для $\overline{u_{l}}\cdot r_{l^{*}}$
\item отбрасывание пунктом (c) соответствует проверке \texttt{Rewritten?}
для $\overline{u_{l}}\cdot r_{l^{*}}$
\item отбрасывание пунктом (d) означает, что один из многочленов $\overline{u_{l}}\cdot r_{l^{*}}$
и $1\cdot r_{l_{*}}$ может быть перезаписано другим, поэтому, если
S-пара не была отброшена проверкой (c), данный тип отбрасывания означает,
что часть S-пары $1\cdot r_{i_{1}}$ не проходит проверку \texttt{Rewritten?}
\end{itemize}
\item S-пары, не отброшенные в \texttt{IsReducible} возвращаются в \texttt{TopReduction}.
Сравнение сигнатур в \texttt{TopReduction} запрещает редукцию $r_{l_{*}}$
по $r_{l^{*}}$ и помещает вычисленный S-многочлен, соответствующий
S-паре, в множество $ToDo_{1}$
\item процедура \texttt{Reduction} добавляет этот многочлен в $ToDo$
\item последний шаг совпадает для обоих путей обработки S-пар: на некоторой
итерации процедура \texttt{Reduction} берёт S-многочлен из $ToDo$,
производит некоторые сигнатурные редукции и добавляет результат в
$Done$.
\end{itemize}
Из путей обработки S-пар видно, что после окончания обработки каждая
S-пара или редуцирована и добавлена в $Done$ или одна из частей S-пары
была отброшена проверкой нормальной формы $\varphi$ или критерием
\texttt{Rewritten?}. Некоторые S-пары могут оказываться на путях обработки
несколько раз, к примеру это происходит на итерации в \texttt{AlgorithmF5}
со значением $d$, не изменившимся с прошлой итерации. Если S-пара
была отброшена при первой попытке обработки, то она будет точно также
отброшена и на следующей попытке. Если первая обработка добавила редуцированный
многочлен в $Done$, то пара будет отбрасываться при следующих попытках
обработки проверкой\texttt{ Rewritten?} за счёт этого многочлена.
Поэтому все попытки обработки, кроме первой, не дают ничего нового.

Путь обработки не является одной процедурой, и в случае, если алгоритм
не останавливается, некоторые S-пары всегда находятся в середине обработки,
при этом или соответствующая S-пара находится в очереди $P$ или S-многочлен
в очереди $ToDo$. Поэтому необходимо понять, обработка каких S-пар
уже завершилась в рассматриваемый нами момент. Элементы $P$ и $ToDo$
извлекаются в процедурах \texttt{AlgorithmF5} и \texttt{Reduction}
в порядке возрастания сигнатур. S-пары с сигнатурами, меньшими $\Sig(g)$,
могут быть разделены на 3 класса:
\begin{itemize}
\item S-пары с сигнатурой $w$, такой что $\sigidx(w)>\sigidx(\Sig(g))=1$.
Они обрабатывались на предыдущих вызовах \texttt{AlgorithmF5}.
\item S-пары с сигнатурой $w$, такой что $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)<\totaldeg(\Sig(g))$.
Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
\texttt{AlgorithmF5}, который обрабатывает $g$.
\item S-пары с сигнатурой $w$, такой что $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)=\totaldeg(\Sig(g)),w\prec\Sig(g)$.
Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
\texttt{Reduce}, который обрабатывает $g$.
\end{itemize}
S-пары из этих классов не могут находиться в середине пути обработки,
потому что в рассматриваемом состоянии алгоритма обработка только
что завершена для $g$, поэтому ни $P$ ни $ToDo$ не содержат необработанных
элементов с сигнатурами, меньшими $\Sig(g)$. Осталось показать, что
для всех S-пар из утверждения теоремы обработка начиналась хотя бы
один раз. Это просто проверить для первых двух классов: обработка
соответствующих S-пар была начата по крайней мере один раз путём вызова
\texttt{CritPair} в \texttt{AlgorithmF5} непосредственно перед тем,
как наибольший из порождающих S-пару был добавлен в $G$. Для S-пар
третьего класса ситуация зависит от полной степени её порождающих.
Если оба порождающих S-пары имеют полную степень $<\totaldeg(g)$,
то её обработка была начата в \texttt{CritPair} аналогично S-парам
первых двух классов. Но некоторые S-пары третьего класса могут иметь
старший по сигнатуре порождающий $r_{l}$, такой что $\totaldeg(r_{l})=\totaldeg(g),\,\Sig(r_{l})\prec\Sig(g)$.
Они обрабатываются вторым из рассмотренных путей обработки S-пар,
поэтому обработка таких S-пар ещё не стартовала к моменту последнего
вызова \texttt{Reduction}. Однако, их обработка начинается внутри
\texttt{Reduction} до изучаемого нами момента: процедура выбирает
многочлены из $ToDo$ в порядке возрастания сигнатуры, поэтому $r_{l}$
редуцируется до $g$ и в процессе редукции $r_{l}$ непосредственно
перед добавлением $r_{l}$ в $Done$ вызов \texttt{TopReduction} начинает
обработку всех таких S-пар.
\end{proof}
Понятие \emph{удовлетворять критерию F5 }и \emph{удовлетворять критерию
Перезаписи} могут быть расширены но произвольные умноженные на моном
отмеченные многочлены $sh,\, h\in G_{g}$:
\begin{defn}
Умноженный на моном отмеченный многочлен  $sr_{i},\, r_{i}\in G_{g}$
называется \emph{удовлетворяющим критерию F5}, если $\varphi_{index(r_{i})+1}(s\Sig(r_{i}))\ne s\Sig(r_{i})$,
где $\varphi_{index(r_{i})+1}$ -- оператор нормальной формы по отношению
к $G_{index(r_{i})+1}$.
\end{defn}
Это определение эквивалентно тому, что $sr_{i}$ является не-нормализованным
отмеченным многочленом с точки зрения определения 2 в части 5 работы
\cite{FaugereF5}.
\begin{defn}
Умноженный на моном отмеченный многочлен $sr_{i},\, r_{i}\in G_{g}$
называется \emph{удовлетворяющим критерию Перезаписи}, если $\exists j>i$
такое что $\Sig(r_{j})|s\Sig(r_{i})$.
\end{defn}
В случае, если $sr_{i}$ является частью S-пары, эти определения эквиваленты
проверкам, производимым в алгоритме, в том смысле, что часть S-пары
отбрасывается алгоритмом тогда и только тогда, когда она удовлетворяет
данному определению как умноженный на моном отмеченный многочлен.
Для обоих критериев выполняется важное свойство, утверждающее, что
если $sr_{i}$ удовлетворяет критерию, то то и дополнительно домноженный
многочлен $s_{1}sr_{i}$ также ему удовлетворяет.


\section{Представления}


\subsection{Определение}

Идея представлений, определённых ниже, приходит из \cite{F5C}, где
подобный метод используется в доказательстве Теоремы 21. Представления
используются для описания способов, которыми многочлен $p$ может
быть записан как элемент идеала $\left(G_{g}\right)$. Одно представление
соответствует записи отмеченного многочлена $p$ в виде конечной суммы
вида
\begin{equation}
p=\sum_{k}m_{k}\cdot b_{i_{k}},\; b_{i_{k}}\in G_{g}\label{eq:Gg-repr-def}
\end{equation}
с коэффициентами $m_{k}=c_{k}t_{k}\in\mathcal{K}\times T$. 
\begin{defn}
Сумма вида \ref{eq:Gg-repr-def}, в которой все пары $\left(t_{k},b_{i_{k}}\right)$
различны, называется \emph{$G_{g}$-представлением} $p$. Символические
произведения $m_{k}\cdot b_{i_{k}}$ называются \emph{элементами}
представления. Если рассмотреть это символическое произведение как
умножение многочленов, то мы получим отмеченный многочлен $m_{k}b_{i_{k}}$,
соответствующий элементу представления. Тогда $p$ оказывается равным
сумме отмеченных многочленов, соответствующих элементам его представления.
Понятие \emph{сигнатура элемента} будет использоваться для обозначения
сигнатура многочлена, соответствующего элементу. Два представления
равны, если наборы их элементов совпадают как множества.
\end{defn}
Большинство представлений, которые будут нам интересны также имеют
следующее свойство, ограничивающее сигнатуру элементов:
\begin{defn}
$G_{g}$-представление $p$ называется \emph{сигнатурным}, если $\forall k\,\Sig(m_{k}b_{i_{k}})\preccurlyeq\Sig(p)$.
\end{defn}

\subsection{Примеры}
\begin{example}
Первый важный пример $G_{g}$-представления тривиален: отмеченный
многочлен из $G_{g}$ равен сумме одного слагаемого -- самого себя
с единичным коэффициентом: 
\[
b_{j}=1\cdot b_{j}.
\]

\end{example}
Это $G_{g}$-представление сигнатурно. Запрет на наличие в представлении
нескольких элементов, имеющих одинаковый моном $t_{k}$ и многочлен
$b_{i_{k}}$ гарантирует, что все элементы представления, отличающиеся
только коэффициентом из поля $c_{k}$ скомбинированы вместе путём
суммирования коэффициентов из поля. Поэтому выражения вида $b_{j}=-1\cdot b_{j}+2\cdot b_{j}$
и $b_{j}=2x\cdot b_{k}+1\cdot b_{j}-2x\cdot b_{k}$ не являются корректными
$G_{g}$-представлениями.
\begin{example}
Отмеченный многочлен $b_{j}\in G_{g}$, домноженный на произвольный
многочлен $h$ также имеет простое $G_{g}$-представление, получающееся
из записи $h$ в виде суммы термов: $h=\sum_{k}m_{k},\, m_{k}\in\mathcal{K}\times T$.
Это $G_{g}$-представление имеет форму 
\begin{equation}
b_{j}h=\sum_{k}m_{k}\cdot b_{j}\label{eq:repr-ex-2}
\end{equation}
и также является сигнатурным.
\end{example}
Отмеченный многочлен может иметь бесконечное множество различных представлений:
к любому представлению можно добавить элементы, соответствующие сизигии,
сгруппировать элементы с одновременно равными мономами и многочленами
и получить другое корректное представление. Это будет представление
того же многочлена, поскольку сумма многочленов, соответствующих элементам
сизигии равна 0.
\begin{example}
Произведение двух многочленов из $G_{g}$ имеет 2 представления вида
\eqref{eq:repr-ex-2}, которые отличаются прибавлением сизигии:
\end{example}
\[
b_{j}b_{i}=\sum_{k}m_{i_{k}}\cdot b_{j}=\sum_{k}m_{i_{k}}\cdot b_{j}+0=\sum_{k}m_{i_{k}}\cdot b_{j}+\left(\sum_{k}m_{j_{k}}\cdot b_{i}-\sum_{k}m_{i_{k}}\cdot b_{j}\right)=\sum_{k}m_{j_{k}}\cdot b_{i},
\]
где $m_{i_{k}}$ -- термы $b_{i}$, а $m_{j_{k}}$ -- термы $b_{j}$.
\begin{example}
Нулевой многочлен имеет пустое представление и представление, соответствующее
каждой сизигии:
\end{example}
\[
0=\sum_{\emptyset}\mbox{(empty sum)}=\sum_{k}m_{j_{k}}\cdot b_{i}+\sum_{k}(-m_{i_{k}})\cdot b_{j},
\]
где $m_{i_{k}}$ и $m_{j_{k}}$ взяты из предыдущего примера. Все
непустые представления нулевого многочлена не сигнатурны.

Другой важный пример $G_{g}$-представлений получается из определений
сигнатуры и идеала. Все отмеченные многочлены, вычисляемые алгоритмом,
принадлежат идеалу $\left(f_{1},\ldots,f_{m}\right)$. Поэтому любой
отмеченный многочлен $p$ может быть записан в виде $ $$\sum_{i}f_{i}g_{i}$,
где $g_{i}$ -- однородные многочлены. Все входные многочлены $f_{i}$
принадлежат $G_{g}$, поэтому $f_{i}g_{i}$ имеют $G_{g}$-представления
вида \eqref{eq:repr-ex-2}.
\begin{example}
Сумма этих представлений даёт следующее сигнатурное представление:
\[
p=\sum_{k}m_{k}\cdot b_{i_{k}},\, m_{k}\in\mathcal{K}\times T,\, b_{i_{k}}\in\left\{ f_{1},\ldots,f_{m}\right\} \subset G_{g}.
\]
\end{example}
\begin{defn}
Частный случай $G_{g}$-представления, при котором $b_{i_{k}}$ ограничены
лишь входными многочленами, будет называться \emph{входным представлением}.
\end{defn}
Входные представления всегда имеют единственный элемент максимальной
сигнатуры. Произвольные $G_{g}$-представления не всегда обладают
этим свойством, поскольку могут иметь несколько разных элементов с
одинаковой максимальной сигнатурой, так как для них возможна ситуация
$m_{1}\Sig(b_{i_{1}})=m_{2}\Sig(b_{i_{2}})$ при $i_{1}\ne i_{2}$.

Следующее утверждение устанавливает связь между входными представлениями
и понятием сигнатуры:
\begin{claim}
Допустимый отмеченный многочлен $p$ с известной сигнатурой $\Sig(p)$
имеет входное представление, состоящее из элемента $c\Sig(p)\cdot f_{index(p)}$
и некоторых других элементов с меньшими сигнатурами.\end{claim}
\begin{proof}
Утверждение вытекает из определения допустимого многочлена в \cite{FaugereF5},
ссылающегося на функцию $v$, которая соответствует суммированию элементов
входного представления.
\end{proof}
Теорема 1 из \cite{FaugereF5} утверждает, что все многочлены, порождаемые
алгоритмом, допустимы, поэтому мы будем применять предыдущее утверждение
ко всем таким многочленам.
\begin{example}
\label{example-of-having-gg-repr}Последний пример восходит к S-парам
с известным $G_{g}$-представлением. S-многочлен, порождённый $b_{l^{*}}$
и $b_{l_{*}}$ из $G_{g}$, имеет вид $p=\overline{u_{l}}\poly(b_{l^{*}})-\underline{u_{l}}\poly(b_{l_{*}})$.
Из процесса редукции вытекает, что $p$ сигнатурно редуцируется и
результат добавляется в $G_{g}$ как некоторый отмеченный многочлен
$b_{l}$. Отсюда его $G_{g}$-представление имеет вид:
\end{example}
\[
p=\sum_{k}m_{k}\cdot b_{n_{k}}+1\cdot b_{l},
\]
где сигнатуры элементов $m_{k}\cdot b_{n_{k}}$ меньше чем $\Sig(b_{l})=\Sig(p)$.
Значение $l$ -- позиция $b_{l}$ в упорядоченном списке $G_{g}$.
В данном представлении $l$ больше чем $l^{*}$ и $l_{*}$, поскольку
соответствующий отмеченный многочлен $b_{l}$ был добавлен в $R$
в момент подсчёта S-многочлена в процедурах \texttt{Spol} или \texttt{TopReduction},
поэтому многочлены $b_{l^{*}}$ и $b_{l_{*}}$, использованные для
его создания не отброшенной S-пары, уже присутствовали в $R$ к тому
моменту, а порядок $G_{g}$ соответствует порядку добавления элементов
в $R$.


\subsection{Порядок на представлениях}
\begin{defn}
Для введения порядка на $G_{g}$-представлениях мы начнём с \emph{порядка
на элементах представления} $\gtrdot_{1}$: будем говорить, что $c_{i}t_{i}\cdot b_{i}\gtrdot_{1}c_{j}t_{j}\cdot b_{j}$
если выполняется один из следующих случаев:
\begin{itemize}
\item $t_{i}\Sig(b_{i})\succ t_{j}\Sig(b_{j})$ 
\item $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$ и $i<j$ (сравнение позиций --
в обратную сторону).
\end{itemize}
\end{defn}
Этот порядок основан лишь на сравнение сигнатур и позиций отмеченных
многочленов в упорядоченном списке $G_{g}$, но не зависит от коэффициента
из поля. Единственный случай, в котором два элемента не могут быть
упорядочены -- одновременное равенство сигнатур $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
и позиций в списке $i=j$. Равенство позиций означает равенство многочленов
$b_{i}=b_{j}$, что вместе с равенством сигнатур даёт $t_{i}=t_{j}$.
Поэтому любые два элемента, принадлежащие одному корректному $G_{g}$представлению
являются сравнимыми с точки зрения порядка $\lessdot_{1}$, поскольку
они имеют различные $\left(t_{k},b_{k}\right)$ по определению. Ниже
приведены некоторые примеры сравнений элементов по $\lessdot_{1}$
для списка $G_{g}=\left\{ b_{1},\, b_{2},\, b_{3}\right\} $ из 3-х
элементов с порядком на сигнатурах $x\mathbf{F}_{i}\succ y\mathbf{F}_{i}$
и сигнатурами $\Sig(b_{1})=\mathbf{F}_{1},\Sig(b_{2})=\mathbf{F}_{2},\Sig(b_{3})=x\mathbf{F}_{1}$.
\begin{itemize}
\item $y\cdot b_{1}\gtrdot_{1}100y\cdot b_{2}$ поскольку сигнатура левой
части  $\succ$
\item $x\cdot b_{1}\gtrdot_{1}y\cdot b_{1}$ поскольку сигнатура левой части
$\succ$
\item $-x\cdot b_{1}$ и $2x\cdot b_{1}$ не сравнимы, поскольку сигнатуры
и позиции в списке равны
\item $y^{2}\cdot b_{1}\lessdot_{1}y\cdot b_{3}$ поскольку сигнатура левой
части $\prec$
\item $x^{2}\cdot b_{1}\gtrdot_{1}x\cdot b_{3}$ поскольку сигнатуры равны,
а позиция в списке отмеченного многочлена левой части равна 1, что
меньше чем позиция многочлена правой части, равная 3.
\end{itemize}
Для расширения этого порядка на $G_{g}$-представления целиком будем
рассматривать \emph{упорядоченную форму} представления, состоящую
из всех его элементов, записанных в $\gtrdot_{1}$-убывающий список.
Эта форма может быть использована для проверки на равенство, поскольку
представления равны тогда и только тогда, когда равны их упорядоченные
формы.
\begin{defn}
При помощи упорядоченных форм введём \emph{порядок на $G_{g}$-представлениях}:
представление $\sum_{k}m'_{k}\cdot b_{i'_{k}}$ является $\lessdot$-меньшим,
чем $\sum_{k}m_{k}\cdot b_{i_{k}}$, если упорядоченные формы для
первого и второго представления удовлетворяют лексикографически расширенному
на формы отношению $\lessdot_{1}$. Для особого случая, когда упорядоченные
формы отличаются лишь длиной, более короткая форма будет называться
$\lessdot$-меньшей. Если наибольшие различные элементы в упорядоченных
формах двух представлений отличаются лишь коэффициентов поля, то представления
являются не сравнимыми.
\end{defn}
Далее даны некоторые примеры этого порядка для того же, трёх-элементного
списка $G_{g}$. Все $G_{g}$-представления записаны в упорядоченных
формах:
\begin{itemize}
\item $x^{2}\cdot b_{1}+xy\cdot b_{1}+y^{2}b_{1}\gtrdot x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}$
поскольку $xy\cdot b_{1}\gtrdot_{1}y^{2}\cdot b_{1}$
\item $x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}\gtrdot x^{2}\cdot b_{1}$ поскольку
правая часть является началом левой
\item $x^{2}\cdot b_{1}\gtrdot xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
поскольку $x^{2}\cdot b_{1}\gtrdot_{1}xy\cdot b_{1}$
\item $xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}\gtrdot y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
поскольку $xy\cdot b_{1}\gtrdot_{1}y\cdot b_{3}$
\item $y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$ и $2y\cdot b_{3}+y^{2}\cdot b_{2}$
не сравнимы, поскольку наибольшие различные элементы -- это $y\cdot b_{3}$
и $2y\cdot b_{3}$.
\end{itemize}
Порядок на представлениях совместим с понятием сигнатурности представления:
\begin{thm}
Если для пары представлений отмеченного многочлена $p$ выполняется
отношение $\sum_{k}m'_{k}\cdot b_{i'_{k}}\lessdot\sum_{k}m_{k}\cdot b_{i_{k}}$
и правое представление сигнатурно, то и левое представление сигнатурно.\end{thm}
\begin{proof}
Теорема легко следует из того, что сигнатуры элементов $\lessdot$-меньшего
представления не могут быть $\succ$-больше, чем максимальная сигнатура
$\gtrdot$-большего представления.
\end{proof}
Важным фактом, позволяющим брать $\lessdot$-минимальный элемент,
является вполне упорядоченность:
\begin{thm}
Представление вполне упорядочены порядком $\lessdot$.\end{thm}
\begin{proof}
Количество различных отмеченных многочленов, входящих в элементы представления,
конечно, поскольку оно равно $|G_{g}|$ для некоторого фиксированного
$g$. Поэтому существование бесконечной $\gtrdot_{1}$-убывающей последовательности
элементов представлений привело бы к существованию бесконечной $\succ$-убывающей
последовательности сигнатур. Учитывая вполне упорядоченность сигнатур
по $\prec$ мы получаем доказательство мы получаем доказательство
вполне упорядоченности элементов представлений по $\lessdot{}_{1}$.

Прямое доказательство вполне упорядоченности представлений по $\lessdot$
на основе вполне упорядоченности их элементов по $\lessdot_{1}$ не
является очень сложным, однако дабы не вдаваться в детали, используем
теорему 2.5.5 книги \cite{Baader.Nipkow98Term}. Она утверждает вполне
упорядоченность конечных наборов с порядком, являющимся лексикографическим
расширением порядка на элементах набора. Это применимо к предмтавлениямм,
так как они являются наборами своих элементов.
\end{proof}

\subsection{Последовательность представлений}

Идея этой части состоит в построении конечной последовательности строго
$\lessdot$-убывающих сигнатурных $G_{g}$-представлений для некоторого
отмеченного многочлена $mh,\, m\in\mathcal{K}\times T,\, h\in G_{g}$
со свойством $\Sig(mh)\prec\Sig(g)$. Первым сигнатурным представлением
в последовательности является $mh=m\cdot h$, а последнее представление
имеет вид $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ со свойствами, выполняющимися
для $\forall k$:
\begin{enumerate}
\item $m_{k}b_{i_{k}}$ не удовлетворяет критерию F5.
\item $m_{k}b_{i_{k}}$ не удовлетворяет критерию Перезаписи.
\item $\HM(m_{k}b_{i_{k}})\leqslant\HM(mh)$
\end{enumerate}
Доказательство существования такой последовательности довольно похоже
на доказательство Теоремы 21 из \cite{F5C} и основано на том, что
если некоторое сигнатурное представление $mh$ содержит не удовлетворяющий
одному из свойств элемент $m_{K}\cdot b_{i_{K}}$, то может быть найдено
$\lessdot$-меньшее представление. Метод построения отличается для
разных свойств, однако схема замены одинакова:
\begin{itemize}
\item выбирается некоторый элемент $m_{K'}\cdot b_{i_{K'}}$ в представлении
$mh$. Следует отметить, что $K'$ может как совпадать, так и отличаться
от $K$
\item строится некоторое представление $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
для этого элемента
\item показывается, что построенное представление $\lessdot$-меньше, чем
представление $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$ 
\end{itemize}
Построение такого представления для $m_{K'}\cdot b_{i_{K'}}$ позволяет
применить следующую лемму:
\begin{lem}
Если элемент $m_{K'}\cdot b_{i_{K'}}$ сигнатурного представления
$mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ имеет представление $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$,
$\lessdot$-меньшее чем представление $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$,
то $mh$ имеет сигнатурное представление, $\lessdot$-меньшее, чем
$mh=\sum_{k}m_{k}\cdot b_{i_{k}}$.\end{lem}
\begin{proof}
Заменим элемент $m_{K'}\cdot b_{i_{K'}}$ в представлении $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
на $\sum_{l}m_{l}\cdot b_{i_{l}}$ и скомбинируем коэффициенты при
элементах с одновременно одинаковыми мономами и многочленами, получив
таким образом изменённое представления для $mh$. Оно будет $\lessdot$-меньше,
чем $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ поскольку: все элементы $\gtrdot_{1}$-большие
$m_{K'}\cdot b_{i_{K'}}$ идентичны в исходном и изменённом представлениях;
элемент $m_{K'}\cdot b_{i_{K'}}$ содержится в исходном, но не в изменённом
представлении; все остальные элементы в представлениях являются $\lessdot_{1}$-меньшими,
чем $m_{K'}\cdot b_{i_{K'}}$ поэтому они не играют роли при сравнении.
Сравнение выполняется даже в случае, когда при комбинировании коэффициентов
все элементы обнулились. Этот случай может возникнуть, если исходное
представление было равно $mh=m_{K'}\cdot b_{i_{K'}}+\sum_{l}(-m_{l})\cdot b_{i_{l}}$,
что привело к изменённому представлению вообще не содержащему элементов:
$mh=0$. Оно является $\lessdot$-меньшим, чем любое непустое представление.
\end{proof}
Теперь покажем, что представление элемента по вышеуказанной схеме
может быть построено, если исходное представление содержит элемент,
не удовлетворяющий по крайней мере одному из свойств.
\begin{lem}
Если сигнатурное $G_{g}$-представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
содержит элемент, не удовлетворяющий свойству 1, то найдётся элемент
$m_{K'}\cdot b_{i_{K'}}$ обладающий $G_{g}$-представлением $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
$\lessdot$-меньшим, чем представление $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$.
\end{lem}
Элемент, не обладающий первым свойством, удовлетворяет критерию F5,
что позволяет позволяет использовать соображение о том, что $m_{K}\Sig(b_{i_{K}})$
не является его сигнатурой $m_{K}b_{i_{K}}$ аналогично теореме 20
работы \cite{F5C}. Для этого случая берётся $K'=K$.
\begin{proof}
Рассмотрим входное представление $m_{K}b_{i_{K}}$ с сигнатурой $\gtrdot_{1}$-максимального
элемента, равной $m_{K}\Sig(b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$:

\begin{equation}
m_{K}b_{i_{K}}=c_{0}s_{0}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.\label{eq:input-repr-case1}
\end{equation}
Из удовлетворения критерия F5 следует, что $s_{0}$ может быть представлено
как $s_{0}=s_{1}\HM(f_{j_{1}}),\, j_{1}>j_{0}$, откуда $s_{0}f_{j_{0}}=s_{1}f_{j_{0}}f_{j_{1}}-s_{1}(f_{j_{1}}-\HM(f_{j_{1}}))f_{j_{0}}$.
На основе этого выражения можно получить другое представление для
$m_{K}b_{i_{K}}$, обозначая за $m_{0i}$ упорядоченные термы $f_{j_{0}}$,
за $m_{1i}$ -- упорядоченные термы $f_{j_{1}}$ и за $N_{0,}N_{1}$
число термов в этих многочленах:

\[
m_{K}b_{i_{K}}=\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}+\sum_{i=2}^{N_{1}}-c_{0}s_{1}m_{1i}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.
\]
Это представление $\lessdot$-меньше, чем $m_{K}\cdot b_{i_{K}}$
поскольку сигнатуры всех его элементов меньше чем $s_{0}\mathbf{F}_{j_{0}}$.
Для элементов третьей суммы $\sum_{l}m_{l}\cdot f_{i_{l}}$ это следует
из \textbf{\eqref{eq:input-repr-case1}}, где эти элементы являются
меньшими элементами входного представления. Для элементов первой суммы
$\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}$ это следует из
неравенства индексов сигнатур $j_{1}>j_{0}$. А для второй суммы используем
совпадение порядка на сигнатурах и на термах: все термы $m_{1i},\, i\geqslant2$
меньше, чем $m_{11}$, поэтому и выполняется неравенство для сигнатур:
$s_{1}m_{1i}\mathbf{F}_{j_{0}}\prec s_{1}m_{11}\mathbf{F}_{j_{0}}=s_{0}\mathbf{F}_{j_{0}}$. \end{proof}
\begin{lem}
Если сигнатурное $G_{g}$-представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
с $\Sig(mh)\prec\Sig(g)$ содержит элемент, не удовлетворяющий свойству
2, то найдётся элемент $m_{K'}\cdot b_{i_{K'}}$ обладающий $G_{g}$-представлением
$m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$ $\lessdot$-меньшим,
чем представление $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$\textup{.}
\end{lem}
Для элементов, не удовлетворяющих критерию Перезаписи $\lessdot$-меньшее
представление сроится методом, аналогичным Предложению 17 из \cite{F5C}.
В этом случае также берётся $K'=K$.
\begin{proof}
Предположим, что сигнатура $\Sig(m_{K}b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$
и она перезаписывается отмеченным многочленом $b_{i'}$ из $R$. Поскольку
представление сигнатурно, мы имеем $\Sig(b_{i'})\preccurlyeq s_{0}\mathbf{F}_{j_{0}}\preccurlyeq\Sig(mh)\prec\Sig(g)$.
Поэтому $b_{i'}$ обрабатывался в процедуре \texttt{TopReduction}
раньше $g$. Значит $b_{i'}$ был редуцирован и результат его редукции
или был нулевым или присутствует в $G_{g}$, поэтому он может использоваться
как многочлен элемента $G_{g}$-представления. Из критерия Перезаписи
известно, что $i'>i_{K}$ и существует $s'\in T$, такое что $s'\Sig(b_{i'})=s_{0}\mathbf{F}_{j_{0}}$.
Для $m_{K}b_{i_{K}}$ есть входное представление \eqref{eq:input-repr-case1}
а для $s'b_{i'}$ входным представлением является:

\[
s'b_{i'}=c's_{0}\cdot f_{j_{0}}+\sum_{l'}m_{l'}\cdot f_{i_{l'}}.
\]
Преобразованием этого выражения получим $G_{g}$-представление для
$c_{0}s_{0}f_{j_{0}}$:

\[
c_{0}s_{0}f_{j_{0}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}.
\]
Используя его для замены первого элемента в \eqref{eq:input-repr-case1}
получим желаемый результат:
\[
m_{K}b_{i_{K}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}+\sum_{l}m_{l}\cdot f_{i_{l}}
\]
Он $\lessdot$-меньше, чем $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$
поскольку элементы обоих сумм имеют сигнатуры, меньшие $s_{0}\mathbf{F}_{j_{0}}$,
а для первого элемента, если $b_{i'}$ не нулевой, имеем $\Sig(c'^{-1}c_{0}s'\cdot b_{i'})=\Sig(m_{K}\cdot b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$
с $i'>i_{K}$, откуда применяя правило $\lessdot_{1}$-сравнения для
равных сигнатур и различных позиций в списке, получаем, что элемент
$c'^{-1}c_{0}s'\cdot b_{i'}$ также $\lessdot_{1}$-меньше, чем$m_{K}\cdot b_{i_{K}}$.
Если же $b_{i'}=0$, то он отбрасывается, и желаемое представление
состоит только из оставшихся 2-х сумм.\end{proof}
\begin{lem}
Если все элементы сигнатурного представления $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
с $\Sig(mh)\prec\Sig(g)$ удовлетворяют свойствам 1 и 2, но один из
них не удовлетворяет свойству 3, то найдётся элемент $m_{K'}\cdot b_{i_{K'}}$,
имеющий представление $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
$\lessdot$-меньшее, чем представление $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$.\end{lem}
\begin{proof}
Существует по крайней мере один элемент $m_{K}\cdot b_{i_{K}}$, не
удовлетворяющий свойству 3. Обозначим за $m_{\max}$ максимальный
$\HM$ отмеченных многочленов, соответствующих элементам представления,
и за $H_{\max}$ список элементов, на котором $m_{\max}$ достигается.
Возьмём в качестве $K'$ номер элемента представления, являющегося
$\gtrdot_{1}$-максимальным в $H_{\max}$. Имеем $ $$\HM(m_{K'}b_{i_{K'}})=m_{\max}\geqslant\HM(m_{K}b_{i_{K}})>\HM(mh)$,
поэтому $\HM$ суммы всех элементов, кроме $K'$-го равен $\HM(mh-m_{K'}b_{i_{K'}})=\HM(m_{K'}b_{i_{K'}})=m_{\max}$,
поэтому существует другой элемент $K''$, обладающий $\HM(m_{K''}b_{i_{K''}})=m_{\max}$.
Отсюда $m_{K''}\cdot b_{i_{K''}}\in H_{\max}$ и $m_{K''}\cdot b_{i_{K''}}\lessdot_{1}m_{K'}\cdot b_{i_{K'}}$
поскольку $ $$m_{K'}\cdot b_{i_{K'}}$ $\gtrdot_{1}$-максимален
в $H_{\max}$.

Равенство $\HM(m_{K''}b_{i_{K''}})=\HM(m_{K'}b_{i_{K'}})$ означает,
что S-пара $b_{i_{K'}}$ и $b_{i_{K''}}$ имеет вид $[m'^{-1}m_{\max},\, m'^{-1}m_{K'},\, b_{i_{K'}},\, m'^{-1}m_{K''},\, b_{i_{K''}}]$
где $m'=\mbox{gcd}(m_{K'},m_{K''})$. Пусть $q$ -- соответствующий
S-многочлен. Тогда $m'\Sig(q)\preccurlyeq\Sig(mh)\prec\Sig(g)$ поскольку
$m'\Sig(q)=\Sig(m_{K'}b_{i_{K'}})$ и представление сигнатурно. Части
S-многочлена $m'^{-1}m_{K'}b_{i_{K'}}$ и $m'^{-1}m_{K''}b_{i_{K''}}$
не удовлетворяют критериям F5 и Перезаписи, поскольку они же, умноженные
на $m'$ равны $m_{K'}b_{i_{K'}}$ и $m_{K''}b_{i_{K''}}$ -- отмеченным
многочленам, соответствующим элементам, про которые известно, что
они не удовлетворяют критериям по предположению леммы. Из $m'\Sig(q)\prec\Sig(g)$
имеем $\Sig(q)\prec\Sig(g)$, а значит можно применить теорему \ref{thm:Exist-gg-repr}
и получить, что $(b_{i_{K'}},b_{i_{K''}})$ -- S-пара с известным
$G_{g}$-представлением, что означает существование представления,
описанного в примере \ref{example-of-having-gg-repr}:

\[
q=1\cdot b_{i'}+\sum_{l}m_{l}\cdot b_{i_{l}},
\]
причём выполняются свойства, показанные после примера: $\Sig(q)=\Sig(b_{i'})$,
$\forall l\,\Sig(q)\succ\Sig(m_{l}b_{i_{l}})$ и $i'>K'$.

С другой стороны по определению S-многочлена мы имеем $m'q=c_{0}m_{K'}b_{i_{K'}}-c_{1}m_{K''}b_{i_{K''}}$,
откуда получаем следующее представление:
\[
m_{K'}b_{i_{K'}}=c_{0}^{-1}c_{1}m_{K''}\cdot b_{i_{K''}}+c_{0}^{-1}m'\cdot b_{i'}+\sum_{l}c_{0}^{-1}m'm_{l}\cdot b_{i_{l}}.
\]
Оно $\lessdot$-меньше, чем $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$: 

$m_{K''}\cdot b_{i_{K''}}$ уже сравнивалось с $m_{K'}\cdot b_{i_{K'}}$ 

$m'\cdot b_{i'}$ имеет ту же сигнатуру, но больший номер позиции
$i'>i_{K'}$

последняя сумма состоит из элементов с сигнатурами, меньшими чем $m'\Sig(b_{i'})=\Sig(m_{K'}\cdot b_{i_{K'}})$.\end{proof}
\begin{thm}
\label{thm:exist-smaller-signature-safe-representation}Или сигнатурное
представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ с $\Sig(mh)\prec\Sig(g)$
удовлетворяет свойствам 1-3 или существует другое сигнатурное представление
$mh=\sum_{l}m_{l}\cdot b_{i_{l}}$ $\lessdot$-меньшее, чем \textup{$\sum_{k}m_{k}\cdot b_{i_{k}}$.}\end{thm}
\begin{proof}
Теорема немедленно следует из комбинации четырёх предыдущих лемм.
\end{proof}
Это привод на с к следующему ключевому результату:
\begin{thm}
Для любого многочлена $mh,\, m\in\mathcal{K}\times T,\, h\in G_{g}$
с $\Sig(mh)\prec\Sig(g)$ существует удовлетворяющее свойствам 1-3
сигнатурное $G_{g}$-представление $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$\textup{.}\end{thm}
\begin{proof}
Начнём с представления $mh=m\cdot h$ и будем заменять текущее представление
на $\lessdot$-меньшее из теоремы \ref{thm:exist-smaller-signature-safe-representation}
до тех пор пока текущее представление не будет удовлетворять свойствам
1-3. Конечность процесса гарантируется вполне упорядоченностью представлений
по $\lessdot$.
\end{proof}
Этот результат может представлять интерес сам по себе, однако для
целей доказательства остановки нужно лишь одно следствие из него:
\begin{cor}
\label{cor:all-needed-for-terminaton}Рассмотрим произвольный многочлен
$f$ без ограничений на его сигнатуру. Если существует сигнатурный
редуктор $f'\in G_{g}$ для $f$ с $\Sig(f')\frac{\HM(f)}{\HM(f')}\prec\Sig(g)$
то $G_{g}$ содержит сигнатурный редуктор для $f$, который не отбрасывается
критериями F5 и перезаписи.\end{cor}
\begin{proof}
Пусть $mf',\, m=\frac{\HM(f)}{\HM(f')}\in\mathcal{K}\times T,\, f'\in G_{g}$
умноженный редуктор с $\Sig(mf')\prec\Sig(g)$. Из предыдущей теоремы
мы можем найти удовлетворяющее свойствам 1-3 представление $mf'=\sum_{k}m_{k}\cdot b_{i_{k}}$.
Свойство 3 означает отсутствие элементов с $\HM$, большим чем у $mf'$,
откуда, поскольку сумма всех элементов этого представления имеет $\HM$
равный $\HM(mf')$, существует элемент $K$, на котором достигается
равенство $\HM$: $\HM(m_{K}\cdot b_{i_{K}})=\HM(mf')=\HM(f_{1}')$.
Поскольку представление сигнатурно, имеем $\Sig(m_{K}\cdot b_{i_{K}})\preccurlyeq\Sig(mf')\prec\Sig(f)$,
а значит $m_{K}b_{i_{K}}$ -- сигнатурный редуктор для $f$ и выполнение
свойств 1-2 гарантирует, что $m_{K}b_{i_{K}}$ не отбрасывается критериями.
\end{proof}

\section{Обнаружение противоречия с учётом критериев}

Теперь мы можем вернуться к результаты теоремы \ref{thm:f_g_3_props},
утверждающей, что в случае. если алгоритм не останавливается, существуют
многочлены $f',f\in G$, такие что $\HM(f')|\HM(f)$, $\frac{\HM(f')}{\Sig(f')}>_{q}\frac{\HM(f)}{\Sig(f)}$.
Используя этот результат и последнее следствие мы построим два многочлена,
приводящие к противоречию в случае отсутствия остановки алгоритма.
\begin{thm}
\label{thm:always-exist-ok-reductor}Если алгоритм не останавливается
на некоторых входных данных, то найдётся шаг, после которого конечное
множество \textup{$G\cup Done$} содержит пару отмеченных многочленов
$f'_{1},f$, для которых выполняется:
\begin{itemize}
\item $f'_{1}$ было добавлено в \textup{$G\cup Done$} до $f$
\item $t_{1}f'_{1}$ не удовлетворяет критериям F5 и Перезаписи, где $t_{1}=\frac{\HM(f)}{\HM(f'_{1})}$
\item $f'_{1}$ -- сигнатурный редуктор для $f$.
\end{itemize}
\end{thm}
\begin{proof}
Пусть $f',f$ -- многочлены из теоремы \ref{thm:f_g_3_props} и $t=\frac{\HM(f)}{\HM(f')}$.
Многочлен $f\in G$, поэтому построенная выше теория о представлениях
может быть рассмотрена применительно к случаю $g$ равного $f$, и
можно говорить о множестве $G_{f}$ и $G_{f}$-представлениях. Поскольку
$tf'$ -- сигнатурный редуктор для $f$ -- мы имеем $\Sig(f')t\prec\Sig(f)$
и следствие \ref{cor:all-needed-for-terminaton} может быть применено
для нахождения сигнатурного редуктора $t_{1}f'_{1}$ для $f$, который
не удовлетворяет критериям. Помимо этого известно, что он принадлежит
$G_{f}$, поэтому выполняется и первое свойство: в процессе работы
алгоритма $f'_{1}$ был добавлен в $G\cup Done$ раньше $f$.\end{proof}
\begin{thm}
Алгоритм $ $F5, описанный в \cite{FaugereF5}, останавливается на
любых входных данных.\end{thm}
\begin{proof}
Покажем, что существование многочленов $f'_{1},f$ из теоремы \ref{thm:always-exist-ok-reductor}
приводит к противоречию. Рассмотрим вызов \texttt{TopReduction} после
которого многочлен $f$ был добавлен в $Done$. Этот вызов вернул
многочлен $f$ как первую половину значения, возвращаемого \texttt{TopReduction},
что означает что предшествующий вызов \texttt{IsReducible} вернул
пустое множество. Это значит, что для каждого многочлена в $G\cup Done$,
в том числе $f'_{1}$, хотя бы одно из условий (a) - (d) не выполнилось.
Это невозможно, поскольку:
\begin{itemize}
\item (a) удовлетворяется, так как $f'_{1}$ -- редуктор для $f$ по теореме
\ref{thm:always-exist-ok-reductor} 
\item (b) и (c) удовлетворяются, поскольку $\frac{\HM(f)}{\HM(f'_{1})}f'_{1}$
не удовлетворяет критериям F5 и Перезаписи по теореме \ref{thm:always-exist-ok-reductor} 
\item (d) удовлетворяется, поскольку $f'_{1}$ -- сигнатурный редуктор для
$f$ по теореме \ref{thm:always-exist-ok-reductor}.
\end{itemize}
\end{proof}

\section{Выводы}

Данная работа показывает, что исходный алгоритм F5 завершается на
любых однородных входных данных, не вводя промежуточных алгоритмов.
При этом не даётся никакого ограничения на количество операций. Простейшее
доказательство остановки алгоритма Бухбергера основано на свойстве
Нётеровости и тоже не даёт такого ограничения. Однако доказательство
остановки, приведённое здесь, значительно отличается по структуре
от доказательства остановки алгоритма Бухбергера, поэтому не может
быть использовано для сравнения эффективности алгоритма F5 c алгоритмом
Бухбергера. В отличие от этого, остановка изменённых вариаций алгоритма
F5 в работах \cite{Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG}
показывается методом, близким к доказательству остановки алгоритма
Бухбергера, за счёт чего остаётся возможность сравнения их эффективности
с алгоритмом Бухбергера.

С точки зрения практической компьютерной алгебры существует вопрос
эффективности изменённых вариаций по сравнению с исходным F5. Изменённые
вариации могут проводить больше времени в дополнительных проверках,
инициирующих остановку. Но в некоторых случаях возможна ситуация,
когда за счёт этих проверок остановка в изменённых версиях инициируется
раньше, чем в исходной, за счёт чего изменённые версии проводят меньше
редукций. Поэтому становится возможным, что на некоторых входных данных
быстрее оказывается исходный алгоритм, а на других -- модифицированный.
Экспериментально измеренные времена работы в Таблице 1 работы \cite{Modifying-for-termination}
показывают, что оба случая действительно встречаются на практике,
но разница во временах работы незначительна. Поэтому, хотя данная
работа и показывает, что останавливаются не только модифицированные
версии, но и исходный алгоритм, вопрос о сравнения эффективности исходной
и модифицированной версий F5 остаётся открытым.

В доказательстве используются три свойства исходного алгоритма F5,
которые отсутствуют или опциональны в других F5-подобных алгоритмах:
однородность входных многочленов, наличие критерия перезаписи и совпадения
порядка на мономах $<$ с порядком на сигнатурах $\prec$. Возможность
расширения доказательства на F5-подобные алгоритмы, не обладающие
этими свойствами, остаётся открытым. Автор предполагает, что доказательство
может быть модифицировано таким образом, что зависимость от первых
двух свойств исчезнет, однако от третьего избавиться не получится,
поскольку оно является ключевым моментом при получении противоречия
на основе результата теоремы \ref{thm:f_g_3_props}.\\



\thanks{Автор благодарит Christian Eder, Jean-Charles Faug\`{e}re, Amir Hashemi,
John Perry, Till Stagers и Алексея Зобнина за их работы и комментарии,
воодушевившие автора на исследования в этой области. Спасибо!}

\bibliographystyle{plain}
\bibliography{f5_references}

\end{document}
