%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside,russian]{amsart}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{listings}
\usepackage[a4paper]{geometry}
\geometry{verbose}
\usepackage{color}
\usepackage{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}
\AtBeginDocument{\DeclareFontEncoding{T2A}{}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
  \theoremstyle{remark}
  \newtheorem{claim}[thm]{\protect\claimname}
  \theoremstyle{definition}
  \newtheorem{defn}[thm]{\protect\definitionname}
  \theoremstyle{plain}
  \newtheorem{fact}[thm]{\protect\factname}
  \theoremstyle{definition}
  \newtheorem{example}[thm]{\protect\examplename}
  \theoremstyle{plain}
  \newtheorem{lem}[thm]{\protect\lemmaname}
  \theoremstyle{plain}
  \newtheorem{cor}[thm]{\protect\corollaryname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\Sig}{\mathcal{S}}
\newcommand{\HM}{\mathrm{HM}}
\newcommand{\totaldeg}{\mathrm{deg}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\sigidx}{\mathrm{index}}

\makeatother

  \providecommand{\claimname}{\inputencoding{koi8-r}хФЧЕТЦДЕОЙЕ}
  \providecommand{\corollaryname}{\inputencoding{koi8-r}чЩЧПД}
  \providecommand{\definitionname}{\inputencoding{koi8-r}пРТЕДЕМЕОЙЕ}
  \providecommand{\examplename}{\inputencoding{koi8-r}рТЙНЕТ}
  \providecommand{\factname}{\inputencoding{koi8-r}жБЛФ}
  \providecommand{\lemmaname}{\inputencoding{koi8-r}мЕННБ}
\providecommand{\theoremname}{\inputencoding{koi8-r}фЕПТЕНБ}

\begin{document}

\title{Остановка Алгоритма F5}
\begin{abstract}
Алгоритм F5, предложенный Фожером, принимает в качестве входных данных
произвольное множество однородных многочленов и корректность результата
доказана для всех случаев, когда алгоритм останавливается. Однако
остановка алгоритма за конечное число шагов доказана лишь для случая,
когда на вход алгоритма подаётся регулярная последовательность многочленов.
В этой работе показано, что алгоритм останавливается на любых входных
данных без какого-либо использования регулярности. Схема доказательства
состоит из двух частей: в первой части показано, что если алгоритм
не останавливается, то рано или поздно он получит пару многочленов,
в которой первый может редуцировать второй. При этом, однако, не утверждается,
что такая редукция будет разрешена критериями, предложенными в F5.
Вторая часть показывает, что при существовании такой пары также будет
существовать пара в которой редукция разрешена всеми критериями. Существование
такой пары приводит к противоречию.
\end{abstract}

\author{Василий Галкин}


\address{МГУ}


\email{galkin-vv@ya.ru}

\maketitle

\section{Введение}

Алгоритм Фожера F5 известен как эффективный алгоритм вычисления базисов
Грёбнера, но одной из главных проблем в его практическом использовании
является отсутствие доказательства остановки для всех входных данных.
Первоисточник \cite{FaugereF5} и детальные исследования в \cite{F5-revisited}
показывают остановку алгоритма только для случая отсутствия редукций
к нулю, что с практической точки зрения означает доказательство для
тех случаев, когда входное множество многочленов представлено регулярной
последовательностью. Но для большинства входных последовательностей
их регулярность неизвестна, и доказанного факта оказывается недостаточно
для утверждения остановки реализации алгоритма на конкретных входных
данных. Один из подходов к решению проблемы -- добавление в алгоритм
дополнительных проверок и критериев, гарантирующих остановку алгоритма.
Этот подход даёт строгое доказательство остановки, однако получаемый
результат есть доказательство остановки модифицированной версии F5,
содержащей дополнительные проверки, которая в силу этого может быть
более сложна в реализации или иметь большее время работы на некоторых
входных данных. Этот подход применяется в работах \cite{Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG,Hashemi-ExtF5,ZobninGeneralization}.

Другой подход состоит в доказательстве остановки некоторого семейства
алгоритмов, основанных на идеях F5 с последующей попыткой переформулировать
F5 таким образом, чтоб он являлся представителем этого семейства.
Основная проблема этого подхода появляется в процессе переформулировки:
описание F5 в других терминах может привести к незаметному внесению
различий в поведение алгоритма, которые трудно заметить, но которые
требуют дополнительных рассуждений для доказательства эквивалентности
с F5. К примеру, \cite{2012GrbTermination} доказывает остановку алгоритма
F5GEN, который отличается от исходного F5 отсутствием проверки критериев
при выборе редуктора. Работа \cite{HuangConception} даёт доказательство
остановки алгоритма TRB-F5, который, как удалось осознать автору в
процессе плодотворных дискуссиях с Джоном Перри, имеет два существенных
отличия от F5. Первое отличие -- другая схема построения правил, приводящая
в конце концов к тому, что в процессе выполнения TRB-F5 правила в
массивах $Rule$ оказываются отсортированными по возрастания сигнатуры.
Второе отличие -- отсутствие в TRB-F5 применения оператора нормальной
формы $\varphi$ перед редукцией, что приводит к эффекту противоположному
отличиям F5 от F5GEN: алгоритм TRB-F5 при выборе редуктора проверяет
критерии для элементов с б\'{о}льшими индексами, которые в F5 используются
неявно в операторе нормальной формы и за счёт этого не подвергаются
проверки критериев. Автор полагает, что эти алгоритмы могут быть изменены
таким образом, чтоб в точности повторять поведение алгоритма F5, и
доказательство остановки может быть перенесено на изменённые версии.
Однако подход с алгоритмами, эквивалентными F5 имеет недостаток: он
усложняет понимание того, как теоремы, используемые для доказательства
остановки могут быть сформулированы в терминах поведения исходного
алгоритма F5.

Подход к доказательству остановки, предлагаемый в данной работе, применяется
к F5 без каких-либо модификаций. Первый шаг доказательства основан
на предлагаемой ниже идеи цепей S-пар. Второй шаг основывается на
методе, использованном в теореме 21 работы \cite{F5C} для доказательства
корректности алгоритма F5C: представление S-многочлена в виде суммы
домноженных многочленов из множества, вычисленного F5C может быть
модифицировано последовательностью замен S-пар и их отброшенных частей,
и за конечное число таких шагов приведено к состоянию, когда выполняются
определённые \flqq{}хорошие\frqq{} свойства.

Вторая часть этой статьи показывает, что предусловия этого метода
могут быть ослаблены для его применения к множеству на любом промежуточном
шаге вычислений F5, и что получаемые следствия могут быть усилены
для их использования в доказательстве остановки. Работа оформлена
как альтернативное доказательство остановки для алгоритма, описанного
в статье \cite{FaugereF5}, доступной на сайте её автора, поэтому
читатель предполагается хорошо знакомым с ней. Большинство используемой
терминологии, включая названия этапов алгоритма, взято оттуда.


\section{Потенциально бесконечные циклы в F5}


\subsection{Процедура \texttt{AlgorithmF5}: увеличение $d$}
\begin{claim}
\label{iterations-d_grow}Если при некоторых входных данных цикл \textbf{while}
внутри процедуры \texttt{AlgorithmF5} выполняется бесконечное число
раз, то значение $d$ неограниченно возрастает.\end{claim}
\begin{proof}
Предположим существование последовательности многочленов $\left\{ f_{1},\ldots,f_{m}\right\} $
в кольце $\mathcal{K}[x_{1},\ldots,x_{n}]$ для которой алгоритм F5
не завершается. Без ограничение общности будем считать что это самая
короткая последовательность такого рода -- алгоритм завершается на
более короткой последовательности $\left\{ f_{2},\ldots,f_{m}\right\} $.
Это означает, что не завершается последняя итерация цикла внутри \texttt{incrementalF5},
то есть не завершается последний вызов процедуры \texttt{AlgorithmF5}.
Для исследования данной ситуации необходимо понять, как ведёт себя
значение полной степени $d$ в процессе выполнения цикла внутри процедуры
\texttt{AlgorithmF5}. Обозначим за $d_{j}$ значение $d$ на $j$-ой
итерации цикла и положим $d_{0}=-1$. Простейшее свойство $d_{j}$
-- неубывание: $d_{j}\geqslant d_{j-1}$. Оно выполняется, поскольку
на $j-1$-ой итерации все многочлены в $R_{d}$ имеют степень $d_{j-1}$,
и поэтому все вновь создаваемые критические пары имеют степень не
менее $d_{j-1}$. Предположим теперь, что $j$ фиксированный номер
некоторой итерации. В начале итерации $j$ все критические пары степени
$d_{j}$ извлекаются из $P$. После вызова процедуры \texttt{Reduction}
в $P$ добавляются некоторые новые критические пары в цикле, итерирующем
по $R_{d}$. Существует возможность что некоторые из них будут иметь
полную степень равную $d_{j}$. Нижеследующие рассуждения призваны
показать, что все критические пары такой полной степени будут отброшены
на следующей итерации алгоритма и ни одна из них не породит S-многочлен.

Для каждой из критических пар $[t,u_{1},r_{1},u_{2,}r_{2}]$ порождённых
на итерации $j$ как минимум один из многочленов пары принадлежит
$R_{d}$ и не более чем один многочлен из пары мог принадлежать $G_{i}$
на момент начала итерации. Все многочлены $R_{d}$ генерируются процедурой
\texttt{Reduction} путём добавления по одному многочлену к множеству
$Done$. Поэтому, среди одного или двух многочленов критической пары,
принадлежащих $R_{d}$, мы можем выбрать многочлен $r_{k}$ добавленный
в $Done$ позже. Тогда про другой многочлен S-пары $r_{3-k}$ можно
утверждать, что он уже присутствовал в $G\cup Done$ к моменту добавления
$r_{k}$ в $Done$. Поэтому процедура \texttt{TopReduction} пыталась
редуцировать $r_{k}$ по $r_{3-k}$, но не сделала этого, поскольку
в функции \texttt{IsReducible} одна из проверок (a) - (d) запретила
это.

При этом для критических пар с полной степенью равной $d_{j}$ мы
имеем $u_{k}=1$, поскольку полная степень критической пары равна
полной степени её челна $r_{k}$. Это означает, что значение $u_{3-k}$
равно $\frac{\HM(r_{k})}{\HM(r_{3-k})}$, поэтому в \texttt{IsReducible}
правило (a) разрешает редукцию $r_{k}$ по $r_{3-k}$. Получается,
что только правила (b) - (d) могли запретить редукцию.

Предположим, что редукция была запрещена правилом (b). Это означает,
что в $G_{i+1}$ существует многочлен, редуцирующий $u_{3-k}\Sig(r_{3-k})$.
Для нашего случая отсюда следовало бы, что в функции \texttt{CritPair}
эквивалентная проверка $\varphi(u_{3-k}\Sig(r_{3-k}))=u_{3-k}\Sig(r_{3-k})$
запретила бы создание критической пары. Получается, что правило (b)
также не могло запретить редукцию.

Предположим, что редукция была запрещена правилом (c). Это означает
существование перезаписи для домноженного редуктора. В нашем случае
это значит, что \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
показала наличие перезаписи в процессе выполнения \texttt{TopReduction},
и будет продолжать возвращать значение \flqq{}Истина\frqq{} на всех
последующих этапах алгоритма, поскольку перезаписывающие многочлены
не могут исчезнуть.

Предположим, что редукция была запрещена правилом (d). Псевдокод в
\cite{FaugereF5} несколько неясен в этом месте, но исходный код процедуры
\texttt{FindReductor}, приложенный к \cite{F5-revisited} достаточно
ясен и утверждает, что редуктор отбрасывается, если одновременно моном
и индекс сигнатуры совпадают для редуктора и редуцируемого многочлена
(в коде \texttt{r{[}k0{]}{[}1{]}} -- моном сигнатуры, а \texttt{r{[}k0{]}{[}2{]}}
-- её индекс):

\begin{lstlisting}[basicstyle={\ttfamily},tabsize=4]
if (ut eq r[k0][1]) and (r[j][2] eq r[k0][2]) then
	// discard reductor by criterion (d)
	continue;
end if;
\end{lstlisting}
В нашем случае это обозначает, что сигнатуры $r_{k}$ и $u_{3-k}r_{3-k}$
равны. Значит вызов \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
будет возвращать \flqq{}Истину\frqq{} после добавления правила,
соответствующего $r_{k}$, поскольку $u_{3-k}\cdot r_{3-k}$ перезаписывается
$1\cdot r_{k}$. Получается, что как и в случае с правилом (c), \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
возвращает \flqq{}Истину\frqq{} при выполнении \texttt{TopReduction}
и позже.

Теперь рассмотрим функцию \texttt{Spol}, выполняемую для некоторой
S-пары полной степени $d_{j}$, сгенерированной на итерации $j$.
Она выполняется внутри $j+1$ итерации цикла в \texttt{AlgorithmF5},
то есть уже после того, как закончилось выполнение \texttt{TopReduction}
для $r_{k}$. Поэтому для случаев (c) и (d) вызов \texttt{Rewritten?}$\left(u_{3-k},r_{3-k}\right)$
внутри \texttt{Spol} вернёт \flqq{}Истину\frqq{}. Значит на итерации
$j+1$ ни одна из S-пар полной степени $d_{j}$ не добавит многочлена
в $F$.

Итого, получено: 
\begin{itemize}
\item первая возможность относительного расположения $d_{j+1}$ и $d_{j}$
-- их равенство: $d_{j+1}=d_{j}$. В этом случае $F$ оказывается
пустым на итерации $j+1$, и, таким образом, $P$ не содержит ни одной
пары с полной степенью $d_{j}$ после того как итерация $j+1$ завершится.
Значит $d_{j+2}>d_{j+1}$. 
\item Другая возможность относительного расположения -- строгое возрастание
$d_{j+1}>d_{j}$.
\end{itemize}
Вместе эти факты дают $\forall j\,\, d_{j+2}>d_{j}$, что доказывает
утверждение \ref{iterations-d_grow}.
\end{proof}

\subsection{Процедура \texttt{Reduction}: конечность $ToDo$}
\begin{claim}
\label{Every_cycle_iteration_finish}Каждая итерация цикла внутри
процедуры \texttt{AlgorithmF5} останавливается, в частности останавливаются
все вызовы процедуры \texttt{Reduction}.\end{claim}
\begin{proof}
Факт остановки известен для вызовов \texttt{AlgorithmF5}, соответствующих
многочленам $f_{2},\dots,f_{m}$, поэтому будет рассматриваться лишь
один оставшийся вызов \texttt{AlgorithmF5}, обрабатывающий первый
элемент входного набора многочленов $f_{1}$. Вначале покажем несколько
общих утверждений о многочленах в множествах $ToDo$ и $Rule$ в процессе
$j$-ой итераций цикла внутри этого вызова \texttt{AlgorithmF5}. Старшая
по сигнатуре часть S-пары всех критических пар, добавляемых функцией
\texttt{CritPair} вначале выполнения \texttt{AlgorithmF5}, обладает
индексом сигнатуры, равным $1$. Все прочие критические пары порождаются
с индексом сигнатуры, соответствующим некоторому отмеченному многочлену,
перемещённому из множества $ToDo$ в множество $Done$. В свою очередь
все элементы $ToDo$ создаются или на основе критических пар или внутри
процедуры \texttt{TopReduction}. Многочлены, генерируемые \texttt{TopReduction}
имеют сигнатуру, превышающую сигнатуру многочлена, который редуцирует
данный вызов процедуры, и который является элементом $ToDo$. Поэтому
многочлен или критическая пара с индексом сигнатуры, отличным от 1
не могут появиться в рассматриваемом вызове \texttt{AlgorithmF5}.
С другой стороны, все многочлены в $ToDo$ имеют одну и ту же полную
степень $d_{j}$. Вместе с единичностью индексов это позволяет заключить,
что полная степень мономов сигнатур равна $d_{j}-\totaldeg(f_{1})$
для всех элементов $ToDo$.

Каждое добавление элемента в массив $Rule$ соответствует добавлению
в множество $ToDo$. Поэтому, элементы добавляемые в $Rule$ на итерации
$j$ имеют полную степень равную $d_{j}$. Вспоминая неубывание $d_{j}$
получаем, что на $j$-ой итерации все элементы $Rule$ с индексом
сигнатуры 1 имеют полную степень $\leqslant d_{j}$ и полную степень
монома сигнатуры $\leqslant d_{j}-\totaldeg(f_{1})$. Также это даёт
информацию о порядке элементов $Rule$ с сигнатурой 1: их полная степень
не убывает.
\begin{defn}
Редукция отмеченного многочлена $r_{k}$ по отмеченному многочлену
$r_{m}$ называется\emph{ сигнатурной редукцией,} если $\Sig(r_{k})\succ t\cdot\Sig(r_{m})$,
где $t=\frac{\HM(r_{k})}{\HM(r_{m})}$ -- моном, на который умножается
редуктор. Редуктор, соответствующий такой редукции называется \emph{сигнатурным
редуктором}. 
\end{defn}
Алгоритм производит только сигнатурные редукции: процедура \texttt{TopReduction}
производит редукцию по неотброшенному редуктору, если он сигнатурный,
и добавляет элемент в $ToDo$ в противном случае. Элементы $ToDo$
обрабатываются в порядке возрастания сигнатур, поэтому ни один из
элементов $G\cup Done$ не может иметь сигнатуры, превышающей сигнатуру
многочлена $r_{k}$, редуцируемого в \texttt{TopReduction}. Рассмотрим
неотброшенный проверками редуктор $r_{m}$. Если он имеет полную степень
$\totaldeg(r_{m})=\totaldeg(r_{k})$, мы получаем свойства $t=1$
и $\Sig(r_{k})\succ\Sig(r_{m})$, гарантирующие что редукция по нему
будет сигнатурной. Случай $\Sig(r_{k})=\Sig(r_{m})$ невозможен, поскольку
такие редукторы отбрасываются в правиле (d) процедуры \texttt{IsReducible}.
Таким образом, ситуация $\Sig(r_{k})\prec t\cdot\Sig(r_{m})$ возможна
только при $\totaldeg(r_{m})<\totaldeg(r_{k})$ и все добавления в
$ToDo$ в процессе \texttt{TopReduction} соответствуют этому случаю.
Моном сигнатуры многочлена, добавляемого таким образом, равен $t\cdot\Sig(r_{m})$
и тот факт что $r_{m}$ не был отброшен проверкой правила \texttt{Rewritten?}
внутри \texttt{IsReducible} гарантирует, что ни одного многочлена
с сигнатурой $t\Sig(r_{m})$ не было порождено, потому что иначе такой
многочлен имел бы связанное с ним правило в $Rule$ с большей полной
степенью, чем правило, соответствующее $r_{m}$, и $r_{m}$ был бы
отброшен в \texttt{IsReducible}. 

Мы хотим показать, что единственная возможность отсутствия остановки
алгоритма соответствует случая неограниченного возрастания $d_{j}$.
Мы показали, что отсутствие остановки алгоритма происходит в случае,
когда не завершается вызов \texttt{AlgorithmF5}, и что он не может
зациклиться обрабатывая бесконечное число итераций итерации с одним
и тем же значением $d$. Остаются два варианта: неограниченное возрастание
$d$ и зацикливание внутри одной из итераций с фиксированным значением.
Далее показано, что такое зацикливание невозможно. Процедура \texttt{AlgorithmF5}
содержит 3 цикла помимо главного:
\begin{itemize}
\item \textbf{for}-цикл внутри \texttt{Spol} завершается, поскольку число
его итераций ограничено числом критических пар к моменту начала выполнения
цикла;
\item \textbf{for}-цикл внутри \texttt{AlgorithmF5} проходит по элементам
$R_{d}$ и также завершается, поскольку число элементов $R_{d}$ зафиксировано
к моменту начала выполнения цикла;
\item наиболее сложный случай соответствует \textbf{while}-циклу внутри
\texttt{процедуры Reduction}, который выполняется до тех пор, пока
множество $ToDo$ не станет пустым. Множество $ToDo$ изначально заполняется
процедурой \texttt{Spol} и потом дополняется новыми элементами в процессе
выполнения \texttt{TopReduction}. Процедура \texttt{Spol} порождает
конечное число элементов, поскольку она завершается, а все элементы
добавляемые \texttt{TopReduction} имеют различные сигнатуры индекса
1, поэтому их число ограничено числом различных сигнатур полной степени
$d_{j}-\totaldeg(f_{1})$, поэтому в $ToDo$ добавляется лишь конечное
число элементов. Теперь мы покажем, что все типы шагов, происходящих
внутри \texttt{Reduction} могут быть выполнены лишь конечное число
раз:

\begin{itemize}
\item шаг, на котором \texttt{IsReducible} возвращает пустое множество,
соответствует переносу элемента множества $ToDo$ в $Done$ и число
таких шагов ограничено числом элементов, добавляемых в $ToDo$
\item шаг, на котором \texttt{IsReducible} возвращает не сигнатурный редуктор,
соответствует добавлению нового элемента в $ToDo$ и число таких шагов
ограничено числом возможных добавлений
\item шаг, на котором \texttt{IsReducible} возвращает сигнатурный редуктор,
соответствует редукции одного из элементов $ToDo$. Это может произойти
лишь конечное число раз, поскольку в $ToDo$ добавляется конечное
число многочленов и не может существовать бесконечной цепочки редукций
для одного многочлена, поскольку в процессе редукции его старший моном
$\HM$ строго $\prec$-убывает, а множество мономов вполне упорядочено
по $\prec$.
\end{itemize}
\end{itemize}
Мы получили, что все циклы внутри процедуры \texttt{AlgorithmF5},
кроме главного, завершаются, что доказывает утверждение \ref{Every_cycle_iteration_finish}.
\end{proof}
Отсюда получается следующий факт о поведении алгоритма в ситуации,
когда он не завершается:
\begin{claim}
\label{d-does-grow}Если алгоритм не завершается на некоторых входных
данных, то значение $d$ неограниченно возрастает в процессе итераций.\end{claim}
\begin{proof}
Следует из комбинирования утверждений \ref{iterations-d_grow} и \ref{Every_cycle_iteration_finish}.
\end{proof}

\section{Цепи S-пар}

Утверждение \ref{d-does-grow} показывает, что в случае отсутствия
остановки работа алгоритма приводит к появлению бесконечной последовательности
ненулевых отмеченных многочленов с неограниченно возрастающей полной
степенью, добавляемых в $G_{i}$. То есть, в этом случае алгоритм
порождает бесконечную последовательность отмеченных многочленов $\left\{ r_{1},r_{2},\ldots,r_{m},\ldots,r_{l},\ldots\right\} $,
в которой $r_{1},\ldots,r_{m}$ соответствуют $m$ исходным многочленам,
а остальные были получены в процедурах \texttt{Spol} и \texttt{TopReduction}.
В обоих случаях новый элемент $r_{l}$ порождается как S-многочлен
двух уже ранее добавленных в последовательность многочленов. Будем
обозначать за $l^{*}$ и $l_{*}$ позиции многочленов, использовавшихся
для генерации $l$-го многочлена последовательности и за $\overline{u_{l}}$,
$\underline{u_{l}}$ мономы, на которые они умножались. При этом $l^{*}$
соответствует части с большей сигнатурой: $\poly(r_{l})=\overline{u_{l}}\poly(r_{l^{*}})-\underline{u_{l}}\poly(r_{l_{*}})$
и $\Sig(r_{l})=\overline{u_{l}}\Sig(r_{l^{*}})\succ\underline{u_{l}}\Sig(r_{l_{*}})$.
Значение $\poly(r_{l})$ может меняться в процедуре \texttt{TopReduction}
на многочлен с меньшим $\HM$, но $\Sig(r_{l})$ нигде далее не меняется
после добавления многочлена в последовательность. Далее, будем пытаться
найти бесконечную подпоследовательность $\left\{ r_{k_{1}},r_{k_{2}},\ldots,r_{k_{n}},\ldots\right\} $
в этой последовательности, обладающую свойством, что $r_{k_{n}}$
является S-многочленом $r_{k_{n-1}}=r_{k_{n}^{*}}$ и некоторого другого
многочлена меньшей сигнатуры. то есть $\Sig(r_{k_{n}})=\overline{u_{k_{n}}}\Sig(r_{k_{n-1}})$
и 
\begin{equation}
\Sig(r_{k_{n-1}})|\Sig(r_{k_{n}}).\label{eq:s-pair-chain-def}
\end{equation}

\begin{defn}
Конечную или бесконечную последовательность, соседние элементы которой
удовлетворяют свойству \ref{eq:s-pair-chain-def} будем называть \emph{цепью
S-пар}.
\end{defn}
Каждый порождаемый многочлен $r_{l}$ имеет конечную цепь S-пар, оканчивающуюся
этим многочленом. Эта цепь может быть последовательно построена, начиная
с последнего элемента$r_{l}$, если на каждом шаге переходить от текущего
многочлена $r_{n}$ к многочлену $r_{n^{*}}$, который использовался
при генерации $r_{n}$ как S-многочлена. Результирующая цепь S-пар
имеет вид $\{r_{q},\ldots,r_{l^{**}},r_{l^{*}},r_{l}\}$, где все
многочлены имеют одинаковый индекс сигнатуры $q=\sigidx(r_{l})$ и
первый элемент является входным многочленом этого индекса.

Первое свойство цепей S-пар основано на критерии перезаписи и заключается
в следующей теореме.
\begin{thm}
Любой отмеченный многочлен может являться начальным элементом лишь
конечного числа различных цепей S-пар длины 2.\end{thm}
\begin{proof}
Алгоритм \texttt{AlgorithmF5} считает S-полиномы в двух местах: процедуре
\texttt{SPol} и процедуре \texttt{TopReduction}. Важно заметить, что
в обоих случаях проверка \texttt{Rewritten?} для части S-полинома
с большей сигнатурой выполняется непосредственно перед созданием S-многочлена.
В первом случае такая проверка производится в самой \texttt{SPol},
а в \texttt{TopReduction} проверка присутствует в вызове \texttt{IsReducible}.
И в обоих случаях получаемый S-многочлен немедленно добавляется в
список $Rule$ последним элементом. Поэтому, в момент построения S-многочлена
с сигнатурой $s$ можно утверждать, что старая часть S-пары соответствует
последнему из правил с сигнатурой, делящей $s$ -- она даже может
быть найдена исходя лишь из списка $Rule$ и сигнатуры $s$ без знания
какой-либо ещё информации об алгоритме.

Рассмотрим произвольный отмеченный многочлен $r_{L}$ с сигнатурой
$\Sig(r_{L})=s$ и упорядоченное по порядку добавления подмножество
$\{r_{l_{1}},\ldots,r_{l_{i}},\ldots\}$ отмеченных многочленов с
сигнатурами удовлетворяющими условию $\Sig(r_{l_{i}})=v_{i}\Sig(r_{L})$.
С точки зрения делимости любая из потенциально бесконечного числа
пар $\{r_{L},r_{l_{i}}\}$ может быть цепью S-пар длины 2. Но идеал
$\left(v_{i}\right)$ в $T$ является конечно порождённым по лемме
Диксона, поэтому после некоторого шага $i_{0}$ будет выполняться$\forall i>i_{0}\,\exists j\leqslant i_{0}$
такое что $v_{j}|v_{i}$. Поэтому при $\forall i>i_{0}$ последовательность
$\{r_{L},r_{l_{i}}\}$ не может являться цепью S-пар, поскольку $\Sig(r_{L})\cdot v_{i}$
перезаписывается $\Sig(r_{l_{j}})\cdot\frac{v_{i}}{v_{j}}$ и существует
не более чем $i_{0}$ цепей S-пар длины 2, начинающихся с многочлена
$r_{L}$.\end{proof}
\begin{defn}
Конечное множество концов цепей S-пар длины 2, начинающихся с $r_{L}$
будет называться \emph{множеством S-порождённых} $r_{L}$.\end{defn}
\begin{thm}
Если алгоритм не останавливается на некоторых входных данных, то он
порождает бесконечную цепь S-пар $\{h_{i}\}$.\end{thm}
\begin{proof}
Поскольку при работе с понятием бесконечности требуется некоторая
строгость, дадим следующее определение.
\begin{defn}
Отмеченный многочлен $r_{l}$ называется \emph{генератором цепи S-пар},
если существует бесконечное множество различных конечных цепей S-пар,
начинающихся с $r_{l}$.
\end{defn}
Если алгоритм не останавливается, то многочлен входного множества
$r_{1}=(f_{1},1F_{1})$ является генератором цепи S-пар, поскольку
каждый многочлен, порождаемый в последнем не завершающемся вызове
\texttt{AlgorithmF5} имеет индекс сигнатуры 1 и является концом цепи
S-пар$\{r_{1},\ldots,r_{l^{**}},r_{l^{*}},r_{l}\}$.

Теперь предположим, что про некоторый отмеченный многочлен $r_{l}$
известно, что он является генератором цепи S-пар. Один из конечного
множества S-порождённых $r_{l}$ также должен являться генератором
цепи S-пар, поскольку в противном случае число различных цепей, исходящих
из $r_{l}$, было бы ограничено конечной суммой конечных количеств
цепей, выходящих из S-порождённых плюс конечным количеством цепей
длины 2, выходящих из $r_{l}$. Поэтому, если отмеченный многочлен
$r_{l}$ является генератором цепи S-пар, среди его S-порождённых
всегда может быть выбран другой генератор цепи S-пар. Таким образом
может быть построена бесконечная цепь S-пар, начинающаяся $r_{1}$
и состоящая из генераторов, что доказывает теорему.
\end{proof}
Для следующей теоремы необходимо ввести порядок на частных, образованных
мономами, путём транзитивного расширения порядка на мономах: $\frac{m_{1}}{m_{2}}>_{q}\frac{m_{3}}{m_{4}}\Leftrightarrow m_{1}m_{4}>m_{3}m_{2}$.
\begin{thm}
\label{thm:f_g_3_props}Если алгоритм не останавливается на некоторых
входных данных, то после некоторого конечного шага множество $G$
содержит пару отмеченных многочленов $f',f$, причём $f$ сгенерирован
после $f'$ и выполняются следующие 3 свойства:

\[
\HM(f')|\HM(f),
\]


\[
\frac{\HM(f')}{\Sig(f')}>_{q}\frac{\HM(f)}{\Sig(f)},
\]


\[
\Sig(f')|\Sig(f).
\]
\end{thm}
\begin{proof}
При работе с цепями S-пар является важным тот факт, что многочлен
никогда не редуцируется дальше, после того как он был использован
для создания S-пары в качестве старей по сигнатуре части. Факт выполняется,
поскольку все многочлены, которые ещё могут быть подвергнуты редукции
находятся в множестве $ToDo$, а все многочлены, используемые как
старшая часть S-пары, находятся в $G$ или в $Done$. Поэтому можно
утверждать, что многочлен $h_{n}$, предшествующий многочлену$h_{n+1}$
в цепи S-пар, сохраняет одно и то же значение $\poly(h_{n})$ после
того как был использован для создания какой-либо S-пары. и можно утверждать,
что
\[
\poly(h_{n+1})=c\frac{\Sig(h_{n+1})}{\Sig(h_{n})}\poly(h_{n})+g_{n},
\]
где $g_{n}$ многочлен, соответствующей младшей части S-пары, использованный
при генерации $h_{n+1}$ из $h_{n}$, и удовлетворяет следующему:
\begin{equation}
\HM(h_{n+1})<\HM\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)=\HM(g_{n}),\,\Sig(h_{n+1})=\Sig\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right)\succ\Sig(g_{n}).\label{eq:spair-chain}
\end{equation}
Из первого неравенства в \ref{eq:spair-chain} получаем, что $\frac{\HM(h_{n})}{\Sig(h_{n})}>_{q}\frac{\HM(h_{n+1})}{\Sig(h_{n+1})}$,
поэтому в цепи S-пар частные $\frac{\HM(h_{i})}{\Sig(h_{i})}$ строго
убывают в смысле порядка на частных. Этот факт не может быть напрямую
использован для доказательства конечности цепей, поскольку порядок
на частных, в отличии от порядка на мономах, не даёт вполне упорядоченности:
к примеру последовательность $\frac{x}{x}>_{q}\frac{x}{x^{2}}>_{q}\cdots>_{q}\frac{x}{x^{n}}>_{q}\cdots$
является бесконечно убывающей.

Существует две возможности для отношения между $\HM$ соседних элементов.
Известно, что $\Sig(h_{n})|\Sig(h_{n+1})$, поэтому они или имеют
равные сигнатуры, или $\totaldeg(h_{n})<\totaldeg(h_{n+1})$. В первом
случае $\HM(h_{n+1})<\HM(h_{n})$ при равенстве полной степени, а
во втором -- $\HM(h_{n+1})>\HM(h_{n})$, поскольку полные степени
$\HM$ отличаются. Поэтому, последовательность$\HM$ элементов бесконечной
цепи S-пар состоит из блоков с фиксированной полной степенью, где
$\HM$ внутри блока строго убывают. Длтны блоков могут быть равными
единице, и полные степени блоков возрастают. Это приводит к следующим
свойствам: цепь S-пар $\{h_{i}\}$ не может содержать элементов с
равными $\HM$ и $\HM(h_{i})|\HM(h_{j})$ возможно только в случае
$i<j$ и $\totaldeg(h_{i})<\totaldeg(h_{j})$.

Это позволяет использовать метод аналогичный используемому в Предложении
14 работы \cite{TheF5Revised}: рассмотрим $\HM$ бесконечной цепи
S-пар $\{h_{i}\}$. Они порождают бесконечную последовательность в
$T$, поэтому по лемме Диксона существует два многочлена, с $\HM(h_{i})|\HM(h_{j})$.
Из предыдущего абзаца следует, что при этом $i<j$, а при помощи свойств
цепи S-пар мы получаем, что $\Sig(h_{i})|\Sig(h_{i+1})|\cdots|\Sig(h_{j})$
и $\frac{\HM(h_{i})}{\Sig(h_{i})}>_{q}\frac{\HM(h_{i+1})}{\Sig(h_{i+1})}>_{q}\cdots>_{q}\frac{\HM(h_{j})}{\Sig(h_{j})}$,
поэтому можно взять $f'=h_{i}$ и $f=h_{j}$.
\end{proof}
Последнее свойство о делимости сигнатур из утверждения теоремы является
побочным эффектом от использования цепей S-пар и не используется в
дальнейшем. При этом первые два свойства используются для построения
сигнатурного редуктора.
\begin{fact}
Если никакие многочлены не были отброшены проверками критериев (b)
и (c) в \texttt{IsReducible}, рассматриваемый алгоритм завершается.\end{fact}
\begin{proof}
Данное выше доказательство теоремы \ref{thm:f_g_3_props} не опирается
на соответствие между порядками на сигнатурах и мономах многочленов.
Но алгоритм F5 использует один и тот же порядок в обоих случаях, и
теперь мы можем воспользоваться этим фактом и переформулировать отношение
на частных мономов из теоремы \ref{thm:f_g_3_props} в отношение на
сигнатурах: 
\[
\Sig(f)\succ t\cdot\Sig(f'),\mbox{ где }t=\frac{\HM(f)}{\HM(f')}\in T.
\]
Это неравенство вместе с делимостью $\HM$ из утверждения теоремы
показывает, что $tf'$ является редуктором для $f$ в \texttt{TopReduction}
с точки зрения сигнатуры -- он проходит проверки (a) и (d) внутри
\texttt{IsReducible} и его сигнатура меньше. При отсутствии проверки
критериев (b) и (c) это напрямую приводило бы к противоречию, так
как в момент добавления $f$ в $G$ отмеченный многочлен $f'$ уже
был там и процедура \texttt{TopReduction} должна была бы редуцировать
$f$ по $f'$.
\end{proof}
Но существование критериев делает возможной ситуацию, в которой $tf'$
отбрасывается проверками (b) или (c) процедуры \texttt{IsReducible}.
Идея дальнейших рассуждений состоит в том, чтоб показать что в этом
случае может быть найден другой сигнатурный редуктор $f$, который
не будет отброшен проверками и таким образом прийти к противоречию.
Последующие главы работы посвящены этому.


\section{S-пары с сигнатурами, меньшими $\Sig(g)$}

В этой и последующих частях $g$ подразумевается некоторым фиксированным
многочленом с индексом сигнатуры 1, добавленный на некоторой итерации
алгоритма в $Done$. Мы будем анализировать состояние алгоритма в
момент непосредственно предшествующий добавлению $g$ в $Done$ в
вызове \texttt{AlgorithmF5} с $i=1$. Рассмотрим в этот момент конечное
множество отмеченных многочленов $G_{1}\cup Done$. Оно состоит из
чисел, являющихся позиций отмеченных многочленов в $R$, поэтому его
элементы могут быть упорядочены в соответствии с позицией в $R$ и
оно окажется записанным в виде упорядоченной последовательности целых
чисел $G_{g}=\{b_{1},\ldots,b_{N}\}$ с $b_{j}<b_{j+1}$. Необходимо
отметить, что этот порядок соответствует порядку отмеченных многочленов
в последовательности, получаемой склеиванием массивов правил $Rule[m]:Rule[m-1]:\cdots:Rule[1]$,
поскольку добавление нового многочлена в $R$ всегда сопровождается
добавлением соответствующего правила. Но этот порядок может отличаться
от порядка в котором многочлены добавлялись в множество $G_{1}\cup Done$,
поскольку многочлены одной полной степени добавляются в $Done$ в
порядке возрастания сигнатуры, при том что добавление многочленов
одной полной степени в $R$ производится в довольно случайном порядке
в процедурах \texttt{Spol} и \texttt{TopReduction}. Далее для простоты
мы будем говорить о отмеченных многочленах $b_{j}$ в $G_{g}$, подразумевая
что $G_{g}$ является не упорядоченным списком позиций, а упорядоченным
списком отмеченных многочленов, расположенных на этих позициях. В
этой терминологии можно сказать, что все входные многочлены $\left\{ f_{1},\ldots,f_{m}\right\} $
присутствуют в $G_{g}$, поскольку они присутствуют в $G_{1}$ в момент
его создания.

S-пары могут обрабатываться в алгоритме различным путями, но главный
факт, описывающий порядок их обработки выражается следующими свойствами,
соответствующими свойствам, использованным в Теореме 21 работы \cite{F5C},
но рассматриваются на произвольной итерации алгоритма, а не после
его остановки.
\begin{thm}
\label{thm:Exist-gg-repr}К моменту добавления $g$ в $Done$ каждая
S-пара элементов $G_{g}$, сигнатура которой меньше $\Sig(g)$ удовлетворяет
одному из трёх свойств:\end{thm}
\begin{enumerate}
\item S-пара имеет часть, которая была отброшена критерием проверки нормальной
формы $\varphi$ (в \texttt{CritPair} или в \texttt{IsReducible}).
Такие S-пары будут называться \emph{S-парами с частью, удовлетворяющей
критерию F5}. 
\item S-пара имеет часть, которая была отброшена проверкой \texttt{Rewritten?}
(в \texttt{SPol} или в \texttt{IsReducible}). Такие S-пары будут называться
\emph{S-парами с частью, удовлетворяющей критерию Перезаписи}.
\item S-пара не была отброшена, поэтому её S-многочлен был сигнатурно редуцирован
по некоторым элементам $G_{g}$ и результат был добавлен как элемент
$G_{g}$. Такие S-пары будут называться \emph{S-парами с известным
$G_{g}$-представлением}.\end{enumerate}
\begin{proof}
S-пары элементов $G_{g}$ обрабатываются в алгоритме двумя основными
путями. Основной путь используется для S-пар, полная степень которых
больше чем полная степень породивших их многочленов. Такие S-пары
обрабатываются в следующем порядке:
\begin{itemize}
\item в процедуре \texttt{AlgorithmF5} они рассматриваются функцией \texttt{CritPair}
при перемещении элементов $G_{i}$ из $R_{d}=Done$ и при обработке
входного многочлена $r_{i}$
\item функция \texttt{CritPair} или отбрасывает пару после проверки нормальной
формы $\varphi$ или добавляет пару в $P$
\item S-пара извлекается из $P$ и передаётся в функцию \texttt{SPol}
\item функция \texttt{SPol} или отбрасывает пару после проверки \texttt{Rewritten?}
или добавляет S-многочлен в $F=ToDo$
\item на некоторой итерации процедура \texttt{Reduction} берёт S-многочлен
из $ToDo$, производит некоторые сигнатурные редукции и добавляет
результат в $Done$.
\end{itemize}
Второй путь обработки используется для S-пар, соответствующих редукциям,
запрещённым алгоритмом -- соответствующие S-пары порождаются многочленами
$r_{l^{*}}$ и $r_{l_{*}}$, такими что $\HM(r_{l^{*}})|\HM(r_{l_{*}})$,
и S-многочлен им соответствующий имеет вид $\overline{u_{l}}\cdot\poly(r_{l^{*}})-1\cdot\poly(r_{l_{*}})$.
Такая ситуация возможна, если для элементов $G_{g}$ редукция $r_{l_{*}}$
по $r_{l^{*}}$ была запрещена сравнением сигнатур в \texttt{TopReduction}
или проверками в \texttt{IsReducible}. Для этого случая порядок \flqq{}обработки\frqq{}
S-пары такой:
\begin{itemize}
\item часть S-пары $\overline{u_{l}}\cdot r_{l^{*}}$ проверяется в \texttt{IsReducible}.
(a) выполнено, поскольку $\HM(r_{l^{*}})|\HM(r_{l_{*}})$. Она может
быть отброшена другими проверками:

\begin{itemize}
\item отбрасывание пунктом (b) соответствует проверке нормальной формы $\varphi$
для $\overline{u_{l}}\cdot r_{l^{*}}$
\item отбрасывание пунктом (c) соответствует проверке \texttt{Rewritten?}
для $\overline{u_{l}}\cdot r_{l^{*}}$
\item отбрасывание пунктом (d) означает, что один из многочленов $\overline{u_{l}}\cdot r_{l^{*}}$
и $1\cdot r_{l_{*}}$ может быть перезаписано другим, поэтому, если
S-пара не была отброшена проверкой (c), данный тип отбрасывания означает,
что часть S-пары $1\cdot r_{i_{1}}$ не проходит проверку \texttt{Rewritten?}
\end{itemize}
\item S-пары, не отброшенные в \texttt{IsReducible} возвращаются в \texttt{TopReduction}.
Сравнение сигнатур в \texttt{TopReduction} запрещает редукцию $r_{l_{*}}$
по $r_{l^{*}}$ и помещает вычисленный S-многочлен, соответствующий
S-паре, в множество $ToDo_{1}$
\item процедура \texttt{Reduction} добавляет этот многочлен в $ToDo$
\item последний шаг совпадает для обоих путей обработки S-пар: на некоторой
итерации процедура \texttt{Reduction} берёт S-многочлен из $ToDo$,
производит некоторые сигнатурные редукции и добавляет результат в
$Done$.
\end{itemize}
Из путей обработки S-пар видно, что после окончания обработки каждая
S-пара или редуцирована и добавлена в $Done$ или одна из частей S-пары
была отброшена проверкой нормальной формы $\varphi$ или критерием
\texttt{Rewritten?}. Некоторые S-пары могут оказываться на путях обработки
несколько раз, к примеру это происходит на итерации в \texttt{AlgorithmF5}
со значением $d$, не изменившимся с прошлой итерации. Если S-пара
была отброшена при первой попытке обработки, то она будет точно также
отброшена и на следующей попытке. Если первая обработка добавила редуцированный
многочлен в $Done$, то пара будет отбрасываться при следующих попытках
обработки проверкой\texttt{ Rewritten?} за счёт этого многочлена.
Поэтому все попытки обработки, кроме первой, не дают ничего нового.

Путь обработки не является одной процедурой, и в случае, если алгоритм
не останавливается, некоторые S-пары всегда находятся в середине обработки,
при этом или соответствующая S-пара находится в очереди $P$ или S-многочлен
в очереди $ToDo$. Поэтому необходимо понять, обработка каких S-пар
уже завершилась в рассматриваемый нами момент. Элементы $P$ и $ToDo$
извлекаются в процедурах \texttt{AlgorithmF5} и \texttt{Reduction}
в порядке возрастания сигнатур. S-пары с сигнатурами, меньшими $\Sig(g)$,
могут быть разделены на 3 класса:
\begin{itemize}
\item S-пары с сигнатурой $w$, такой что $\sigidx(w)>\sigidx(\Sig(g))=1$.
Они обрабатывались на предыдущих вызовах \texttt{AlgorithmF5}.
\item S-пары с сигнатурой $w$, такой что $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)<\totaldeg(\Sig(g))$.
Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
\texttt{AlgorithmF5}, который обрабатывает $g$.
\item S-пары с сигнатурой $w$, такой что $\sigidx(w)=\sigidx(\Sig(g))=1,\totaldeg(w)=\totaldeg(\Sig(g)),w\prec\Sig(g)$.
Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
\texttt{Reduce}, который обрабатывает $g$.
\end{itemize}
S-пары из этих классов не могут находиться в середине пути обработки,
потому что в рассматриваемом состоянии алгоритма обработка только
что завершена для $g$, поэтому ни $P$ ни $ToDo$ не содержат необработанных
элементов с сигнатурами, меньшими $\Sig(g)$. Осталось показать, что
для всех S-пар из утверждения теоремы обработка начиналась хотя бы
один раз. Это просто проверить для первых двух классов: обработка
соответствующих S-пар была начата по крайней мере один раз путём вызова
\texttt{CritPair} в \texttt{AlgorithmF5} непосредственно перед тем,
как наибольший из порождающих S-пару был добавлен в $G$. Для S-пар
третьего класса ситуация зависит от полной степени её порождающих.
Если оба порождающих S-пары имеют полную степень $<\totaldeg(g)$,
то её обработка была начата в \texttt{CritPair} аналогично S-парам
первых двух классов. Но некоторые S-пары третьего класса могут иметь
старший по сигнатуре порождающий $r_{l}$, такой что $\totaldeg(r_{l})=\totaldeg(g),\,\Sig(r_{l})\prec\Sig(g)$.
Они обрабатываются вторым из рассмотренных путей обработки S-пар,
поэтому обработка таких S-пар ещё не стартовала к моменту последнего
вызова \texttt{Reduction}. Однако, их обработка начинается внутри
\texttt{Reduction} до изучаемого нами момента: процедура выбирает
многочлены из $ToDo$ в порядке возрастания сигнатуры, поэтому $r_{l}$
редуцируется до $g$ и в процессе редукции $r_{l}$ непосредственно
перед добавлением $r_{l}$ в $Done$ вызов \texttt{TopReduction} начинает
обработку всех таких S-пар.
\end{proof}
Понятие \emph{удовлетворять критерию F5 }и \emph{удовлетворять критерию
Перезаписи} могут быть расширены но произвольные умноженные на моном
отмеченные многочлены $sh,\, h\in G_{g}$:
\begin{defn}
Умноженный на моном отмеченный многочлен  $sr_{i},\, r_{i}\in G_{g}$
называется \emph{удовлетворяющим критерию F5}, если $\varphi_{index(r_{i})+1}(s\Sig(r_{i}))\ne s\Sig(r_{i})$,
где $\varphi_{index(r_{i})+1}$ -- оператор нормальной формы по отношению
к $G_{index(r_{i})+1}$.
\end{defn}
Это определение эквивалентно тому, что $sr_{i}$ является не-нормализованным
отмеченным многочленом с точки зрения определения 2 в части 5 работы
\cite{FaugereF5}.
\begin{defn}
Умноженный на моном отмеченный многочлен $sr_{i},\, r_{i}\in G_{g}$
называется \emph{удовлетворяющим критерию Перезаписи}, если $\exists j>i$
такое что $\Sig(r_{j})|s\Sig(r_{i})$.
\end{defn}
В случае, если $sr_{i}$ является частью S-пары, эти определения эквиваленты
проверкам, производимым в алгоритме, в том смысле, что часть S-пары
отбрасывается алгоритмом тогда и только тогда, когда она удовлетворяет
данному определению как умноженный на моном отмеченный многочлен.
Для обоих критериев выполняется важное свойство, утверждающее, что
если $sr_{i}$ удовлетворяет критерию, то то и дополнительно домноженный
многочлен $s_{1}sr_{i}$ $ $также ему удовлетврояет.


\section{Representations}


\subsection{Definition}

The idea of representations comes from \cite{F5C}, where a similar
method is used in the proof of Theorem 21. Representations are used
to describe all possible ways how a labeled polynomial $p$ can be
written as an element of $\left(G_{g}\right)$ ideal. The single representation
corresponds to writing a labeled polynomial $p$ as any finite sum
of the form
\begin{equation}
p=\sum_{k}m_{k}\cdot b_{i_{k}},\; b_{i_{k}}\in G_{g}\label{eq:Gg-repr-def}
\end{equation}
with coefficients $m_{k}=c_{k}t_{k}\in\mathcal{K}\times T$. 
\begin{defn}
Sum of the form \ref{eq:Gg-repr-def} with all pairs $\left(t_{k},b_{i_{k}}\right)$
distinct is called \emph{$G_{g}$-representation} of $p$. The symbolic
products $m_{k}\cdot b_{i_{k}}$ are called the \emph{elements} of
representation. If we treat this symbolic product as multiplication
we get an labeled polynomial $m_{k}b_{i_{k}}$ corresponding to the
representation element. So $p$ is equal to sum of labeled polynomials,
corresponding to elements of its representation. Also the term \emph{element
signature} will be used for signature of labeled polynomials corresponding
to the element. Two representations are equal if the sets of their
elements are equal.
\end{defn}
Most representations we are interested in have the following additional
property limiting elements signature:
\begin{defn}
The $G_{g}$-representation of $p$ is called \emph{signature-safe}
if $\forall k\,\Sig(m_{k}b_{i_{k}})\preccurlyeq\Sig(p)$.
\end{defn}

\subsection{Examples}
\begin{example}
The first important example of a $G_{g}$-representation is trivial:
the labeled polynomial from $G_{g}$ is equal to sum of one element,
identity-multiplied itself: 
\[
b_{j}=1\cdot b_{j}.
\]

\end{example}
This $G_{g}$-representation is signature-safe. The prohibition of
two elements which have same monomial $t_{k}$ and polynomial $b_{i_{k}}$
ensures that all elements of representation that differ only in field
coefficient $c_{k}$ are combined together by summing field coefficients.
So expressions like $b_{j}=-1\cdot b_{j}+2\cdot b_{j}$ and $b_{j}=2x\cdot b_{k}+1\cdot b_{j}-2x\cdot b_{k}$
are not valid $G_{g}$-representations.
\begin{example}
A labeled polynomial $b_{j}\in G_{g}$ multiplied by arbitrary polynomial
$h$ also have a simple $G_{g}$-representation arising from splitting
$h$ into terms: $h=\sum_{k}m_{k},\, m_{k}\in\mathcal{K}\times T$.
This $G_{g}$-representation has form 
\begin{equation}
b_{j}h=\sum_{k}m_{k}\cdot b_{j}\label{eq:repr-ex-2}
\end{equation}
and is signature-safe too.
\end{example}
A labeled polynomial can have arbitrary number of representations:
for example we can add elements corresponding to a syzygy to any representation
and combine elements with identical monomials and polynomials to get
the correct representation. The result will be representation of the
same polynomial because sum of syzygy elements is equal to 0.
\begin{example}
The product of two polynomial from $G_{g}$ has two representations
of the form (\ref{eq:repr-ex-2}) which differs in syzygy addition:
\end{example}
\[
b_{j}b_{i}=\sum_{k}m_{i_{k}}\cdot b_{j}=\sum_{k}m_{i_{k}}\cdot b_{j}+0=\sum_{k}m_{i_{k}}\cdot b_{j}+\left(\sum_{k}m_{j_{k}}\cdot b_{i}-\sum_{k}m_{i_{k}}\cdot b_{j}\right)=\sum_{k}m_{j_{k}}\cdot b_{i},
\]
where $m_{i_{k}}$ are terms of $b_{i}$ and $m_{j_{k}}$ are terms
of $b_{j}$.
\begin{example}
The zero polynomial has an empty representation and an representation
for every syzygy:
\end{example}
\[
0=\sum_{\emptyset}\mbox{(empty sum)}=\sum_{k}m_{j_{k}}\cdot b_{i}+\sum_{k}(-m_{i_{k}})\cdot b_{j},
\]
where $m_{i_{k}}$ and $m_{j_{k}}$ are same as above.

Another important example of $G_{g}$-representation comes from ideal
and signature definitions. All labeled polynomials computed by the
algorithm are elements of ideal $\left(f_{1},\ldots,f_{m}\right)$.
So any labeled polynomial $p$ can be written as $ $$\sum_{i}f_{i}g_{i}$,
where $g_{i}$ are homogeneous polynomials. All input polynomials
$f_{i}$ belong to $G_{g}$, so $f_{i}g_{i}$ has $G_{g}$-representations
of the form (\ref{eq:repr-ex-2}).
\begin{example}
Those representations sum give the following signature-safe representation:
\[
p=\sum_{k}m_{k}\cdot b_{i_{k}},\, m_{k}\in\mathcal{K}\times T,\, b_{i_{k}}\in\left\{ f_{1},\ldots,f_{m}\right\} \subset G_{g}.
\]
\end{example}
\begin{defn}
This particular case of $G_{g}$-representation where $b_{i_{k}}$
are limited to input polynomials will be called \emph{input-representation}.
\end{defn}
Input representations always has the only element with maximal signature.
This property is special to input-representations because generic
$G_{g}$-representations can have multiple elements with same maximal
signature -- it is possible to have $m_{1}\Sig(b_{i_{1}})=m_{2}\Sig(b_{i_{2}})$
while $i_{1}\ne i_{2}$.

The following claim makes important connection between signatures
and input-representations:
\begin{claim}
An admissible labeled polynomial $p$ with known signature $\Sig(p)$
has an input-representation consisting of an element $c\Sig(p)\cdot f_{index(p)}$
and some other elements with smaller signatures.\end{claim}
\begin{proof}
The claimed fact follows from the admissible polynomial definition
in \cite{FaugereF5} referring to function $v$ which correspond to
summing representation elements.
\end{proof}
The theorem 1 of \cite{FaugereF5} states that all polynomials in
the algorithm are admissible, do the above claim will be applied to
all appeared polynomials.
\begin{example}
\label{example-of-having-gg-repr}The last example comes from S-pairs
with a computed $G_{g}$-representation. S-polynomial of $b_{l^{*}}$
and $b_{l_{*}}$ from $G_{g}$ is $p=\overline{u_{l}}\poly(b_{l^{*}})-\underline{u_{l}}\poly(b_{l_{*}})$.
It is known from reduction process that for such S-pairs $p$ is signature-safe
reduced and the result is added to $G_{g}$ as some labeled polynomial
$b_{l}$. So the $G_{g}$-representation is:
\end{example}
\[
p=\sum_{k}m_{k}\cdot b_{n_{k}}+1\cdot b_{l},
\]
where signatures of $m_{k}\cdot b_{n_{k}}$ elements are smaller than
$\Sig(b_{l})=\Sig(p)$. The value of $l$ is position of $b_{l}$
in ordered list $G_{g}$. In this representation $l$ is greater than
$l^{*}$ and $l_{*}$ because corresponding labeled polynomial $b_{l}$
is added to $R$ at the moment of S-polynomial computation in \texttt{Spol}
or \texttt{TopReduction} so the polynomials $b_{l^{*}}$ and $b_{l_{*}}$
used to create S-pair already present in $R$ at that moment and the
order of $G_{g}$ correspond to order of $R$.


\subsection{Ordering representations}
\begin{defn}
To order $G_{g}$-representations we start from \emph{representation
elements ordering} $\gtrdot_{1}$: we say that $c_{i}t_{i}\cdot b_{i}\gtrdot_{1}c_{j}t_{j}\cdot b_{j}$
if one of the following cases holds:
\begin{itemize}
\item $t_{i}\Sig(b_{i})\succ t_{j}\Sig(b_{j})$ 
\item $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$ and $i<j$ (note the opposite
order).
\end{itemize}
\end{defn}
This ordering is based only on comparison of signatures and positions
of labeled polynomials in the ordered list $G_{g}$ but does not depend
on the field coefficient. The only case in which two elements can't
be ordered is equality of both signatures $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
and positions in list $i=j$. Position equality means $b_{i}=b_{j}$
which in conjunction with signature equality gives $t_{i}=t_{j}$.
So any two elements that belong to a single $G_{g}$-representation
are comparable with $\lessdot_{1}$ order because they have distinct
$\left(t_{k},b_{k}\right)$ by definition. Below are given some examples
of $\lessdot_{1}$ element ordering for the 3-element list $G_{g}=\left\{ b_{1},\, b_{2},\, b_{3}\right\} $
with ordering $x\mathbf{F}_{i}\succ y\mathbf{F}_{i}$ and signatures
$\Sig(b_{1})=\mathbf{F}_{1},\Sig(b_{2})=\mathbf{F}_{2},\Sig(b_{3})=x\mathbf{F}_{1}$.
\begin{itemize}
\item $y\cdot b_{1}\gtrdot_{1}100y\cdot b_{2}$ because signature of left
side is $\succ$
\item $x\cdot b_{1}\gtrdot_{1}y\cdot b_{1}$ because signature of left side
is $\succ$
\item $-x\cdot b_{1}$ and $2x\cdot b_{1}$ are not comparable because signatures
and list indexes are equal
\item $y^{2}\cdot b_{1}\lessdot_{1}y\cdot b_{3}$ because signature of left
side is $\prec$
\item $x^{2}\cdot b_{1}\gtrdot_{1}x\cdot b_{3}$ because signatures are
equal and the list position of left side's labeled polynomial is
1 which is smaller than right side's position 3.
\end{itemize}
To extend this order to entire $G_{g}$-representations consider \emph{ordered
form} of representation consisting of all its elements written in
a list with $\gtrdot_{1}$-decreasing order. This form can be used
for equality testing because if two representations are equal then
they have exactly equal ordered forms.
\begin{defn}
With ordered forms the \emph{$G_{g}$-representations ordering} can
be introduced: the representation $\sum_{k}m'_{k}\cdot b_{i'_{k}}$
is $\lessdot$-smaller than $\sum_{k}m_{k}\cdot b_{i_{k}}$ if the
ordered form of the first representation is smaller than second's
according to lexicographical extension of $\lessdot_{1}$ ordering
on elements. For the corner case of the one ordered form being beginning
of the other the shorter form is $\lessdot$-smaller. If the greatest
different elements of ordered forms differ only in field coefficient
the representations are not comparable.
\end{defn}
Some examples of this ordering are given for the same as above 3-element
$G_{g}$ list. Note that all $G_{g}$-representations are already
written in ordered forms:
\begin{itemize}
\item $x^{2}\cdot b_{1}+xy\cdot b_{1}+y^{2}b_{1}\gtrdot x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}$
because $xy\cdot b_{1}\gtrdot y^{2}\cdot b_{1}$
\item $x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}\gtrdot x^{2}\cdot b_{1}$ because
the right ordered form is beginning of the left
\item $x^{2}\cdot b_{1}\gtrdot xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
because $x^{2}\cdot b_{1}\gtrdot xy\cdot b_{1}$
\item $xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}\gtrdot y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
because $xy\cdot b_{1}\gtrdot y\cdot b_{3}$
\item $y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$ and $2y\cdot b_{3}+y^{2}\cdot b_{2}$
are not comparable because the greatest different elements are $y\cdot b_{3}$
and $2y\cdot b_{3}$.
\end{itemize}
The ordering is compatible with signature-safety:
\begin{thm}
If two representations of $p$ has a relation $\sum_{k}m'_{k}\cdot b_{i'_{k}}\lessdot\sum_{k}m_{k}\cdot b_{i_{k}}$
and the second one is signature-safe representation then the first
one is signature-safe too.\end{thm}
\begin{proof}
This theorem quickly follows from a fact that elements of a $\lessdot$-smaller
representation can't has signatures $\succ$-greater than signatures
of $\gtrdot$-greater representation.
\end{proof}
The key fact allowing to take $\lessdot$-minimal element is well-orderness:
\begin{thm}
The representations are well-ordered with $\lessdot$ ordering.\end{thm}
\begin{proof}
The number of different labeled polynomial positions is finite because
it is equal to $|G_{g}|$ which is finite for fixed $g$. So the existence
of infinite $\gtrdot_{1}$-descending sequence of representation elements
would lead to existence of infinite $\succ$-descending sequence of
signatures. Combining this with well-orderness of signatures with
ordering $\prec$ we get the proof for well-orderness of elements
with ordering $\lessdot{}_{1}$.

The straightforward proof for $\lessdot$-well-orderness of representations
following from $\lessdot_{1}$-well-orderness of elements is not very
complex but to skip its strict details the theorem 2.5.5 of \cite{Baader.Nipkow98Term}
will be referenced. It states well-orderness of finite multiset with
an lexicographically extended ordering of well-ordered elements. This
applies to the representations because they form a subset in the finite
multiset of representation elements.
\end{proof}

\subsection{Sequence of representations}

The idea of this part is constructing a finite sequence of strictly
$\lessdot$-descending signature-safe $G_{g}$-representations for
a given labeled polynomial $mh,\, m\in\mathcal{K}\times T,\, h\in G_{g}$
with $\Sig(mh)\prec\Sig(g)$. The first signature-safe representation
in the sequence is $mh=m\cdot h$, the last representation is $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
with elements having the following properties $\forall k$:
\begin{enumerate}
\item $m_{k}b_{i_{k}}$ does not satisfy F5 criterion.
\item $m_{k}b_{i_{k}}$ does not satisfy Rewritten criterion.
\item $\HM(m_{k}b_{i_{k}})\leqslant\HM(mh)$
\end{enumerate}
The proof of such sequence existence is very similar to Theorem 21
of \cite{F5C} and is based on a fact, that if a some signature-safe
representation of $mh$ contains an element $m_{K}\cdot b_{i_{K}}$
not having one of the properties then a $\lessdot$-smaller representation
can be constructed. The exact construction differ for three cases
but the replacement scheme is the same:
\begin{itemize}
\item a some element $m_{K'}\cdot b_{i_{K'}}$ in $mh$ representation is
selected. Note that $K'$ in some cases is not equal to $K$
\item some representation $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
is constructed for this element.
\item it is shown that constructed representation is $\lessdot$-smaller
than representation $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$ 
\end{itemize}
Construction of such representation for $m_{K'}\cdot b_{i_{K'}}$
allows application of the following lemma:
\begin{lem}
If an element $m_{K'}\cdot b_{i_{K'}}$ of signature-safe representation
$mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ has an representation $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
which is $\lessdot$-smaller than representation $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
then $mh$ has a signature-safe representation $\lessdot$-smaller
than $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$.\end{lem}
\begin{proof}
We replace $m_{K'}\cdot b_{i_{K'}}$ in $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
by $\sum_{l}m_{l}\cdot b_{i_{l}}$ and combine coefficients near elements
with both monomial and polynomial equal, so a modified representation
for $mh$ appears. Is is $\lessdot$-smaller than $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
because all elements $\gtrdot_{1}$-greater than $m_{K'}\cdot b_{i_{K'}}$
are identical in both representations if they present but the element
 $m_{K'}\cdot b_{i_{K'}}$ is contained in original representation
but not in the modified. And all other elements in representations
are $\lessdot_{1}$-smaller than $m_{K'}\cdot b_{i_{K'}}$ so they
does not influence the comparison. The comparison holds even in a
corner case when all elements are discarded while combining coefficients.
This case can appear if the original representation is equal to $mh=m_{K'}\cdot b_{i_{K'}}+\sum_{l}(-m_{l})\cdot b_{i_{l}}$
what leads to modified representation $mh=0$ with zero elements which
is $\lessdot$-smaller than any non-empty representation.
\end{proof}
Now it will be shown that replacement scheme can be performed if the
representation contains an element not satisfying at least one of
three properties.
\begin{lem}
If a signature-safe $G_{g}$-representation $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
does not satisfy property 1 then there exists an element $m_{K'}\cdot b_{i_{K'}}$
having $G_{g}$-representation $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
which is $\lessdot$-smaller than representation $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
.
\end{lem}
An element not having the first property does satisfy the F5 criterion
and the idea is to use that $m_{K}\Sig(b_{i_{K}})$ is not the minimal
signature of $m_{K}b_{i_{K}}$ like in Theorem 20 of \cite{F5C}.
$K'=K$ is taken for this case.
\begin{proof}
Consider input-representation of $m_{K}b_{i_{K}}$ with signature
of $\gtrdot_{1}$-maximal element equal to $m_{K}\Sig(b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$:

\begin{equation}
m_{K}b_{i_{K}}=c_{0}s_{0}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.\label{eq:input-repr-case1}
\end{equation}
From the satisfying F5 criterion $s_{0}$ can be expressed like $s_{0}=s_{1}\HM(f_{j_{1}}),\, j_{1}>j_{0}$
so $s_{0}f_{j_{0}}=s_{1}f_{j_{0}}f_{j_{1}}-s_{1}(f_{j_{1}}-\HM(f_{j_{1}}))f_{j_{0}}$.
From this we can write another representation for $m_{K}b_{i_{K}}$,
assuming $m_{0i}$ are sorted terms of $f_{j_{0}}$, $m_{1i}$ are
sorted terms of $f_{j_{1}}$ and $N_{0,}N_{1}$ are number of terms
in those polynomials:

\[
m_{K}b_{i_{K}}=\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}+\sum_{i=2}^{N_{1}}-c_{0}s_{1}m_{1i}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.
\]
This representation is $\lessdot$-smaller than $m_{K}\cdot b_{i_{K}}$
because signatures of all elements are smaller than $s_{0}\mathbf{F}_{j_{0}}$.
For the elements of the third sum $\sum_{l}m_{l}\cdot f_{i_{l}}$
this follows from \textbf{\ref{eq:input-repr-case1}}, where those
elements are smaller elements of input-representation. For the elements
of the first sum $\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}$
this follows from the position inequality $j_{1}>j_{0}$. And for
the second sum we use the equality in term and signature orderings:
all terms $m_{1i},\, i\geqslant2$ are smaller than $m_{11}$, so
the signatures are: $s_{1}m_{1i}\mathbf{F}_{j_{0}}\prec s_{1}m_{11}\mathbf{F}_{j_{0}}=s_{0}\mathbf{F}_{j_{0}}$. \end{proof}
\begin{lem}
If a signature-safe $G_{g}$-representation $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
with $\Sig(mh)\prec\Sig(g)$ does not satisfy property 2 then there
exists an element $m_{K'}\cdot b_{i_{K'}}$ having $G_{g}$-representation
$m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$ which is $\lessdot$-smaller
than representation $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$ \textup{.}
\end{lem}
For the elements not satisfying case 2 the $\lessdot$-smaller representation
is created in a way used in Proposition 17 of \cite{F5C}. $K'=K$
is taken for this case too.
\begin{proof}
Assume that $\Sig(m_{K}b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$ and it
is rewritten by labeled polynomial $b_{i'}$ from $R$. Because the
representation is signature-safe we have $\Sig(b_{i'})\preccurlyeq s_{0}\mathbf{F}_{j_{0}}\preccurlyeq\Sig(mh)\prec\Sig(g)$.
So $b_{i'}$ was processed in \texttt{TopReduction} before $g$. Since
$b_{i'}$ is rewriter we have $b_{i'}\ne0$. All this gives the fact
that $b_{i'}$ does present not only in $R$ but in $G_{g}$ too so
it can be used as a polynomial of $G_{g}$-representation element.
From the Rewritten criterion definition we know that $i'>i_{K}$ and
the existence of $s'\in T$ such that $s'\Sig(b_{i'})=s_{0}\mathbf{F}_{j_{0}}$.
So, for the $m_{K}b_{i_{K}}$ there is an input-representation \ref{eq:input-repr-case1}
and for the $s'b_{i'}$ the input-representation is:

\[
s'b_{i'}=c's_{0}\cdot f_{j_{0}}+\sum_{l'}m_{l'}\cdot f_{i_{l'}}.
\]
A $G_{g}$-representation for $c_{0}s_{0}f_{j_{0}}$ can be acquired
with transformation of the above expression:

\[
c_{0}s_{0}f_{j_{0}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}.
\]
Using this to replace the first element in \ref{eq:input-repr-case1}
we get the wanted result:
\[
m_{K}b_{i_{K}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}+\sum_{l}m_{l}\cdot f_{i_{l}}
\]
It is $\lessdot$-smaller than $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$
because elements of both sums has signatures smaller than $s_{0}\mathbf{F}_{j_{0}}$,
and for the first element $ $$\Sig(c'^{-1}c_{0}s'\cdot b_{i'})=\Sig(m_{K}\cdot b_{i_{K}})=s_{0}\mathbf{F}_{j_{0}}$
but $i'>i_{K}$, so applying the $\lessdot_{1}$-comparison rule for
equal signatures and different list positions we get that element
$c'^{-1}c_{0}s'\cdot b_{i'}$ is $\lessdot_{1}$-smaller than $m_{K}\cdot b_{i_{K}}$
too.\end{proof}
\begin{lem}
If a signature-safe representation $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
with $\Sig(mh)\prec\Sig(g)$ satisfies properties 1 and 2 but does
not satisfy property 3 then there exists an element $m_{K'}\cdot b_{i_{K'}}$
having representation $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
which is $\lessdot$-smaller than representation $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$.\end{lem}
\begin{proof}
There exists at least one element $m_{K}\cdot b_{i_{K}}$ that does
not satisfy property 3. Let $m_{\max}$ be the maximal $\HM$ of labeled
polynomials corresponding to representation elements and $H_{\max}$
be a list of elements where $m_{\max}$ is achieved. Select $K'$
to be the index of the $\gtrdot_{1}$-greatest representation element
in $H_{\max}$. We have $ $$\HM(m_{K'}b_{i_{K'}})=m_{\max}\geqslant\HM(m_{K}b_{i_{K}})>\HM(mh)$,
so the $\HM$ of sum of all elements except $K'$ is equal to $\HM(mh-m_{K'}b_{i_{K'}})=\HM(m_{K'}b_{i_{K'}})=m_{\max}$,
so there is another element $K''$ having $\HM(m_{K''}b_{i_{K''}})=m_{\max}$.
So, $m_{K''}\cdot b_{i_{K''}}\in H_{\max}$ and $m_{K''}\cdot b_{i_{K''}}\lessdot_{1}m_{K'}\cdot b_{i_{K'}}$
because of $ $$m_{K'}\cdot b_{i_{K'}}$ $\gtrdot_{1}$-maximality
in $H_{\max}$.

The $\HM(m_{K''}b_{i_{K''}})=\HM(m_{K'}b_{i_{K'}})$ means that a
critical pair of $b_{i_{K'}}$ and $b_{i_{K''}}$ has the form $[m'^{-1}m_{\max},\, m'^{-1}m_{K'},\, b_{i_{K'}},\, m'^{-1}m_{K''},\, b_{i_{K''}}]$
where $m'=\mbox{gcd}(m_{K'},m_{K''})$. Let $q$ be corresponding
S-polynomial. Then $m'\Sig(q)\preccurlyeq\Sig(mh)\prec\Sig(g)$ because
$m'\Sig(q)=\Sig(m_{K'}b_{i_{K'}})$ and the representation is signature-safe.
The S-polynomial parts $m'^{-1}m_{K'}b_{i_{K'}}$ and $m'^{-1}m_{K''}b_{i_{K''}}$
does not satisfy F5 and Rewritten criteria because their forms multiplied
by $m'$ are $m_{K'}b_{i_{K'}}$ and $m_{K''}b_{i_{K''}}$ -- labeled
polynomials corresponding to elements which are known not to satisfy
both criteria by assumption. Therefore $m'\Sig(q)\prec\Sig(g)$ and
$\Sig(q)\prec\Sig(g)$. It follows from this with theorem \ref{thm:Exist-gg-repr}
that the S-pair $(b_{i_{K'}},b_{i_{K''}})$ is S-pair with computed
$G_{g}$-representation, what means that there is an representation
described in example \ref{example-of-having-gg-repr} :

\[
q=1\cdot b_{i'}+\sum_{l}m_{l}\cdot b_{i_{l}},
\]
satisfying the properties shown after that example: $\Sig(q)=\Sig(b_{i'})$,
$\forall l\,\Sig(q)\succ\Sig(m_{l}b_{i_{l}})$ and $i'>K'$.

From the other hand we have $m'q=c_{0}m_{K'}b_{i_{K'}}-c_{1}m_{K''}b_{i_{K''}}$,
so we get the following representation:
\[
m_{K'}b_{i_{K'}}=c_{0}^{-1}c_{1}m_{K''}\cdot b_{i_{K''}}+c_{0}^{-1}m'\cdot b_{i'}+\sum_{l}c_{0}^{-1}m'm_{l}\cdot b_{i_{l}}.
\]
It is $\lessdot$-smaller than $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$: 

$m_{K''}\cdot b_{i_{K''}}$ was already compared to $m_{K'}\cdot b_{i_{K'}}$ 

$m'\cdot b_{i'}$ has the same signature but greater position $i'>i_{K'}$

the last sum contains elements with signatures smaller than $m'\Sig(b_{i'})=\Sig(m_{K'}\cdot b_{i_{K'}})$.\end{proof}
\begin{thm}
\label{thm:exist-smaller-signature-safe-representation}A signature-safe
representation $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ with $\Sig(mh)\prec\Sig(g)$
either satisfies properties 1-3 or there exists a signature-safe representation
$mh=\sum_{l}m_{l}\cdot b_{i_{l}}$ which is $\lessdot$-smaller than
\textup{$\sum_{k}m_{k}\cdot b_{i_{k}}$.}\end{thm}
\begin{proof}
This theorem quickly follows from four previous lemmas together
\end{proof}
This leads to main result:
\begin{thm}
For any labeled polynomial $mh,\, m\in\mathcal{K}\times T,\, h\in G_{g}$
with $\Sig(mh)\prec\Sig(g)$ there exists a signature-safe $G_{g}$-representation
$mh=\sum_{k}m_{k}\cdot b_{i_{k}}$ that satisfies properties 1-3\textup{.}\end{thm}
\begin{proof}
Start with representation $mh=m\cdot h$ and begin replacing it by
$\lessdot$-smaller representation from theorem \ref{thm:exist-smaller-signature-safe-representation}
until the representation satisfying properties 1-3 appears. The finiteness
of the process is guaranteed by $\lessdot$-well-orderness.
\end{proof}
This result may be interesting by itself, but for the purposes of
proving termination only one corollary is needed:
\begin{cor}
\label{cor:all-needed-for-terminaton}Consider an arbitrary polynomial
$f$ without any restrictions on its signature. If there exists a
signature-safe reductor $f'\in G_{g}$ for $f$ with $\Sig(f')\frac{\HM(f)}{\HM(f')}\prec\Sig(g)$
then $G_{g}$ contains a signature-safe reductor for $f$ that is
not rejected by F5 and Rewritten criteria.\end{cor}
\begin{proof}
Let $mf',\, m=\frac{\HM(f)}{\HM(f')}\in\mathcal{K}\times T,\, f'\in G_{g}$
be a multiplied reductor with $\Sig(mf')\prec\Sig(g)$. From the previous
theorem we can find representation $mf'=\sum_{k}m_{k}\cdot b_{i_{k}}$
that satisfies properties 1-3. Property 3 means that there is no elements
with $\HM$'s greater than $mf'$ so because sum of all elements
has $\HM$ equal to $\HM(mf')$ there exists an element $K$ that
achieves $\HM$ equality: $\HM(m_{K}\cdot b_{i_{K}})=\HM(mf')=\HM(f_{1}')$.
Since the representation is signature-safe $\Sig(m_{K}\cdot b_{i_{K}})\preccurlyeq\Sig(mf')\prec\Sig(f)$
so $m_{K}b_{i_{K}}$ is a signature-safe reductor for $f$ and properties
1-2 ensure that $m_{K}b_{i_{K}}$ does not satisfy criteria.
\end{proof}

\section{Finding contradiction with the criteria enabled}

Now return to the result of theorem \ref{thm:f_g_3_props} which states
for the case of algorithm non-termination existence of a polynomials
$f',f\in G$ such that $\HM(f')|\HM(f)$, $\frac{\HM(f')}{\Sig(f')}>_{q}\frac{\HM(f)}{\Sig(f)}$.
Using this result and last corollary we construct two polynomials
leading to contradiction for the case of algorithm non-termination.
\begin{thm}
\label{thm:always-exist-ok-reductor}If the algorithm does not terminate
for some input then after some finite step the set \textup{$G\cup Done$}
contains a pair of labeled polynomials $f'_{1},f$ where:
\begin{itemize}
\item $f'_{1}$ is added to \textup{$G\cup Done$} before $f$
\item $t_{1}f'_{1}$ does not satisfy F5 and Rewritten criteria, where $t_{1}=\frac{\HM(f)}{\HM(f'_{1})}$
\item $f'_{1}$ is signature-safe reductor for $f$.
\end{itemize}
\end{thm}
\begin{proof}
Let $f',f$ be polynomials from the theorem \ref{thm:f_g_3_props}
an define $t=\frac{\HM(f)}{\HM(f')}$. We have $f\in G$ so the above
theory about representations can be applied to the fixed value of
$g$ equal to $f$ and we can speak about $G_{f}$ set and $G_{f}$-representations.
Because $tf'$ is a signature-safe reductor for $f$ we have $\Sig(f')t\prec\Sig(f)$
and the corollary \ref{cor:all-needed-for-terminaton} can be applied
to find a signature-safe reductor $t_{1}f'_{1}$ for $f$ which does
not satisfy criteria. Also it is known to belong to $G_{f}$, so during
the algorithm execution $f'_{1}$ was appended to $G\cup Done$ before
$f$.\end{proof}
\begin{thm}
The original $ $F5 algorithm as described in \cite{FaugereF5} does
terminate for any input.\end{thm}
\begin{proof}
We are going o show that the existence of polynomials $f'_{1},f$
from the theorem \ref{thm:always-exist-ok-reductor} leads to contradiction.
Consider the call to \texttt{TopReduction} after which the polynomial
$f$ was inserted in $Done$. That call returns polynomial $f$ as
first part of \texttt{TopReduction} return value, so the value returned
by \texttt{IsReducible} is empty set. It means that one of conditions
(a) - (d) was not satisfied for all polynomials in $G\cup Done$ including
$f'_{1}$. This is not possible because:
\begin{itemize}
\item (a) is satisfied because $f'_{1}$ is a reductor for $f$ from the
theorem \ref{thm:always-exist-ok-reductor} 
\item (b) and (c) are satisfied because $\frac{\HM(f)}{\HM(f'_{1})}f'_{1}$
does not satisfy F5 and Rewritten criteria from the theorem \ref{thm:always-exist-ok-reductor} 
\item (d) is satisfied because $f'_{1}$ is a signature-safe reductor for
$f$ from the theorem \ref{thm:always-exist-ok-reductor}.
\end{itemize}
\end{proof}

\section{Conclusions}

This paper shows that original F5 algorithm terminates for any homogeneous
input without introducing intermediate algorithms. However, it does
not give any limit on number of operations. The simplest proof of
the termination of Buchberger algorithm is based on Noetherian property
and does not give any such limit too. Unfortunately the termination
proof given here is quite different in structure compared to the proof
of Buchberger algorithm termination, so this proof does not show that
F5 is more efficient than Buchberger in any sense. Unlike this the
termination of the modified versions of F5 algorithm in \cite{Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG}
is shown in a way analogous to Buchberger algorithm and there is room
for comparison of their efficiency with Buchberger's one.

From the point of view of practical computer algebra computations
there is a question about efficiency of the modified versions compared
to original F5. The modified versions can spend more time in additional
termination checks. But for some cases it is possible that those checks
can allow the termination of modified versions before original so
the modified version performs smaller number of reductions. So it
is possible that for some inputs the original algorithm is faster
and for others the modified version. Some experimental timings in
Table 1 in \cite{Modifying-for-termination} shows that both cases
are possible in practice but the difference in time is insignificant.
So the question about efficiency of original F5 compared to modified
versions is open.

This proof uses three properties of original F5 that are absent or
optional in some F5-like algorithms: the homogeneity of input polynomials,
the presence of Rewritten criterion and the equality of monomial order
$<$ and signature order $\prec$. The possibility of extending the
termination proof to the modified algorithms without these properties
is open question. There is an unproved idea that the proof can be
modified to remove reliance on the first two properties but not on
the third property of orders equality because it is key point of coming
to a contradiction form the result of theorem \ref{thm:f_g_3_props}.\\



\thanks{The author would like to thank Christian Eder, Jean-Charles Faug\`{e}re,
Amir Hashemi, John Perry, Till Stagers and Alexey Zobnin for inspiring
me on investigations in this area by their papers and comments. Thanks!}

\bibliographystyle{plain}
\bibliography{f5_references}

\end{document}
