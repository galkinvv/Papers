%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{-1}
\usepackage{babel}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[unicode=true]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}
\AtBeginDocument{\DeclareFontEncoding{T2A}{}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
\theoremstyle{definition}
\newtheorem{defn}[thm]{\protect\definitionname}
\theoremstyle{plain}
\newtheorem{lem}[thm]{\protect\lemmaname}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\vestnikonly}[1]{}
\newcommand{\novestnikonly}[1]{#1}
\vestnikonly{
\usepackage{allerree}

\def\wdeb{0}
\usepackage{nameref}
\usepackage{url}
\let\href\undefined
\newcommand{\href}[2]{\url{#1}}

\newcounter{countergvtheorems}

\renewenvironment{lem}
{\refstepcounter{countergvtheorems}\begin{theorem}{Лемма  \arabic{countergvtheorems}.}}
{\end{theorem}\par{\bf Доказательство.}}

\renewenvironment{thm}
{\refstepcounter{countergvtheorems}\begin{theorem}{Теорема \arabic{countergvtheorems}.}}
{\end{theorem}\par{\bf Доказательство.}}

\renewenvironment{defn}
{\par \refstepcounter{countergvtheorems} {\bf Определение \arabic{countergvtheorems}.}}
{\par}
}%\vestnikonly
\novestnikonly{
\newcommand{\iabstract}[4]{
\begin{abstract}
#3
\footnote{\emph{Keywords:} #4}
\end{abstract}
}
}%\novestnikonly


\DeclareMathOperator{\HC}{HC}
\DeclareMathOperator{\HM}{HM}
\DeclareMathOperator{\LCM}{LCM}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\SIG}{\mathcal{S}}

\AtBeginDocument{
  \def\labelitemi{\normalfont\bfseries{--}}
}

\makeatother

\providecommand{\definitionname}{\inputencoding{latin9}Definition}
\providecommand{\lemmaname}{\inputencoding{latin9}Lemma}
\providecommand{\theoremname}{\inputencoding{latin9}Theorem}

\begin{document}
\global\long\def\GVWl{<_{\text{H}}}


\global\long\def\GVWg{>_{\text{\textnormal{H}}}}


\global\long\def\eqdef{\overset{\mathrm{_{def}}}{=}}


\global\long\def\equivdef{\overset{\mathrm{_{def}}}{\Leftrightarrow}}


\novestnikonly{


\title{Simple signature-based Groebner basis algorithm\textbf{DO\_CHECK\_SPELLING}}


\author{Galkin Vasily\\
Moscow State University\\
email:\href{mailto: galkin-vv@yandex.ru}{ galkin-vv@yandex.ru}}

\maketitle
\providecommand{\definitionname}{Definition}
\providecommand{\lemmaname}{Lemma}
\providecommand{\theoremname}{Theorem} 
}%\novestnikonly
\vestnikonly{
\cleanbegin 
\def\udk{512}
\ltitle{ПРОСТОЙ ИТЕРАТИВНЫЙ АЛГОРИТМ ВЫЧИСЛЕНИЯ БАЗИСОВ ГРЁБНЕРА, ОСНОВАННЫЙ НА СИГНАТУРАХ} {В.\,В.~Галкин\footnote[1]{{\it Галкин Василий Витальевич} --- асп. каф. алгебры мех.-мат. ф-та МГУ, e-mail: galkin-vv@yandex.ru.}}
}%\vestnikonly
\iabstract
{Данная работа описывает алгоритм вычисления базисов Грёбнера, основанный на использовании отмеченных многочленов и идеях из алгоритма F5. Отличительными особенностями алгоритма по сравнению с аналогами являются простота самого алгоритма и доказательства его корректности, достигнутые без потери эффективности. Это позволяет создать простую реализацию, не уступающую более сложным аналогам по производительности}
{базис Грёбнера, алгоритм F5, отмеченные многочлены}
{This paper presents an algorithm for computing Groebner bases based upon labeled polynomials and ideas from the algorithm F5. The main highlights of this algorithm compared with analogues are simplicity both of the algorithm and of the its correctness proof achieved without loss of the efficiency. This leads to simple implementation which performance is in par with more complex analogues} {Groebner basis, F5 algorithm, labeled polynomials}

Consider polynomial ring $P=k[x_{1},\dots,x_{n}]$ over field $k$.
Also assume that monoid of its monomials $\mathbb{T}$ has a monomial
order$\prec$. A problem asking for a Gröbner basis can be stated
for any ideal$\left(f_{1},\dots,f_{l}\right)$ in this ring. One of
the approaches to the problem is using iterative method which computes
every step a basis for ideal $\left(f_{1},\dots,f_{i}\right),i=2\dots l$
based on the already computed for $\left(f_{1},\dots,f_{i-1}\right)$
basis $R_{i-1}$ and polynomial $f_{i}$. The alrgorithm described
in this paper is designed to perform one step of such computation.
So, the algorthm's input data consist of a some polynomial $f$ and
a polynomial set referred as $\left\{ g_{1},\dots,g_{m}\right\} $
which is Gröbner basis of ideal $I_{0}=\left(g_{1},\dots,g_{m}\right)$.
After finishing the algorithm should give the resulting polynomial
set $R$ being a Gröbner basis of ideal $I=\left(g_{1},\dots,g_{m},f\right)$.
The special cases $f=0\Rightarrow I=I_{0}$ and $\exists i\, g_{i}\in k\Rightarrow I=P$
are not interesting from the computational point of view, so the further
chapters assume that $f\neq0,\forall i\, g_{i}\notin k.$ The homogeniety
of input polynomials is not required unlike the F5 algorithm described
in \cite{FaugereF5}.


\section{Definitions}

Consider the set$\mathbb{T}_{0}=\mathbb{T}\cup\left\{ 0\right\} $
-- the monomial monoid extended by zero. The order $\prec$ can be
extended to $\mathbb{T}_{0}$ as $\prec_{0}$ with defintion $\forall t\in\mathbb{T}\, t\succ_{0}0$
which keeps the well-orderness property. The notion of division also
can be extended to $\mathbb{T}_{0}$: $t_{1}|t_{2}\eqdef\exists t_{3}\, t_{1}t_{3}=t_{2}$.
For polynomial $p\in P,p\neq0$ the highest by $\prec$ monom and
coefficient are written as $\HM(p)\in\mathbb{T}$ and $\HC(p)\in k$.
For zero we define -- $\HM(0)\eqdef0\in\mathbb{T}_{0}$, $\HC(0)\eqdef0\in k$.
The least common multiple of $t_{1},t_{2}\in\mathbb{T}$ is written
as $\LCM(t_{1},t_{2})\in\mathbb{T}$. In the following all definitions
are given for fixed $I_{0}$ and $f$:
\begin{defn}
The \emph{labeled polynomial} is a pair $h=(\sigma,p)\in\mathbb{T}_{0}\times P$,
that satisfies the correctness property: $\exists u\in P\,\HM(u)=\sigma,uf\equiv p\pmod{I_{0}}.$
Some terminology is extended to labeled polynomials. The highest monomial
is $\HM(h)\eqdef\HM(p)$ and coefficient is $\HC(h)\eqdef\HC(p)$.
Additionally the \emph{signature} is defined $\SIG(h)\eqdef\sigma$
and a notation is introduced for the polynomial -- secand element
of pair: $\poly(h)\eqdef p$. The set of all labeled polynomials is
written as $H\subset\mathbb{T}_{0}\times P$. The trivial examples
of labeled polynomials are $\left(1,f\right)$ and $\left(0,g\right)$
for $g\in I_{0}$. Another labeled polynomial example is $\left(\HM(g),0\right)$
for $g\in I_{0}$. It satisfies correctness property because we can
take $u$ equal to $g$.\end{defn}
\begin{lem}
The product of $h\in H,t\in\mathbb{T}$ defined as $th\eqdef(t\sigma,tp)\in H,$
is correct.
\end{lem}
The correctness property is checked by directly finding $u$ for $th$.
\begin{defn}
If the polynomials and monomial\emph{ $h'_{1},h_{2}\in H,t\in\mathbb{T}$}
satisfy $\SIG(h'_{1})\succ_{0}\SIG(th_{2}),\HM(h'{}_{1})=\HM(th{}_{2})\neq0,$
then exists a \emph{signature-safe reduction $h'_{1}$ by $h_{2}$},
resulting in labeled polynomial $h_{1}\in H$, equal to: 
\[
h_{1}=\left(\SIG(h'_{1}),\poly(h'_{1})+Kt\poly(h_{2})\right),
\]
where the $K\in k$ is selected in a way to perform cancellation of
high coefficients, so we have $\HM(h{}_{1})\prec_{0}\HM(h'{}_{1})$.
Such reduction is equivalent to plain reduction with high term cancellation
extended with requirement for reductor's signature being smaller than
the signature of labeled polynomial being reduced. Like in previous
case the correctness check is performed directly.
\end{defn}
Let's introduce a partial order $\GVWl$ on $H$: 
\[
h_{1}=(\sigma_{1},p_{1})\GVWl h_{2}=(\sigma_{2},p_{2})\equivdef\HM(p_{1})\sigma_{2}\prec_{0}\HM(p_{2})\sigma_{1}.
\]


The elements with zero signature or high monomial are extremums:
\[
\forall\sigma_{1},\sigma_{2},p_{1},p_{2}\,\left(0,p_{1}\right)\not\GVWl\left(\sigma_{2},p_{2}\right),\,\left(\sigma_{1},0\right)\not\GVWg\left(\sigma_{2},p_{2}\right).
\]

\begin{lem}
Let $h_{1},h_{2}\in H,t\in\mathbb{T}$. Then $h_{1}\GVWg h_{2}\Leftrightarrow h_{1}\GVWg th_{2}$.
\end{lem}
Deduced from the fact that multiplying one of the compared labeled
polynomials by $t$ leads to multiplying by $t$ both sides in the
definition of$\GVWg$.
\begin{lem}
Let $h_{1},h_{2}\in H,\HM(h_{1})|\HM(h_{2}),\HM(h_{2})\neq0$. Then
signature-safe reduction $h_{2}$ by $h_{1}$ is possible iff$h_{1}\GVWg h_{2}$.
\end{lem}
Deduced from the fact that claims of both sides are equivalent $\SIG(h_{2})\succ_{0}\SIG(h_{1})\frac{\HM(h_{2})}{\HM(h_{1})}$.
\begin{lem}
Let $h_{1}\in H$ be a result of signature-safe reduction of $h_{1}'$
by some other polynomial. Then $h_{1}\GVWl h_{1}'$.
\end{lem}
Deduced from equality $\SIG(h_{1})=\SIG(h_{1}')$ and decreasing $\HM$
during reduction: $\HM(h_{1})\prec_{0}\HM(h_{1}').$
\begin{lem}
\label{lem:greater-or-smaller}Let $h_{1}\GVWl h_{2}$ be labeled
polynomials. Then $\forall h_{3}\in H\setminus\left\{ \left(0,0\right)\right\} $
at least one of the following two inequalities is hold: $h_{1}\GVWl h_{3}$
or $h_{3}\GVWl h_{2}$.
\end{lem}
The lemma clause gives inequality
\begin{equation}
\HM(h_{1})\SIG(h_{2})\prec_{0}\HM(h_{2})\SIG(h_{1})\label{eq:gvw-order-3}
\end{equation}
which shows $\HM(h_{2})\neq0,\SIG(h_{1})\neq0$. Therefore for the
special case $\HM(h_{3})=0$ we get $h_{3}\GVWl h_{2}$and for the
case $\SIG(h_{3})=0$ we get $h_{1}\GVWl h_{3}$. For remaining generic
non-zero case the inequality \eqref{eq:gvw-order-3} can be multipled
by non-zero monomial $\HM(h_{3})\SIG(h_{3})$: 
\begin{equation}
\HM(h_{3})\SIG(h_{3})\HM(h_{1})\SIG(h_{2})\prec_{0}\HM(h_{3})\SIG(h_{3})\HM(h_{2})\SIG(h_{1}).\label{eq:left-or-right-monom}
\end{equation}
So, the element $\HM(h_{3})^{2}\SIG(h_{2})\SIG(h_{1})\in\mathbb{T}_{0}$
need to be $\succ_{0}$ than left side or $\prec_{0}$ than right
side of inequality \eqref{eq:left-or-right-monom}, and gives after
cancellation one of the inequalities from lemma statement.


\section{Algorithm}
\begin{lyxlist}{00.00.0000}
\item [{Вход:}] многочлены $\{g_{1},\dots,g_{m}\}$, образующие базис Грёбнера;
многочлен $f$.
\item [{Переменные:}] $R$ и $B$ -- подмножества $H$; $(\sigma,p')\in H$
-- отмеченный многочлен текущего шага до редукции; $(\sigma,p)$ --
он же после редукции; $r,b$ -- элементы $R$ и $B$
\item [{Результат:}] базис Грёбнера идеала $I=\left(g_{1},\dots,g_{m},f\right)$
\end{lyxlist}

\paragraph*{\label{par:SimpleSignatureGroebner}SimpleSignatureGroebner$\left(\left\{ g_{1},\dots,g_{m}\right\} ,f\right)$}
\begin{enumerate}
\item $R\leftarrow\{\left(\HM(g_{1}),0\right),\left(\HM(g_{2}),0\right),\dots,\left(\HM(g_{m}),0\right),(0,g_{1}),(0,g_{2}),\dots,(0,g_{m})\}$
\item $B\leftarrow\{\}$
\item $(\sigma,p')\leftarrow(1,f)$
\item \textbf{do forever:}

\begin{enumerate}
\item \label{enu:-before-reduce}$p\leftarrow$ReduceCheckingSignatures($\sigma,p',R$)
\item \label{enu:-after-reduce}$R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\item \textbf{if} $p\not=0$\textbf{:}

\begin{enumerate}
\item \textbf{for $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$:}

\begin{enumerate}
\item $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end{enumerate}
\item \textbf{for }$\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$\textbf{:}

\begin{enumerate}
\item $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end{enumerate}
\end{enumerate}
\item \label{enu:-remove-from-B}$B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\SIG(r)|\SIG(b)\}$
\item \textbf{if $B\neq\varnothing$: }$(\sigma,p')\leftarrow$ элемент
$B$ с $\prec$-минимальной сигнатурой
\item \textbf{else: break}
\end{enumerate}
\item \textbf{return} $\{\poly(r)\,|\, r\in R\}$
\end{enumerate}

\paragraph*{\label{par:ReduceCheckingSignatures:}ReduceCheckingSignatures$\left(\sigma,p,R\right)$}
\begin{enumerate}
\item \textbf{do while $\exists r\in R\, r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$:}

\begin{enumerate}
\item $p\leftarrow$редуцировать $p$ с сохранением сигнатуры по $\GVWg$-максимальному
элементу $r$ среди указанных в условии цикла
\end{enumerate}
\item \textbf{return} $p$\end{enumerate}
\begin{lem}
Все пары из $\mathbb{T}_{0}\times P$ в алгоритме -- элементы $H\setminus\left\{ \left(0,0\right)\right\} $.
\end{lem}
Элементы, формируемые до начала главного цикла, являются рассмотренными
выше примерами отмеченных многочленов. Все остальные отмеченные многочлены
в алгоритме формируются или умножением на $t\in\mathbb{T}$ или редукцией
с сохранением сигнатуры, поэтому они корректны и лежат в $H$.

Условия циклов, расширяющих $B$, таковы, что в\textbf{ }$B$ нет
ни нулевых сигнатур, ни нулевых старших мономов. Поэтому $\sigma$
никогда не обращается в 0 и нулевые сигнатуры в $R$ лишь у элементов
$(0,g_{1}),...,(0,g_{m}).$ Нулевой старший моном может быть у любого
многочлена, добавляемого в $R$, а нулевых многочленов с одновременно
нулевой сигнатурой в $R$ нет.


\section{Остановка алгоритма}
\begin{lem}
\label{lem:exist-reductor}В любой момент работы алгоритма любой отмеченный
многочлен из $B$ может быть редуцирован с сохранением сигнатуры по
некоторому элементу $R.$
\end{lem}
Отмеченные многочлены добавляются в $B$ таким образом, чтобы иметь
хотя бы один подходящий редуктор. $(\sigma,p)\in R$ является таким
редуктором при добавлении в первом цикле \textbf{for}, $r\in R$ --
во втором.
\begin{lem}
\label{lem:r-gvw-small}До редукции многочлена $p'$, то есть на шаге
\ref{enu:-before-reduce} любой итерации алгоритма, сигнатуры элементов
$\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $ не делят $\sigma$.
\end{lem}
На первой итерации алгоритма это выполняется, поскольку $\sigma=1$
и $R$ не содержит элементы с сигнатурами, делящими 1. На последующих
итерациях это выполнено, поскольку если бы в $R$ существовали такие
элементы, то $\left(\sigma,p'\right)$ был бы убран из $B$ в предыдущей
итерации на шаге \ref{enu:-remove-from-B}.
\begin{lem}
\label{lem:r-gvw-big}После редукции многочлена $p'$ до $p$, на
шаге \ref{enu:-after-reduce} любой итерации алгоритма, старшие мономы
элементов $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $ не делят
$\HM(p)$.
\end{lem}
Вытекает из того, что цикл в \nameref{par:ReduceCheckingSignatures:}
останавливается по достижении $p$, для которого такие элементы в
$R$ не существуют.
\begin{lem}
\label{lem:adds-really-new}После редукции многочлена $p'$ до $p$,
на шаге \ref{enu:-after-reduce} любой итерации алгоритма, элементы
$R$ не могут одновременно иметь старшие мономы, делящие $\HM(p)$,
и сигнатуры, делящие $\sigma$.
\end{lem}
В силу леммы \ref{lem:exist-reductor} будет произведена хотя бы одна
редукция $p'$, поэтому $(\sigma,p')\GVWg(\sigma,p)$. Отсюда по лемме
\ref{lem:greater-or-smaller} для $\forall r\in R$ имеем $r\GVWg(\sigma,p)$
или $r\GVWl(\sigma,p')$. Выполнение одного из неравенств позволяет
применить одну из лемм \ref{lem:r-gvw-small} и \ref{lem:r-gvw-big}.
\begin{thm}
Алгоритм \nameref{par:SimpleSignatureGroebner} останавливается
\end{thm}
Для доказательства остановки нужно показать, что все циклы \textbf{do}
выполняются лишь конечное число раз. В \nameref{par:ReduceCheckingSignatures:}
при ненулевых $p$ на каждой итерации $\HM(p)$ уменьшается по $\prec_{0}$,
что возможно лишь конечное число раз. При обнулении $p$ он завершится
в силу $\GVWl$-минимальности $(\sigma,0)$.

На каждом шаге основного цикла пополняется множество $R\subset\mathbb{T}_{0}\times P$.
Оно может быть разбито как $R_{*0}\cup R_{0*}\cup R_{**},$ где $R_{*0}\subset\mathbb{T}\times\left\{ 0\right\} ,R_{0*}\subset\left\{ 0\right\} \times P\setminus\left\{ 0\right\} ,R_{**}\subset\mathbb{T}\times P\setminus\left\{ 0\right\} $.
$R_{0*}$ не пополняется в силу $\sigma\neq0$. Для $R_{*0}$ и $R_{**}$
применим подход, основанный на понятии идеалов моноидов, предложенном
в \cite{KreuzerRobbianoBook1} как ``monoid ideal''. Рассмотрим следующие
множества, являющиеся идеалами моноидов: $L_{*0}=\left(\left\{ \sigma\,|\,(\sigma,0)\in R_{*0}\right\} \right)\subset\mathbb{T}$
и $L_{**}=\left(\left\{ (\sigma,t)\,|\,\exists(\sigma,p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$.
В силу леммы \ref{lem:adds-really-new} добавляемые в $R$ элементы
расширяют на каждом шаге $L_{*0}$ или $L_{**}$. Поскольку моноиды
$\mathbb{T}$ и $\mathbb{T}\times\mathbb{T}$ изоморфны $\mathbb{N}^{n}$
и $\mathbb{N}^{2n}$, к их идеалам может быть применена лемма Диксона,
которая и утверждает, что расширение может происходить лишь конечное
число раз.


\section{Корректность результата}
\begin{defn}
\emph{S-представлением} $h\in H$ над множеством $\left\{ r_{i}\right\} \subset H$
будем называть выражение $\poly(h)=\sum_{j}K_{j}t_{j}\poly(r_{i_{j}}),$
$K_{j}\in k,t_{j}\in\mathbb{T},i_{j}\in\mathbb{N}$, такое что $\forall j\,\HM(h)\succcurlyeq_{0}\HM(t_{j}r_{i_{j}}),\SIG(h)\succcurlyeq_{0}\SIG(t_{j}r_{i_{j}})$.\end{defn}
\begin{lem}
\label{lem:one-j-exact}Пусть $\poly(h)=\sum_{j}K_{j}t_{j}\poly(r_{i_{j}})$
-- S-представление для $h$. Тогда для хотя бы одного $j$ достигается
$\HM(h)=\HM(t_{j}r_{i_{j}})$.
\end{lem}
В качестве такого $j$ можно взять то, на котором достигается $\succ$-максимум
$\HM(t_{j}r_{i_{j}})$.

Следующее определение расширяет понятие S-базиса из работы \cite{TheF5Revised}:
\begin{defn}
Назовём $R\subset H$\emph{ S-базисом} (соответственно \emph{S$_{\sigma}$-базисом}),
если все элементы$H$ (соответственно $\left\{ h\in H\,|\,\SIG(h)\prec_{0}\sigma\right\} $)\emph{
}имеют S-представление\emph{ }над $R$\emph{.}\end{defn}
\begin{lem}
\label{lem:s-basis-and-no-reductions}Пусть $\sigma\succ_{0}0,R=\left\{ r_{i}\right\} $
-- S\emph{$_{\sigma}$}-базис и выбраны $h_{1},h_{2}\in H,\SIG(h_{i})=\sigma$,
которые не редуцируются по $R$ с сохранением сигнатуры. Тогда $\HM(h_{1})=\HM(h_{2})$
и у $h_{1}$ есть S-представление над $R\cup\left\{ h_{2}\right\} $.
\end{lem}
Из определения $H$ имеем $\exists u_{i}\in P\,\HM(u_{i})=\sigma,u_{i}f\equiv\poly(h_{i})\pmod{I_{0}},i=1,2.$
Значит некоторой линейной комбинации $\poly(h_{i})$ сопоставляется
$\prec_{0}\sigma$ сигнатура: 
\[
\exists K\in k,v\in P\,\HM(v)=\sigma'\prec_{0}\sigma,vf\equiv\poly(h_{1})-K\poly(h_{2})\pmod{I_{0}},
\]
то есть $\left(\sigma',p'\right)=\left(\sigma',\poly(h_{1})-K\poly(h_{2})\right)\in H$.
Из определения S\emph{$_{\sigma}$}-базиса и $\sigma'\prec_{0}\sigma$
вытекает $\exists r_{j}\in R,t\in\mathbb{T}\,\SIG(tr_{j})\preccurlyeq_{0}\sigma',\HM(tr_{j})=\HM(p')$.
Отсюда $\HM(h_{i})\neq\HM(p'),i=1,2$, иначе $r_{j}$ редуцировало
бы $h_{i}$ с сохранением сигнатуры. Значит, $\HM(h_{i})$ сокращаются
при вычитании с $k$-коэффициентом, что даёт $\HM(h_{1})=\HM(h_{2})$.
S-представление $h_{1}$ получается добавлением $K\poly(h_{2})$ к
S-представлению $\left(\sigma',p'\right)$.
\begin{thm}
\label{thm:exist-r-sigma}На каждой итерации алгоритма после шага
\ref{enu:-remove-from-B} выполнен инвариант: для $\forall\sigma\in\mathbb{T},\sigma\prec$
сигнатур элементов $B$, найдутся $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\SIG(t_{\sigma}r_{\sigma})=\sigma$
и $t_{\sigma}r_{\sigma}$ не редуцируется по $R$ с сохранением сигнатуры.
\end{thm}
Множество $R_{\sigma}=\left\{ r\in R\,|\,\SIG(r)|\sigma\right\} $
непусто, так как содержит добавленный на первой итерации элемент $r_{0}$
с $\SIG(r_{0})=1$. Обозначим за $r_{\sigma}$ его $\GVWl$-минимальный
элемент; положим $t_{\sigma}=\frac{\sigma}{\SIG(r_{\sigma})}$. Предположим,
что $t_{\sigma}r_{\sigma}$ может быть редуцирован с сохранением сигнатуры
относительно некоторого $r_{1}\in R$. Отсюда следует, что $r_{1}\GVWg r_{\sigma}$,
а также что они не нулевые. Значит на той же итерации, когда в $R$
был добавлен последний из $\{r_{\sigma},r_{1}\}$, в множество $B$
был добавлен многочлен $t'r_{\sigma}$, где $t'=\frac{\LCM(\HM(r_{1}),\HM(r_{\sigma}))}{\HM(r_{\sigma})}$,
причём $t'|t_{\sigma}$. Отсюда $\SIG(t'r_{\sigma})|\SIG(t_{\sigma}r_{\sigma})=\sigma\Rightarrow\SIG(t'r_{\sigma})\preccurlyeq\sigma\prec$
сигнатур элементов $B$. В силу этого неравенства на сигнатуры получается,
что $t'r_{\sigma}$ уже не может быть элементом $B$, а значит был
выкинут на шаге \ref{enu:-remove-from-B} одной из итераций, то есть
$\exists r_{2}\in R\, r_{2}\GVWl t'r_{\sigma},\SIG(r_{2})|\SIG(t'r_{\sigma})$.
Это невозможно, поскольку влечёт $r_{2}\GVWl r_{\sigma},r_{2}\in R_{\sigma}$,
что противоречит $\GVWl$-минимальности $r_{\sigma}$.
\begin{thm}
\label{thm:has-s-repr}На каждой итерации алгоритма после шага \ref{enu:-remove-from-B}
выполнен инвариант: $\forall h\in H,\SIG(h)\prec$ сигнатур элементов
$B$, имеет S-представление над $R$.
\end{thm}
Предположим нарушение инварианта на какой-то итерации и рассмотрим
$\prec_{0}$-минимальную $\sigma$, для которой непусто $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\SIG(h)=\sigma\}$.
Тогда $R$ -- S\emph{$_{\sigma}$}-базис. $\forall g\in I_{0}\,\left(0,g\right)$
имеют S-представления над $\{(0,g_{1}),...,(0,g_{m})\}\subset R$,
поэтому $\sigma\succ_{0}0$. Выберем $v_{\sigma}$ -- один из элементов
$V_{\sigma}$ с $\prec_{0}$-наименьшим $\HM$. Он не может быть редуцирован
с сохранением сигнатуры по $R$, поскольку результат редукции $v_{1}$
был бы элементом $V_{\sigma}$ с $\HM(v_{1})\prec_{0}\HM(v_{\sigma})$.
Возьмём $w_{\sigma}\eqdef t_{\sigma}r_{\sigma}$ из инварианта теоремы
\ref{thm:exist-r-sigma} и применим лемму \ref{lem:s-basis-and-no-reductions}
к $v_{\sigma},w_{\sigma}$ и $R$. Получим что $v_{\sigma}$ имеет
S-представление над $R\cup\{w_{\sigma}\}$. Вхождения $w_{\sigma}$
в нём можно заменить на $t_{\sigma}r_{\sigma}$, получив представление
$v_{\sigma}$ над $R$, что приводит к противоречию.
\begin{lem}
Если $R$ -- S-базис, то $\{\poly(r)\,|\, r\in R\}$ является базисом
Грёбнера идеала $I$.
\end{lem}
Для $\forall p\in I$ можно взять некоторый $h=\left(\sigma,p\right)\in H$
и применить лемму \ref{lem:one-j-exact}.
\begin{thm}
\nameref{par:SimpleSignatureGroebner} возвращает базис Грёбнера
\end{thm}
К моменту остановки $B=\varnothing$, значит по теореме \ref{thm:has-s-repr}
$R$ -- S-базис.


\subsection{Сравнение с аналогами}

Представленный алгоритм принадлежит к семейству алгоритмов вычисления
базисов Грёбнера, использующих сигнатуры, которые вычисляют S-базис
и в той или иной степени являются модификациями алгоритма F5 из \cite{FaugereF5}.
Одно из основных направлений его модификации -- упрощение теоретических
обоснований и расширение области применимости -- представлено в \cite{GermanF5Proof,ZobninGeneralization,F5InBBStyle}.
Другое -- повышение эффективности путём ввода дополнительных критериев
отбрасывания некоторых вычислений -- описывается в \cite{F5C,G2V,SignatureBasedGBs}
и позволяет проводить вычисления так, чтобы до конца редуцировались
лишь многочлены, являющиеся новыми элементами S-базиса или дающие
новую сигнатуру нулевого многочлена, расширяющую идеал моноида, содержащий
такие сигнатуры, называемые также \emph{сигнатурами сизигий.} Обобщение
с одновременным применением всех критериев в алгоритмах TRB-MJ и SB
\cite{HuangConception,PracticalGB} позволяет добиться большей эффективности
благодаря тому, что все отбрасывания применяются до проведения таких
вычислительно трудоёмких операций, как редукция многочлена или подсчёт
старшего монома S-пары, -- в результате не оказывается, что результаты
каких-то вычислений были отброшены.

Во всех упомянутых алгоритмах, включая немодифицированный F5, формулируется
два типа критериев отброса: критерии, связанные с сизигиями, и критерии
перезаписи, корректность каждого из которых доказывается независимо.
Также, даже в алгоритмах, не вычисляющих S-полиномы явно, теоретическое
обоснование корректности алгоритма на них опирается.

Данная работа описывает алгоритм вычисляющий минимальный S-базис и
осуществляющий отброс вычислений не менее эффективно, чем в TRB-MJ,
но использующий лишь единственный критерий отброса на шаге \ref{enu:-remove-from-B},
основанный на $\GVWl$-упорядочивании множества $R$. Вопрос наиболее
эффективного способа выбора редуктора в \nameref{par:ReduceCheckingSignatures:}
является открытым. Представленный в этой работе способ выбора основан
на всё том же упорядочении $R$ и совпадает для случая однородных
многочленов со способом выбора, применявшемся в алгоритме F5. Теоретическое
обоснование сформулировано без S-полиномов и позволяет применять к
нему простую алгебраическую интерпретацию из \cite{ZobninGeneralization}.

Упрощение формулировки алгоритма повлекло значительное уменьшение
времени на его реализацию и отладку на компьютере по сравнению с аналогами,
как за счёт меньшего количества множеств, так и за счёт общего для
критериев отбрасывания и процедуры редукции порядка. Простота реализации
и нетребовательность к структурам данных позволяет за небольшое время
внедрять эффективную версию алгоритма в любую систему компьютерной
алгебры. Реализация, упоминаемая ниже, была создана автором за 8 часов,
что на порядок меньше, чем время, затраченное автором на экспериментальные
реализации других алгоритмов в подобных условиях. Доказательство,
основанное на инвариантах в терминах S-представлений, позволило сделать
работу алгоритма более прозрачной с алгебраической точки зрения и
потенциально расширяемым на объекты, обобщающие кольцо многочленов
над полем.

Алгоритм был реализован на С++ с использованием функций ядра программного
комплекса Singular 3-1-4 и открытых наработок Кристиана Эдера (одного
из авторов \cite{SignatureBasedGBs}) по реализации F5-подобных алгоритмов
на этом ядре. Исходный код реализации содержится в функции ssg файла,
доступного по адресу \href{https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc}{https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc}

Сравнение реализации SimpleSignatureGroebner с другими алгоритмами
вычисления базисов Грёбнера, реализованных Кристианом Эдером подтвердили
следующие соображения:
\begin{itemize}
\item алгоритм SimpleSignatureGroebner корректно вычисляет базис Грёбнера;
\item результат содержит не большее число многочленов, чем результат других
инкрементальных алгоритмов, возвращающих S-базис;
\item время работы алгоритма оказывается не больше, чем у других инкрементальных
алгоритмов, основанных на сигнатурах.
\end{itemize}
\newpage{}\vestnikonly{
\spisoklit
\small\wrefdef{11}
\wref{1}{Faug\`{e}re J.-C.} A new efficient algorithm for computing Gr\"{o}bner bases without reduction to zero (F5) // Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2002. 75--83.

\wref{2}{Kreuzer M., Robbiano L.} Computational commutative algebra. 1 // Springer-Verlag. Berlin. 2000.

\wref{3}{Arri A., Perry J.} The F5 criterion revised // Journal of Symbolic Computation. 2011. {\bf46}, \No~9. 1017--1029.

\wref{4}{Герман О.} Доказательство критерия Фожера для алгоритма F5 // Математические заметки. 2010. {\bf88}, \No~4. 502--510.

\wref{5}{Зобнин А.} Обобщение алгоритма F5 вычисления базиса Грёбнера полиномиальных идеалов // Программирование. 2009. \No~2. 21--30.

\wref{6}{Sun, Y., Wang, D.} The F5 algorithm in Buchberger’s style // Journal of Systems Science and Complexity. 2011. {\bf24}, \No~6. 1218--1231. 

\wref{7}{Gao S., Guan Y., Volny F.} A new incremental algorithm for computing Gr\"{o}bner bases // Proceedings of the 2010 International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2010. 13--19.

\wref{8}{Eder C., Perry J.} Signature-based algorithms to compute Gr\"{o}bner bases // Proceedings of the 36th International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2011. 99--106.

\wref{9}{Eder C., Perry J.} F5C: A variant of Faug\`{e}re's F5 algorithm with reduced Gr\"{o}bner bases // Journal of Symbolic Computation. 2010. {\bf45}, \No~12. 1442--1458.

\wref{10}{Huang L.} A new conception for computing Gr\"{o}bner basis and its applications // депонировано: \href{http://arxiv.org/abs/1012.5425v2}{}.

\wref{11}{Roune B., Stillman M.} Practical Gr\"{o}bner basis computation // Proceedings of the 2012 International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2012.

\lend
}%\vestnikonly
\novestnikonly{

\bibliographystyle{plain}
\bibliography{f5_references}


}%\novestnikonly
\end{document}
