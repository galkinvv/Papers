#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass extarticle
\begin_preamble
\input{gost/babelbst.tex}
\oddsidemargin=0.46cm
\hoffset=0cm
\textwidth=16.75cm
\topmargin=-0.54cm
\textheight=25.2cm
\headheight=0cm
\headsep=0cm
\sloppy
\end_preamble
\options a4paper, reqno, 14pt
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\begin_local_layout

\end_local_layout
\language russian
\language_package babel
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 7
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWg}{>_{\text{\textnormal{H}}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\GVWl}{<_{\text{H}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\eqdef}{\overset{\mathrm{_{def}}}{=}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\equivdef}{\overset{\mathrm{_{def}}}{\Leftrightarrow}}
\end_inset

	
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Sig}{\mathcal{S}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\HM}{\mathrm{HM}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\HC}{\mathrm{HC}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\LCM}{\mathrm{LCM}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\totaldeg}{\mathrm{deg}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\poly}{\mathrm{poly}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\sigidx}{\mathrm{index}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
let
\backslash
maketitle
\backslash
relax%
\end_layout

\end_inset


\end_layout

\begin_layout Title
Сигнатурные алгоритмы вычисления базисов Грёбнера
\end_layout

\begin_layout Author
Василий Галкин, Мехмат МГУ, galkin-vv@ya.ru
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center

\size larger
Московский государственный университет 
\begin_inset Newline newline
\end_inset

 имени М.В.
\begin_inset space ~
\end_inset

Ломоносова
\begin_inset Newline newline
\end_inset


\begin_inset VSpace medskip
\end_inset

Механико-математический факультет
\size default

\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align right
На правах рукописи
\begin_inset Newline newline
\end_inset

УДК 512
\begin_inset Note Note
status open

\begin_layout Plain Layout
\align right
.628.2+519.688
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%+512.714
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\begin_inset VSpace vfill
\end_inset


\begin_inset VSpace vfill
\end_inset


\size larger
ГАЛКИН Василий Витальевич
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset VSpace vfill
\end_inset


\size huge
Сигнатурные алгоритмы
\begin_inset Newline newline
\end_inset

вычисления базисов Грёбнера
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset

Специальность 01.01.06
\begin_inset space ~
\end_inset

--- математическая логика,
\begin_inset Newline newline
\end_inset

алгебра и теория чисел
\end_layout

\begin_layout Standard
\align center

\size larger
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
Диссертация на соискание ученой степени 
\begin_inset Newline newline
\end_inset

 кандидата физико-математических наук
\end_layout

\begin_layout Standard
\align center

\size large
\begin_inset VSpace vfill
\end_inset

Научный руководитель:
\begin_inset Newline newline
\end_inset

кандидат физико-математических наук,
\begin_inset Newline newline
\end_inset

доцент
\begin_inset Newline newline
\end_inset

А.И.
\begin_inset space ~
\end_inset

Зобнин
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset

Москва
\begin_inset Newline newline
\end_inset

 2012 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
Введение
\end_layout

\begin_layout Subsection*
Актуальность темы
\end_layout

\begin_layout Standard
Одним из современных практических применений алгебры является её использование
 для компьютерного решения полиномиальных систем уравнений, возникающих
 в различных областях деятельности 
\begin_inset CommandInset citation
LatexCommand cite
key "FastStablePolySolving"

\end_inset

.
 Традиционно, при решении таких систем не использовалась их полиномиальность
 и к ним применялись общие приближённые методы решения уравнений.
 Однако со временем были разработаны алгоритмы, позволяющие использовать
 базисы Грёбнера для решения таких систем, причём как базисы относительно
 лексикографического, так и относительно произвольного мономиального порядка
 
\begin_inset CommandInset citation
LatexCommand cite
key "UsingAlgebraicGeometry"

\end_inset

.
 
\end_layout

\begin_layout Standard
Возникающие на практике системы могут иметь неточно заданные входные данные,
 что делает невозможным прямое применение алгоритмов, предложенных для вычислени
я базисов Грёбнера в кольце многочленов над полем.
 Существуют методики, позволяющие применять любой алгоритм базисов Грёбнера
 для приближённого случая, но они не учитывают сам ход алгоритма и могут
 запускать его несколько раз, что снижает эффективность такого подхода.
 Наиболее классическим алгоритмом вычисления базисов Грёбнера является алгоритм
 Бухбергера.
 В дальнейшем он получил развитие в виде алгоритма F4, для которого была
 найдена методика применения к системам с приближёнными входными данными
 
\begin_inset CommandInset citation
LatexCommand cite
key "NumericalComputationGB"

\end_inset

.
\end_layout

\begin_layout Standard
Однако, наиболее эффективными из известных на сегодняшний день алгоритмов
 вычисления базисов Грёбнера, являются алгоритмы, основанные на сигнатурах.
 Их идея, заключающаяся в использовании информации о выражении всех вычисляемых
 многочленов через исходные для минимизации числа лишних операций, была
 впервые предложена в основанном на сизигиях виде в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "FirstSyzygiesPaper"

\end_inset

.
 Следующей вехой в этом направлении стала работа 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, описавшая первый эффективный сигнатурный алгоритм -- алгоритм F5, применимый
 к однородным регулярным последовательностям.
 В дальнейшем он развивался в сторону расширения области применимости и
 повышения эффективности.
 Одно из наиболее полных объяснений методики применения алгоритма F5 к неоднород
ным входным данным даётся в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "Eder2012inhomogeneous"

\end_inset

.
 Повышение эффективности шло по нескольким направлениям.
 Совершенствовались критерии отбрасывания многочленов: алгоритм G2V из 
\begin_inset CommandInset citation
LatexCommand cite
key "G2V"

\end_inset

 позволил отбрасывать многочлены основываясь на всех известных сизигиях,
 а не только на тривиальных, а работа 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

 предложила критерий отбрасывания, позволяющий отбрасывать до редукции все
 многочлены за исключением минимального S-базиса.
 Также развивалось взаимодействие между этапами алгоритма: алгоритм F5C
 из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 добавил редукцию базиса между этапами, а алгоритмы GVW из
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

 и F5B из
\begin_inset CommandInset citation
LatexCommand cite
key "F5InBBStyle"

\end_inset

 делают алгоритм одноэтапным, позволяя использовать более широкий спектр
 порядков на сигнатурах.
 Последним направлением развития является переход от очереди S-пар к очереди
 их старших частей, позволяющий упростить конструкцию всего алгоритма.
 Этот подход был введён в уже упоминавшемся алгоритме G2V и продолжен в
 алгоритме GVW.
 Совмещение всех этих методик ускорение породило практически одинаковые
 алгоритмы TRB-MJ 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 и SB 
\begin_inset CommandInset citation
LatexCommand cite
key "PracticalGB"

\end_inset

, являющиеся наиболее эффективными сигнатурными алгоритмами на сегодняшний
 день.
 Алгоритм 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:SimpleSignatureGroebner"

\end_inset

, используемый в данной работе в качестве базового, также практически совпадает
 с ними в порядке работы, но отличается формулировкой и методом обоснования.
 Помимо сигнатурного направления развития эффективных алгоритмов вычисления
 базисов Грёбнера существует инволютивное направление, но данная работа
 сосредотачивается именно на применении сигнатурных алгоритмов для решения
 систем.
\end_layout

\begin_layout Standard
Применение сигнатурных алгоритмов к приближённым вычислениям изучено хуже,
 чем приближённые вариации алгоритма Бухбергера.
 Одной из работ этого направления является 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

, предлагающая использование метода замены переменных.
 Однако, этот метод разделяет недостаток универсальных адаптаций алгоритмов
 базиса Грёбнера: в процессе работы алгоритм F5 запускается несколько раз.
 Основное направление данной работы -- более глубокое изучение этой области,
 путём изучения применимости сигнатурных алгоритмов в приближённом случае
 с упором на эффективность вносимых в них модификаций.
\end_layout

\begin_layout Subsection*
Цель работы
\end_layout

\begin_layout Standard
Целью настоящей работы является создание методик решения приближённых систем
 алгебраических уравнений при помощи сигнатурных алгоритмов базиса Грёбнера.
 В качестве отдельных этапов, приводящих к данной цели, ставились следующие
 задачи:
\end_layout

\begin_layout Itemize
установить остановку сигнатурного алгоритма F5 вычисления Базисов Грёбнера
 на произвольном входном множестве многочленов, не обязательно являющимся
 регулярной последовательностью
\end_layout

\begin_layout Itemize
сформулировать и доказать свойства, однозначно определяющие многочлены,
 участвующие в проводимых алгоритмом F5 редукциях на основе состояния алгоритма,
 представленного множествами многочленов
\end_layout

\begin_layout Itemize
сформировать наиболее простой алгоритм, индуцированный этими свойствами,
 доказать его корректность и остановку, а также реализовать его в одной
 из систем компьютерной алгебры
\end_layout

\begin_layout Itemize
сформулировать строгое определение задачи приближённого решения системы,
 которое бы соответствовало алгоритмам приближённых вычислений, реализуемым
 на компьютере
\end_layout

\begin_layout Itemize
предложить метод применения алгоритмов базиса Грёбнера для решения приближённых
 систем, основывающийся на модулярных вычислениях для вероятностного определения
 точного равенства нулю приближённых коэффициентов; построить правило выбора
 модуля для таких вычислений, обеспечивающее вероятность получения некорректного
 ответа не более заданной константы
\end_layout

\begin_layout Itemize
научиться применять метод замены переменных из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

 к сигнатурным алгоритмам без их перезапуска
\end_layout

\begin_layout Standard
Эти задачи были успешно решены в данной работе.
\end_layout

\begin_layout Subsection*
Научная новизна
\end_layout

\begin_layout Standard
Научная новизна диссертации состоит в следующем:
\end_layout

\begin_layout Itemize
Доказана остановка алгоритма F5 на любых входных данных, не обязательно
 являющихся регулярными.
 В отличие от работ 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination,HuangConception"

\end_inset

 доказана именно остановка алгоритма в исходной формулировке работы 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, а не аналогичных алгоритмов, идентичность которых с F5 до конца не ясна.
 Показано, что при существовании редуктора, отбрасываемого одним из критериев
 в алгоритме существует один и только один не отбрасываемый редуктор
\end_layout

\begin_layout Itemize
Предложен вероятностный модулярный метод решения полиномиальных систем уравнений
 с приближёнными входными данными.
 Дано явное численное правило выбора простого модуля на основе требуемой
 вероятности корректности и величин, возникающих в процессе работы алгоритма.
\end_layout

\begin_layout Itemize
Предложен метод интеграции методики замены переменных в сигнатурные алгоритмы
 вычисления базисов Грёбнера, позволяющий в отличие от работы 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

 добавлять новые замены в процессе работы алгоритма
\end_layout

\begin_layout Subsection*
Основные методы исследования
\end_layout

\begin_layout Standard
Большая часть методов, используемых в работе, являются алгебраическими.
 Это включает базисы Грёбнера, коммутативную алгебру, линейную алгебру,
 а также символические вычисления и теорию конечных полей.
 Помимо них работа использует приёмы, используемые в теории вероятностей
 и численных методах.
 Главные результаты о сигнатурных алгоритмах вцелом, на которые опирается
 данная работа, находятся в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5,F5C"

\end_inset

.
 Эффективный алгоритм базисов Грёбнера, описанный в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception,PracticalGB"

\end_inset

 получает новое доказательство корректности и используется как базовый алгоритм
 для проведения приближённых вычислений.
 Одна из методик приближённых вычислений является непосредственным развитием
 идеи замены переменных из 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

.
 Данная работа была бы невозможна без теории сигнатурных алгоритмов, построенной
 в 
\begin_inset CommandInset citation
LatexCommand cite
key "G2V,Modifying-for-termination,ZobninGeneralization_ru,SignatureBasedGBs,TheF5Revised"

\end_inset

, и является результатом связывания сигнатурных алгоритмов вычисления базисов
 Грёбнера с одной из наиболее практических областей их применения -- решением
 приближённых полиномиальных систем.
\end_layout

\begin_layout Subsection*
Теоретическая и практическая ценность работы
\end_layout

\begin_layout Standard
Диссертация совмещает теоретические и прикладные направления.
 Теоретическая сторона результатов включает доказательства остановки сигнатурных
 алгоритмов на нерегулярных последовательностях и получение строгих оценок
 вероятности корректности для вероятностных модулярных алгоритмов.
 Сигнатурный алгоритм инкрементального вычисления базисов Грёбнера был реализова
н автором в системе компьютерной алгебры Singular.
 Алгоритмы нетребовательны к структурам данных и могут быть легко перенесены
 в другие системы компьютерной алгебры.
 Результаты диссертации могут быть полезны при решении задач, возникающих
 в робототехнике и видеоаналитике.
\end_layout

\begin_layout Subsection*
Апробация работы
\end_layout

\begin_layout Standard
Результаты диссертации докладывались на научно-исследовательском семинаре
 кафедры высшей алгебры МГУ.
\end_layout

\begin_layout Subsection*
Публикации
\end_layout

\begin_layout Standard
Результаты автора по теме диссертации находятся в процессе публикации в
 работах 
\begin_inset Quotes fld
\end_inset

Остановка алгоритма F5
\begin_inset Quotes frd
\end_inset

 и 
\begin_inset Quotes fld
\end_inset

Простой итеративный алгоритм вычисления базисов Грёбнера, основанный на
 сигнатурах
\begin_inset Quotes frd
\end_inset

 в журнале 
\begin_inset Quotes fld
\end_inset

Вестник МГУ
\begin_inset Quotes frd
\end_inset

.
 Переводы статей на английский язык в несколько более полном изложении,
 не скованном требованиями журнала к размеру публикации, доступны в электронной
 библиотеке 
\begin_inset CommandInset href
LatexCommand href
target "http://arxiv.org"

\end_inset

 как 
\begin_inset CommandInset href
LatexCommand href
name "Termination of Original F5"
target "http://arxiv.org/abs/1203.2402"

\end_inset

 и 
\begin_inset CommandInset href
LatexCommand href
name "Simple signature-based Groebner basis algorithm"
target "http://arxiv.org/abs/1205.6050"

\end_inset

.
\end_layout

\begin_layout Subsection*
Структура и объем диссертации
\end_layout

\begin_layout Standard
Диссертационная работа состоит из введения, двух частей, первая из которых
 посвящена исследованию алгоритмов вычисления базисов Грёбнера, а вторая
 -- их применению к решению систем, заключения и библиографии.
 Общий объем диссертации составляет 
\begin_inset CommandInset ref
LatexCommand pageref
reference "LastPage"

\end_inset


\begin_inset space ~
\end_inset

страниц.
 Структура работы отражена в оглавлении.
\end_layout

\begin_layout Subsection*
Благодарности
\end_layout

\begin_layout Standard
Автор благодарит своего научного руководителя, кандидата физико-математических
 наук, доцента кафедры высшей алгебры Алексея Игоревича Зобнина за руководство,
 идеи и советы, высказанные в процессе написания работы.
 Автор благодарит доктора физико-математических наук, профессора кафедры
 высшей алгебры Александра Васильевича Михалёва за оказание моральной поддержки
 и вселение уверенности.
 Автор благодарит доктора физико-математических наук, доцента кафедры высшей
 алгебры Ивана Владимировича Аржанцева, вызвавшего у автора интерес к алгебре
 на семинарах младших курсов.
 Автор также признателен доктору физико-математических наук, профессору
 кафедры высшей алгебры Евгению Соломоновичу Голоду за погружение автора
 в более глубокое понимание алгебры в период обучения в аспирантуре.
\end_layout

\begin_layout Standard
Автор выражает благодарность кандидату физико-математических наук, доценту
 кафедры высшей геометрии и топологии, Ивану Алексеевичу Дынникову за сохранение
 и поддержание интереса автора к разнообразию математики в процессе всё
 большего её изучения.
\end_layout

\begin_layout Standard
Автор благодарен авторам системы компьютерной алгебры Singular и лично Кристиану
 Эдеру за создание программного комплекса, позволившего автору быстро разрабатыв
ать и тестировать алгоритмы.
 Автор выражает огромную благодарность Джону Перри из University of Southern
 Mississippi, в работах и переписке с которым автор сделал наиболее важный
 шаг для данной диссертации -- осознал принципы сигнатурных алгоритмов.
\end_layout

\begin_layout Standard
Автор также благодарит свою жену за помощь в финальной подготовке текста
 работы.
\end_layout

\begin_layout Part
Вычисление базисов Грёбнера
\end_layout

\begin_layout Section
Обозначения
\end_layout

\begin_layout Standard
Для работы с базисами Грёбнера необходимо договориться об обозначениях,
 которые будут использоваться на протяжении всего текста:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{K}$
\end_inset

 -- некоторое поле
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

 -- абстрактное множество переменных
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{T}$
\end_inset

 -- множество мономов, образуемых этими переменными.
 Является коммутативным моноидом по операции умножения мономов
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathbb{T}_{0}=\mathbb{T}\cup\left\{ 0\right\} $
\end_inset

 -- формально расширенное нулём множество мономов.
 Операция умножения расширяется как 
\begin_inset Formula $\forall t\in\mathbb{T}_{0}$
\end_inset

 
\begin_inset Formula $t\cdot0=0$
\end_inset

.
 Является коммутативной полугруппой по этой операции.
 Понятие делимости в 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 стандартно: 
\begin_inset Formula $t_{1}|t_{2}\equivdef\exists t_{3}\, t_{1}\cdot t_{3}=t_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}$
\end_inset

 -- кольцо многочленов 
\begin_inset Formula $\mathcal{K}[x_{1},\dots,x_{n}]$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\totaldeg(t)\in\mathbb{Z}$
\end_inset

 -- полная степень монома 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset


\end_layout

\begin_layout Definition
Полный порядок 
\begin_inset Formula $\prec$
\end_inset

 на 
\begin_inset Formula $\mathbb{T}$
\end_inset

 называется 
\emph on
мономиальным
\emph default
, если он делает 
\begin_inset Formula $\mathbb{T}$
\end_inset

 вполне упорядоченным, а также 
\begin_inset Formula $\forall t_{1},t_{2},t_{3}\in\mathbb{T}$
\end_inset

 выполняется:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
t_{1}\prec t_{2}\Longrightarrow t_{1}t_{3}\prec t_{2}t_{3}
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
1\preccurlyeq t_{1}.
\]

\end_inset

Примерами мономиальных порядков являются лексикографический порядок lex
\begin_inset Formula $\left(x_{1},\dots,x_{n}\right)$
\end_inset

, задаваемый как:
\begin_inset Formula 
\begin{eqnarray*}
 & x_{1}^{a_{1}}x_{2}^{a_{2}}\cdots x_{n}^{a_{n}}\prec x_{1}^{b_{1}}x_{2}^{b_{2}}\cdots x_{n}^{b_{n}}\equivdef\\
 & \equivdef\exists i,1\leqslant i\leqslant n,\left(a_{1},\dots,a_{i-1}\right)=\left(b_{1},\dots,b_{i-1}\right),a_{i}<b_{i}\\
\end{eqnarray*}

\end_inset

и степенной обратный лексикографический порядок degrevlex
\begin_inset Formula $\left(x_{1},\dots,x_{n}\right)$
\end_inset

, задаваемый как:
\begin_inset Formula 
\[
x_{1}^{a_{1}}x_{2}^{a_{2}}\cdots x_{n}^{a_{n}}\prec x_{1}^{b_{1}}x_{2}^{b_{2}}\cdots x_{n}^{b_{n}}\equivdef
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\equivdef\left[\begin{array}{cc}
\sum_{i}a_{i}<\sum_{i}b_{i}\\
\sum_{i}a_{i}=\sum_{i}b_{i}, & \exists i,1\leqslant i\leqslant n,\left(a_{i+1},\dots,a_{n}\right)=\left(b_{i+1},\dots,b_{n}\right),a_{i}>b_{i}
\end{array}\right..
\]

\end_inset


\end_layout

\begin_layout Lemma
Для мономиального порядка 
\begin_inset Formula $\prec$
\end_inset

 и 
\begin_inset Formula $\forall t_{1},t_{2},t_{3}\in\mathbb{T}$
\end_inset

 выполняется: 
\begin_inset Formula 
\[
t_{1}\prec t_{2}\Longleftrightarrow t_{1}t_{3}\prec t_{2}t_{3}
\]

\end_inset


\end_layout

\begin_layout Proof
Заметим, что поскольку порядок полный, из неравенства 
\begin_inset Formula $t_{1}t_{3}\prec t_{2}t_{3}$
\end_inset

 вытекает что 
\begin_inset Formula $t_{1}\ne t_{2}$
\end_inset

 значит,
\begin_inset Formula 
\[
\left[\begin{array}{c}
t_{1}\prec t_{2}\\
t_{1}\succ t_{2}
\end{array}\right..
\]

\end_inset

Второе при этом невозможно, поскольку тогда из определения бы следовало,
 что 
\begin_inset Formula $t_{1}t_{3}\succ t_{2}t_{3}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\prec$
\end_inset

 -- зафиксированный мономиальный порядок на 
\begin_inset Formula $\mathbb{T}$
\end_inset

.
 Минимальным элементом является 
\begin_inset Formula $1\in\mathbb{T}$
\end_inset

, то есть пустое произведение
\end_layout

\begin_layout Itemize
\begin_inset Formula $\prec_{0}$
\end_inset

 -- порядок 
\begin_inset Formula $\prec$
\end_inset

, продолженный на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 заданием 
\begin_inset Formula $1\succ_{0}0$
\end_inset

.
 Легко показать, что он делает 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 вполне упорядоченным
\end_layout

\begin_layout Itemize
\begin_inset Formula $\HM(p)\in\mathbb{T}_{0}$
\end_inset

 -- старший моном многочлена, определяется для 
\begin_inset Formula $\forall p\in\mathcal{P}$
\end_inset

: при 
\begin_inset Formula $p\neq0$
\end_inset

 равен старшему по 
\begin_inset Formula $\prec$
\end_inset

 моному, а для 
\begin_inset Formula $p=0$
\end_inset

 определён как 
\begin_inset Formula $\HM(0)=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\HC(p)\in\mathcal{K}$
\end_inset

 -- старший коэффициент многочлена, определяется для 
\begin_inset Formula $\forall p\in\mathcal{P}$
\end_inset

: при 
\begin_inset Formula $p\neq0$
\end_inset

 равен коэффициенту при старшем по 
\begin_inset Formula $\prec$
\end_inset

 моному, а для 
\begin_inset Formula $p=0$
\end_inset

 определён как 
\begin_inset Formula $\HC(0)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\LCM(t_{1},t_{2})\in\mathbb{T}$
\end_inset

 -- наименьшее общее кратное мономов 
\begin_inset Formula $t_{1},t_{2}\in\mathbb{T}$
\end_inset

.
 
\end_layout

\begin_layout Definition
Ненулевой многочлен 
\begin_inset Formula $g$
\end_inset

 
\emph on
редуцирует
\emph default
 ненулевой многочлен 
\begin_inset Formula $f$
\end_inset

, если 
\begin_inset Formula $\HM(g)|\HM(f)$
\end_inset

.
 
\emph on
Результатом редукции
\emph default
 называется многочлен 
\begin_inset Formula $h=f-\frac{\HC(f)\HM(f)}{\HC(g)\HM(g)}g$
\end_inset

.
 Он может быть нулевой, и для него выполняется 
\begin_inset Formula $\HM(h)\prec_{0}\HM(f)$
\end_inset

.
 Конечная или бесконечная последовательность 
\begin_inset Formula $\left\{ f,f_{1},f_{2},...\right\} $
\end_inset

 называется 
\emph on
последовательностью редукций 
\emph default
по элементам 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 многочлена 
\begin_inset Formula $f$
\end_inset

, если каждый следующий элемент есть результат редукции предыдущего по некотором
у многочлену из 
\begin_inset Formula $G$
\end_inset

.
 Многочлен называется 
\emph on
нередуцируемым
\emph default
 по множеству, если ни один из элементов множества не редуцирует его.
 
\emph on
Результатом редукции многочлена 
\emph default

\begin_inset Formula $f$
\end_inset


\emph on
 по множеству 
\emph default

\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 называется последний элемент в начинающейся с 
\begin_inset Formula $f$
\end_inset

 последовательности редукций, которую нельзя продолжить.
 Результат редукции по множеству нередуцируем по нему.
\end_layout

\begin_layout Standard
Определение редукции зависит от порядка.
 На его основе дадим самое простое определение базиса Грёбнера:
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gb-def-1"

\end_inset

Множество 
\begin_inset Formula $G\subset I$
\end_inset

 называется 
\emph on
базисом Грёбнера
\emph default
 идеала 
\begin_inset Formula $I$
\end_inset

 кольца 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для порядка 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall f\in I,f\neq0\,\exists g\in G$
\end_inset

, редуцирующий 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Lemma
Если множество 
\begin_inset Formula $G\subset I$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 есть конечная последовательность редукций по элементам 
\begin_inset Formula $G$
\end_inset

, начинающаяся с 
\begin_inset Formula $f$
\end_inset

 и заканчивающаяся нулём.
\end_layout

\begin_layout Proof
Она может быть получена последовательным проведением редукций до тех пор,
 пока не будет получен нулевой многочлен.
 Конечность этой операции гарантируется тем, что каждая редукция уменьшает
 
\begin_inset Formula $\HM$
\end_inset

 по 
\begin_inset Formula $\prec_{0}$
\end_inset

, а множество 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 вполне упорядочено.
\end_layout

\begin_layout Standard
Для алгоритмов вычисления базиса Грёбнера будет полезна некоторая переформулиров
ка этого определения, для которой вводятся понятия представлений, отчасти
 заимствованные из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 Представления используются для описания способов, которыми многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан как комбинация многочленов из множества 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Definition
Для фиксированного множества 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 назовём 
\emph on
представлением
\emph default
 
\emph on
многочлена 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

 
\emph default
любую соответствующую верному равенству в 
\begin_inset Formula $\mathcal{P}$
\end_inset

 запись вида:
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot g_{i_{k}},\; g_{i_{k}}\in G
\]

\end_inset

с коэффициентами 
\begin_inset Formula $m_{k}=c_{k}t_{k}\in\mathcal{K}\times\mathbb{T}$
\end_inset

, в которой все пары 
\begin_inset Formula $\left(t_{k},g_{i_{k}}\right)$
\end_inset

 различны, и коэффициенты 
\begin_inset Formula $c_{k}\ne0$
\end_inset

.
 Символические произведения 
\begin_inset Formula $m_{k}\cdot g_{i_{k}}$
\end_inset

 называются 
\emph on
элементами
\emph default
 представления.
 Если рассмотреть это символическое произведение, как умножение многочленов,
 то мы получим многочлен 
\begin_inset Formula $m_{k}g_{i_{k}}$
\end_inset

, соответствующий элементу представления.
 Тогда 
\begin_inset Formula $p$
\end_inset

 оказывается равным сумме многочленов, соответствующих элементам его представлен
ия.
 Два представления равны, если наборы их элементов совпадают как множества.
 Поскольку, правая часть представления лежит в идеале 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\left(G\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang russian
, представление может существовать лишь для 
\begin_inset Formula $p\in\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Понятие представления не зависит от порядка 
\begin_inset Formula $\prec$
\end_inset

.
 Для базисов Грёбнера нужна следующая разновидность представлений, определение
 которой уже зависит от порядка:
\end_layout

\begin_layout Definition
Представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

 называется 
\emph on
степенным
\emph default
, если 
\begin_inset Formula $\forall k\,\HM(m_{k}g_{i_{k}})\preccurlyeq\HM(p)$
\end_inset

.
\end_layout

\begin_layout Standard
Дадим несколько примеров представлений над множеством 
\begin_inset Formula $G=\{y,y^{2},x^{2}+y\}\subset\mathbb{R}[x,y]$
\end_inset

 с лексикографическим порядком 
\begin_inset Formula $\mbox{lex}\left(x,y\right)$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $y=1\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}=y\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}=y\cdot(x^{2}+y)-x^{2}\cdot y$
\end_inset

 -- представление, не являющееся степенным
\end_layout

\begin_layout Itemize
\begin_inset Formula $0=1\cdot y^{2}-y\cdot y$
\end_inset

 -- представление, не являющееся степенным
\end_layout

\begin_layout Itemize
\begin_inset Formula $0=0$
\end_inset

 (сумма нуля элементов) -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}=1\cdot(x^{2}+y)-1\cdot y$
\end_inset

 -- степенное представление
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}y=y\cdot y+y\cdot(x^{2}+y)-2y\cdot y$
\end_inset

 -- не является представлением, так как первый и последний элементы отличаются
 лишь коэффициентом
\end_layout

\begin_layout Itemize
\begin_inset Formula $x^{2}y+y^{2}=y\cdot y+y\cdot(x^{2}+y)-1\cdot y^{2}$
\end_inset

 -- степенное представление, так как первый и последний элементы отличаются
 как пары, хотя и равны как многочлены.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exist-hm-in-deg-repr"

\end_inset

В степенном представлении 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 существует элемент 
\begin_inset Formula $m_{K}\cdot g_{i_{K}}$
\end_inset

, для которого 
\begin_inset Formula $\HM(p)=\HM(m_{K}g_{i_{K}})$
\end_inset


\end_layout

\begin_layout Proof
Выберем любой из элементов представления с 
\begin_inset Formula $\succ$
\end_inset

-максимальным среди элементов старшим мономом 
\begin_inset Formula $m$
\end_inset

.
 Из определения степенного представления имеем 
\begin_inset Formula $m\preccurlyeq\HM(p)$
\end_inset

.
 С другой стороны, поскольку, сумма всех элементов даёт 
\begin_inset Formula $p$
\end_inset

, хотя бы один из них обязан иметь старший моном не меньше 
\begin_inset Formula $\HM(p)$
\end_inset

.
 Таким образом, 
\begin_inset Formula $m=\HM(p)$
\end_inset

 и выбранный элемент -- искомый.
\end_layout

\begin_layout Standard
Теперь можно сформулировать эквивалентное определение для базиса Грёбнера:
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gb-def-2"

\end_inset

Множество 
\begin_inset Formula $G\subset I$
\end_inset

 называется 
\emph on
базисом Грёбнера
\emph default
 идеала 
\begin_inset Formula $I$
\end_inset

 кольца 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для порядка 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall f\in I$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Theorem
Определения 
\begin_inset CommandInset ref
LatexCommand ref
reference "gb-def-1"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "gb-def-2"

\end_inset

 эквивалентны
\end_layout

\begin_layout Proof
Если множество 
\begin_inset Formula $G$
\end_inset

 удовлетворяет второму определению, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 один из элементов степенного представления может быть взят в качестве редуцирую
щего.
\end_layout

\begin_layout Proof
Если множество 
\begin_inset Formula $G$
\end_inset

 удовлетворяет первому определению, то для 
\begin_inset Formula $\forall f\in I$
\end_inset

 степенное представление может быть получено как последовательность вычитаемых
 элементов в последовательности редукций 
\begin_inset Formula $f$
\end_inset

 к нулю по элементам 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
При зафиксированном кольце многочленов и порядке на мономах, для постановки
 задачи вычисления базисов Грёбнера необходимо задать идеал 
\begin_inset Formula $I\subset\mathcal{P}$
\end_inset

.
 Все алгоритмы, описанные в этой работе, подразумевают что идеал задаётся
 конечным набором своих порождающих: 
\begin_inset Formula $I=\left(F\right)=\left(f_{1},\ldots,f_{m}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Все алгоритмы вычисления базиса Грёбнера по заданным таким образом входным
 данным могут быть разделены на две больших группы: инкрементальные и одноэтапны
е.
 Инкрементальные алгоритмы состоят из 
\begin_inset Formula $m-1$
\end_inset

 шагов, причём, 
\begin_inset Formula $i$
\end_inset

-й шаг строит базис Грёбнера 
\begin_inset Formula $G_{i+1}$
\end_inset

 идеала 
\begin_inset Formula $\left(f_{1},\ldots,f_{i+1}\right)$
\end_inset

, принимая на вход многочлен 
\begin_inset Formula $f_{i+1}$
\end_inset

, и набор многочленов, составляющих, найденный ранее, базис 
\begin_inset Formula $G_{i}$
\end_inset

.
 При этом 
\begin_inset Formula $G_{1}$
\end_inset

 известно сразу, поскольку равно 
\begin_inset Formula $\left\{ f_{1}\right\} $
\end_inset

, а последний найденный базис 
\begin_inset Formula $G_{m}$
\end_inset

 является искомым базисом 
\begin_inset Formula $I$
\end_inset

.
 Таким образом, чтоб задать инкрементальный алгоритм, нужно задать лишь
 его шаг, находящий конечное множество 
\begin_inset Formula $G_{i+1}$
\end_inset

 по заданным 
\begin_inset Formula $f_{i+1}$
\end_inset

 и множеству 
\begin_inset Formula $G_{i}$
\end_inset

.
 При формулировке шага входные данные будут обозначаться просто как 
\begin_inset Formula $f$
\end_inset

 и 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
Одноэтапные алгоритмы принимают на вход сразу все многочлены 
\begin_inset Formula $f_{1},\ldots,f_{m}$
\end_inset

 и возвращают искомый базис Грёбнера, и не допускают естественного разбиения
 на шаги, аналогичные инкрементальным алгоритмам.
 Они могут быть сделаны инкрементальными 
\begin_inset Quotes fld
\end_inset

искусственно
\begin_inset Quotes frd
\end_inset

, путём использования одноэтапного алгоритма в роли шага для инкрементального,
 подавая ему на вход множество 
\begin_inset Formula $G_{i}\cup f_{i+1}$
\end_inset

.
\end_layout

\begin_layout Section
Алгоритм Бухбергера
\end_layout

\begin_layout Standard
Простейшим алгоритмом вычисления базиса Грёбнера является алгоритм Бухбергера.
 Мы не будем подробно останавливаться на нём, однако дадим некоторые теоретическ
ие сведения, которые будут использоваться и в других алгоритмах, и опишем
 наиболее простую его версию без каких-либо оптимизаций.
\end_layout

\begin_layout Definition

\emph on
\begin_inset CommandInset label
LatexCommand label
name "def:S-pair-nosig"

\end_inset

S-парой
\emph default
 ненулевых многочленов 
\begin_inset Formula $g_{1}$
\end_inset

 и 
\begin_inset Formula $g_{2}$
\end_inset

 называется пара произведений:
\begin_inset Formula 
\[
\left(\frac{\HM(g_{2})\HC(g_{2})}{\LCM(\HM(g_{1}),\HM(g_{2}))}\cdot g_{1};\frac{\HM(g_{1})\HC(g_{1})}{\LCM(\HM(g_{1}),\HM(g_{2}))}\cdot g_{2}\right).
\]

\end_inset

Каждое из произведений называется 
\emph on
частью S-пары
\emph default
.
 Части S-пары могут рассматриваться как символические произведения монома
 на многочлен, или как многочлены, равные этим произведениям.
 При последней трактовке у частей S-пары оказывается одинаковый старший
 моном, называемый 
\emph on
сокращаемым мономом S-пары
\emph default
, и одинаковый старший коэффициент.
 Поэтому, при вычитании второй части S-пары из первой, происходит сокращение
 старших мономов.
 Получаемая разность называется 
\emph on
S-многочленом
\emph default
, соответствующим S-паре, или просто S-многочленом 
\begin_inset Formula $g_{1}$
\end_inset

 и 
\begin_inset Formula $g_{2}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Simple-spoly"

\end_inset

Пусть задано конечное множество ненулевых многочленов 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

, и известно, что любой S-многочлен элементов 
\begin_inset Formula $G$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
 Тогда любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

, и таким образом, 
\begin_inset Formula $G$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Эта теорема является главной теоремой, показывающей корректность алгоритма
 Бухбергера, однако вместо неё будет доказана более общая версия, применимая
 далее для алгоритмов, основанных на сигнатурах.
 Следующее определение формулируется для любых объектов, с которыми можно
 проводить операции сравнения на равенство, умножения на моном и взятия
 старшего монома 
\begin_inset Formula $\HM$
\end_inset

.
 При всех использованиях этого понятия таким объектом будет являться многочлен
 из 
\begin_inset Formula $\mathcal{P}$
\end_inset

, возможно, с некоторыми дополнительно ассоциированными с ним данными, поэтому
 в тексте определения мы будем использовать термин 
\begin_inset Quotes fld
\end_inset

обобщённый многочлен
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Definition

\emph on
Условием представления
\emph default
 обобщённого многочлена 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 через обобщённый многочлен 
\begin_inset Formula $g\in\mathcal{P}$
\end_inset

 называется булева функция 
\begin_inset Formula $\beta(p,g)$
\end_inset

, удовлетворяющая следующим условиям:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\beta(p,p)=\mbox{TRUE}$
\end_inset


\end_layout

\begin_layout Itemize
Если 
\begin_inset Formula $\beta(p,g)=\mbox{TRUE}$
\end_inset

, то 
\begin_inset Formula $\forall m\in\mathbb{T}$
\end_inset

 будет 
\begin_inset Formula $\beta(mp,mg)=\mbox{TRUE}$
\end_inset


\end_layout

\begin_layout Itemize
Если 
\begin_inset Formula $\beta(p,g)=\mbox{TRUE}$
\end_inset

, то 
\begin_inset Formula $\forall k\in\mathcal{K},k\ne0$
\end_inset

 будет 
\begin_inset Formula $\beta(kp,g)=\beta(p,kg)=\mbox{TRUE}$
\end_inset


\end_layout

\begin_layout Itemize
Если 
\begin_inset Formula $\beta(p,g)=\mbox{TRUE}$
\end_inset

 и 
\begin_inset Formula $\beta(g,h)=\mbox{TRUE}$
\end_inset

, то 
\begin_inset Formula $\beta(p,h)=\mbox{TRUE}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Простейшим примером условия представления является 
\emph on
условие на старший моном
\emph default
 
\begin_inset Formula $\beta_{\HM}$
\end_inset

, определённое как 
\begin_inset Formula 
\[
\beta_{\HM}(p,g)=\mbox{TRUE}\Longleftrightarrow\HM(g)\preccurlyeq\HM(p).
\]

\end_inset


\end_layout

\begin_layout Definition
Представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

 называется 
\emph on
удовлетворяющим условию 
\begin_inset Formula $\beta$
\end_inset


\emph default
, если 
\begin_inset Formula $\forall k\,\beta(p,m_{k}g_{i_{k}})=\mbox{TRUE}$
\end_inset

.
\end_layout

\begin_layout Standard
В соответствии с этим определением представление является степенным тогда
 и только тогда, когда удовлетворяет условию 
\begin_inset Formula $\beta_{\HM}$
\end_inset

.
 Теперь можно сформулировать теорему, которая в частном случае тождественно
 истинной функции 
\begin_inset Formula $\beta_{2}$
\end_inset

 совпадает с теоремой 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Simple-spoly"

\end_inset

.
\end_layout

\begin_layout Theorem
Пусть зафиксировано некоторое условие представления 
\begin_inset Formula $\beta_{2}$
\end_inset

, и задано конечное множество ненулевых многочленов 
\begin_inset Formula $G=\{g_{1},\dots,g_{m}\}\subset\mathcal{P}$
\end_inset

, про которое известно, что любой S-многочлен элементов 
\begin_inset Formula $G$
\end_inset

 имеет представление над 
\begin_inset Formula $G$
\end_inset

, одновременно удовлетворяющее условиям 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Пусть также любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет представление над 
\begin_inset Formula $G$
\end_inset

, удовлетворяющее условию 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Тогда любой элемент идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

 имеет представление, одновременно удовлетворяющее условиям 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

, и, таким образом, 
\begin_inset Formula $G$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим противное и рассмотрим некоторый многочлен 
\begin_inset Formula $p\in\left(G\right)$
\end_inset

, не имеющий представления одновременно удовлетворяющего условиям 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Среди его представлений, удовлетворяющих 
\begin_inset Formula $\beta_{2}$
\end_inset

, найдём минимум значения 
\begin_inset Formula $\max_{k}\HM(m_{k}g_{i_{k}})$
\end_inset

 и обозначим его за 
\begin_inset Formula $M$
\end_inset

.
 Далее зафиксируем среди представлений, на которых этот минимум достигается,
 представление 
\begin_inset Formula $p=\sum_{k}m_{k}\cdot g_{i_{k}}$
\end_inset

 с минимальным количеством элементов, обладающих старшим мономом 
\begin_inset Formula $M$
\end_inset

.
 В силу предположенного, оно не может удовлетворять 
\begin_inset Formula $\beta_{\HM}$
\end_inset

, а значит 
\begin_inset Formula $M\succ\HM(p)$
\end_inset

.
 Отсюда вытекает, что в представлении есть как минимум 2 элемента со старшим
 мономом 
\begin_inset Formula $M$
\end_inset

, поскольку при суммировании в 
\begin_inset Formula $p$
\end_inset

 этот моном должен сократиться.
 Для простоты будем полагать, что это элементы с индексами 1 и 2: 
\begin_inset Formula $c_{1}t_{1}\cdot g_{i_{1}}$
\end_inset

 и 
\begin_inset Formula $c_{2}t_{2}\cdot g_{i_{2}}$
\end_inset

.
 При этом 
\begin_inset Formula $i_{1}\ne i_{2}$
\end_inset

, так как иначе из равенства их 
\begin_inset Formula $\HM$
\end_inset

 следовало бы равенство 
\begin_inset Formula $t_{1}=t_{2}$
\end_inset

, что вместе с 
\begin_inset Formula $i_{1}=i_{2}$
\end_inset

 противоречит неповторяемости элементов в представлении.
 S-пара 
\begin_inset Formula $g_{i_{1}}$
\end_inset

 и 
\begin_inset Formula $g_{i_{2}}$
\end_inset

 имеет вид 
\begin_inset Formula $\left(c_{1}'t_{1}'\cdot g_{i_{1}};c_{2}'t_{2}'\cdot g_{i_{2}}\right)$
\end_inset

, причём, 
\begin_inset Formula $\exists t_{m}\in\mathbb{T},c_{m}\in\mathcal{K}$
\end_inset

 для которых 
\begin_inset Formula $c_{1}'t_{1}'c_{m}t_{m}=c_{1}t_{1}$
\end_inset

.
 S-многочлен 
\begin_inset Formula $c_{1}'t_{1}'\cdot g_{i_{1}}-c_{2}'t_{2}'\cdot g_{i_{2}}$
\end_inset

 имеет представление, удовлетворяющее 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 В силу свойств условий представления отсюда следует, что после умножения
 его на 
\begin_inset Formula $c_{m}t_{m}$
\end_inset

 он тоже будет иметь представление над 
\begin_inset Formula $G$
\end_inset

, удовлетворяющее 
\begin_inset Formula $\beta_{\HM}$
\end_inset

 и 
\begin_inset Formula $\beta_{2}$
\end_inset

.
 Обозначим это представление за 
\begin_inset Formula $\sum_{l}m_{l}\cdot g_{i_{l}}$
\end_inset

.
 Тогда выражение 
\begin_inset Formula 
\[
p=\sum_{l}m_{l}\cdot g_{i_{l}}+(c_{2}+c_{m}c_{2}')t_{2}\cdot g_{i_{2}}+\sum_{k>2}m_{k}\cdot g_{i_{k}}
\]

\end_inset

после группировки подобных даст удовлетворяющее 
\begin_inset Formula $\beta_{2}$
\end_inset

 представление, с меньшим количеством элементов, обладающих старшим мономом
 
\begin_inset Formula $M$
\end_inset

, что приводит к противоречию.
\end_layout

\begin_layout Standard
Теперь сформулируем простейший вариант алгоритма Бухбергера в виде одноэтапного
 алгоритма
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Вход: многочлены 
\begin_inset Formula $\{f_{1},\dots,f_{m}\}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Переменные: 
\begin_inset Formula $P\subset\mathcal{P}$
\end_inset

 -- множество вычисленных S-многочленов.
 
\begin_inset Formula $G\subset\mathcal{P}$
\end_inset

 -- получаемый базис Грёбнера.
 
\begin_inset Formula $p\in\mathcal{P}$
\end_inset

 -- многочлен текущего шага
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\begin_inset CommandInset label
LatexCommand label
name "par:Buchberger"

\end_inset

Buchberger
\begin_inset Formula $\left(\left\{ f_{1},\dots,f_{m}\right\} \right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $G\leftarrow\{f_{1},\dots,f_{m}\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $P\leftarrow\{$
\end_inset

S-многочлены всех пар 
\begin_inset Formula $(f_{i},f_{j}),i<j\}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
while 
\begin_inset Formula $P\ne\varnothing$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 любой элемент 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $P\leftarrow P\setminus\{p\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 результат редукции 
\begin_inset Formula $p$
\end_inset

 по 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $P\leftarrow P\cup\{$
\end_inset

S-многочлены всех пар 
\begin_inset Formula $(p,g),g\in G\}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
\begin_inset Formula $G\leftarrow G\cup\{p\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Standard
Для доказательства правильности любого алгоритма вычисления базисов Грёбнера
 нужно показать его остановку за конечное число шагов и корректность результата.
 Для алгоритма Бухбергера это показывают две следующие известные теоремы.
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Buchberger"

\end_inset

 останавливается на любых входных данных
\end_layout

\begin_layout Proof
Каждый новый элемент, добавляемый в 
\begin_inset Formula $G$
\end_inset

, нередуцируем по нему, а значит, расширяет идеал моноида, порождаемый старшими
 элементами многочленов 
\begin_inset Formula $G$
\end_inset

.
 Этот процесс не может быть бесконечен по лемме Диксона.
 Значит, после некоторого шага все результаты редукции нулевые и 
\begin_inset Formula $P$
\end_inset

 перестаёт пополняться.
 После этого оно исчерпается за конечное число итераций и алгоритм завершится.
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Buchberger"

\end_inset

 возвращает базис Грёбнера идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Proof
Все S-пары элементов 
\begin_inset Formula $G$
\end_inset

 были добавлены в 
\begin_inset Formula $P$
\end_inset

, и редуцированы.
 Вне зависимости от того произошла ли редукция к нулю, или в 
\begin_inset Formula $G$
\end_inset

 был добавлен новый элемент, после окончания итерации цикла, рассматриваемый
 S-многочлен имеет степенное представление над 
\begin_inset Formula $G$
\end_inset

.
 Отсюда по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Simple-spoly"

\end_inset

 следует, что 
\begin_inset Formula $G$
\end_inset

 -- базис Грёбнера 
\begin_inset Formula $(G)$
\end_inset

.
 С другой стороны 
\begin_inset Formula $(G)=\left(f_{1},\dots,f_{m}\right)$
\end_inset

, поскольку 
\begin_inset Formula $f_{1},\dots,f_{m}$
\end_inset

 были добавлены в 
\begin_inset Formula $G$
\end_inset

 на первом шаге и все вычисления производились лишь внутри идеала.
\end_layout

\begin_layout Section
Алгоритм F5
\end_layout

\begin_layout Standard
Понятие сигнатуры связано с понятием представлений: сигнатура многочлена
 содержит информацию о максимальном, в определённом смысле, элементе представлен
ия этого многочлена.
 Поэтому для её определения необходимо зафиксировать множество, над которым
 рассматривается представление.
 Вопрос единственности сигнатуры после этой фиксации зависит от того, выбирается
 ли среди представлений какое-то одно.
 В работах 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5,SignatureBasedGBs"

\end_inset

 сигнатура определяется для многочлена однозначно, при помощи выбора минимальног
о, в определённом смысле, представления.
 В работах 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C,GVW,G2V,F5InBBStyle,HuangConception"

\end_inset

 и в данной работе представление не фиксируется, и один многочлен может
 иметь неограниченное число сигнатур.
 Таким образом, понятие сигнатуры зависит не только от многочлена, но и
 от того, над каким множеством рассматриваются его представления и даже
 от самого представления.
 Для одноэтапных алгоритмов представления рассматриваются над множеством
 
\begin_inset Formula $f_{1},\dots,f_{m}$
\end_inset

, а для инкрементальных на каждом шаге берётся соответствующее этому шагу
 множество 
\begin_inset Formula $G_{i}\cup f_{i+1}$
\end_inset

.
\end_layout

\begin_layout Standard
Сначала введём определение сигнатуры для элемента представления в одноэтапном
 и инкрементальном случаях.
\end_layout

\begin_layout Definition
Для одноэтапного алгоритма 
\emph on
сигнатурой элемента представления
\emph default
 
\begin_inset Formula $ct\cdot f_{i}$
\end_inset

 называется пара 
\begin_inset Formula $(t,i)\in\mathbf{T}=\mathbb{T}\times\mathbb{N}$
\end_inset

.
 В этой паре 
\begin_inset Formula $i$
\end_inset

 называется 
\emph on
индексом сигнатуры
\emph default
, а 
\begin_inset Formula $t$
\end_inset

 -- 
\emph on
мономом сигнатуры
\emph default
.
 Умножение такой сигнатуры на моном определяется как 
\begin_inset Formula $t_{1}(t,i)\eqdef(t_{1}t,i)$
\end_inset

, что соответствует умножению на моном элемента представления.
 Делимость элементов 
\begin_inset Formula $t',t''\in\mathbf{T}$
\end_inset

 определяется в соответствии с этим определением умножения:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
t'|t''\equivdef\exists t_{1}\in\mathbb{T},t''=t_{1}t'
\]

\end_inset


\end_layout

\begin_layout Standard
Для сравнения сигнатур из 
\begin_inset Formula $\mathbf{T}$
\end_inset

 могут использоваться различные порядки.
 Обычно используется порядок 
\begin_inset Formula $\prec_{P}$
\end_inset

, сравнивающий вначале индексы, а потом мономы:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(t_{1},i_{1}\right)\prec_{P}\left(t_{2},i_{2}\right)\Longleftrightarrow\left[\begin{aligned} & i_{1}<i_{2}\\
 & i{}_{1}=i_{2},t_{1}\prec t_{2}
\end{aligned}
\right..
\]

\end_inset


\end_layout

\begin_layout Definition
Для
\emph on
 
\emph default
инкрементального алгоритма 
\emph on
сигнатурой элемента представления
\emph default
 
\begin_inset Formula $ct\cdot p$
\end_inset

 называется 
\begin_inset Formula $t\in\mathbb{T}_{0}$
\end_inset

, если 
\begin_inset Formula $p=f$
\end_inset

 и 
\begin_inset Formula $0\in\mathbb{T}_{0}$
\end_inset

 если 
\begin_inset Formula $p\in G$
\end_inset

.
 В этом случае, понятие 
\emph on
монома сигнатуры
\emph default
 совпадает с понятием сигнатуры.
 Для их сравнения используется порядок 
\begin_inset Formula $\prec_{0}$
\end_inset

, уже заданный на 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующие определения не зависят от типа алгоритма, поэтому в них будем
 подразумевать под 
\begin_inset Formula $\tau$
\end_inset

 множество сигнатур соответствующее 
\begin_inset Formula $\mathbf{T}$
\end_inset

 или 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

, а под 
\begin_inset Formula $\prec_{\tau}$
\end_inset

 порядок на нём.
\end_layout

\begin_layout Definition

\emph on
Представлением 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset


\emph default
 называется представление 
\begin_inset Formula $p$
\end_inset

, в котором 
\begin_inset Formula $\prec_{\tau}$
\end_inset

-максимальная сигнатура элементов в точности равна 
\begin_inset Formula $\sigma$
\end_inset

.
 
\emph on
Отмеченным многочленом
\emph default
 называется пара 
\begin_inset Formula $h=(\sigma,p)\in\tau\times\mathcal{P}$
\end_inset

, удовлетворяющая следующему 
\emph on
условию корректности
\emph default
: существует представление 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
 На отмеченные многочлены распространяются определения старшего монома 
\begin_inset Formula $\HM(h)\eqdef\HM(p)$
\end_inset

 и коэффициента 
\begin_inset Formula $\HC(h)\eqdef\HC(p)$
\end_inset

.
 Также определяется 
\emph on
сигнатура
\emph default
 
\begin_inset Formula $\Sig(h)\eqdef\sigma$
\end_inset

 и вводится обозначение многочлена -- второго элемента пары: 
\begin_inset Formula $\poly(h)\eqdef p$
\end_inset

.
 Множество отмеченных многочленов обозначается за 
\begin_inset Formula $H\subset\tau\times\mathcal{P}$
\end_inset

.
 Полная степень монома сигнатуры 
\begin_inset Formula $\sigma\in\tau$
\end_inset

 обозначается 
\begin_inset Formula $\totaldeg(\sigma)$
\end_inset

.
\end_layout

\begin_layout Lemma
Результат умножения отмеченного многочлена 
\begin_inset Formula $h\in H$
\end_inset

 на моном 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

, заданного как 
\begin_inset Formula $th\eqdef(t\sigma,tp),$
\end_inset

 лежит в 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Необходимо проверить условие корректности.
 Представление 
\begin_inset Formula $tp$
\end_inset

 сигнатуры 
\begin_inset Formula $t\sigma$
\end_inset

 может быть получено умножением на 
\begin_inset Formula $t$
\end_inset

 представления 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
 
\end_layout

\begin_layout Definition

\emph on
Сигнатурное условие представления
\emph default
 
\begin_inset Formula $\beta_{\Sig}$
\end_inset

 для отмеченных многочленов 
\begin_inset Formula $p,g\in H$
\end_inset

 определяется как
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\beta_{\Sig}(p,g)=\mbox{TRUE}\Longleftrightarrow\Sig(g)\preccurlyeq_{\tau}\Sig(p).
\]

\end_inset


\end_layout

\begin_layout Definition
Представление, удовлетворяющее условиям 
\begin_inset Formula $\beta_{\Sig}$
\end_inset

 и 
\begin_inset Formula $\beta_{\HM}$
\end_inset

, называется сигнатурным представлением.
\end_layout

\begin_layout Standard
Следующее определение вводит понятие сигнатурной редукции отмеченных многочленов
, соответствующее сигнатурному представлению.
 
\end_layout

\begin_layout Definition
Если для некоторых
\emph on
 
\begin_inset Formula $h'_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset


\emph default
 выполняется 
\begin_inset Formula $\Sig(h'_{1})\succ_{\tau}\Sig(th_{2}),\HM(h'{}_{1})=\HM(th{}_{2})\neq0,$
\end_inset

 то возможна 
\emph on
сигнатурная редукция 
\begin_inset Formula $h'_{1}$
\end_inset

 по 
\begin_inset Formula $h_{2}$
\end_inset

,
\emph default
 дающая в результате отмеченный многочлен 
\begin_inset Formula $h_{1}\in H$
\end_inset

, равный: 
\begin_inset Formula 
\[
h_{1}=\left(\Sig(h'_{1}),\poly(h'_{1})+Kt\poly(h_{2})\right),
\]

\end_inset

где коэффициент 
\begin_inset Formula $K\in\mathcal{K}$
\end_inset

 взят так, чтобы при сложении сократились старшие мономы, и выполнилось
 
\begin_inset Formula $\HM(h{}_{1})\prec_{0}\HM(h'{}_{1})$
\end_inset

.
 По сути, такая редукция представляет из себя обычную редукцию многочлена
 с сокращением старшего монома, дополненную требованием того, что сигнатура
 редуктора меньше сигнатуры редуцируемого.
 Корректность проверяется взятием представления для 
\begin_inset Formula $\poly(h'_{1})+Kt\poly(h_{2})$
\end_inset

, равного соответствующей линейной комбинации представлений 
\begin_inset Formula $\poly(h'_{1})$
\end_inset

 и 
\begin_inset Formula $\poly(h_{2})$
\end_inset

.
\end_layout

\begin_layout Remark
Последовательность таких сигнатурных редукций по некоторому множеству отмеченных
 многочленов, заканчивающаяся нулём, определяет сигнатурное представление
 над этим множеством, состоящее из редуцирующих элементов.
\end_layout

\begin_layout Definition

\emph on
S-пара отмеченных многочленов
\emph default
 
\begin_inset Formula $h_{1},h_{2}\in H$
\end_inset

 определяется аналогично простой S-паре, путём подстановки 
\begin_inset Formula $h_{1},h_{2}$
\end_inset

 на место обычных многочленов 
\begin_inset Formula $g_{1},g_{2}$
\end_inset

 в определении 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:S-pair-nosig"

\end_inset

.
 При этом каждая из частей S-пары 
\begin_inset Formula $\left(k_{1}u_{1}\cdot h_{1},k_{2}u_{2}\cdot h_{2}\right)$
\end_inset

 отмеченных многочленов имеет соответствующую ей сигнатуру 
\begin_inset Formula $\Sig(u_{i}h_{i})$
\end_inset

.
 Если сигнатуры частей различны, то часть с большей сигнатурой называется
 
\emph on
старшей частью S-пары
\emph default
, а часть с меньшей -- 
\emph on
младшей частью S-пары
\emph default
.
 При равенстве сигнатур частей такого разделения нет, но в этом случае нельзя
 определить сигнатуру S-многочлена, так как невозможно проверить условие
 корректности.
 При различии сигнатур частей S-многочлен 
\begin_inset Formula $k_{1}u_{1}\cdot h_{1}-k_{2}u_{2}\cdot h_{2}$
\end_inset

 является результатом сигнатурной редукции старшей части по младшей, и имеет
 сигнатуру, равную сигнатуре старшей части.
\end_layout

\begin_layout Standard
В дальнейшем мы не будем одновременно работать с сигнатурами двух видов,
 подразумевая сигнатуры из 
\begin_inset Formula $\mathbf{T}$
\end_inset

 в случае одноэтапных алгоритмов и сигнатуры из 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

 для инкрементальных.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example:labeled-polys"

\end_inset

Простейшие отмеченные многочлены для одноэтапного случая:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(\left(\HM(p),i\right),pf_{i}\right),p\in\mathcal{P},i\in\mathbb{N}$
\end_inset

.
 Соответствует представлению вида 
\begin_inset Formula $pf_{i}=\sum_{m_{p}\in p}m_{p}\cdot f_{i}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\left(t\HM(f_{i}),j\right),0\right)$
\end_inset

 для 
\begin_inset Formula $i<j\in\mathbb{N},t\in\mathbb{T}$
\end_inset

.
 Соответствует представлению, получаемому для нуля из разбиения 
\begin_inset Formula $f_{i}$
\end_inset

 и 
\begin_inset Formula $f_{j}$
\end_inset

 на составляющие их мономы: 
\begin_inset Formula 
\[
0=t(f_{i}f_{j}-f_{j}f_{i})=\sum_{m_{f_{i}}\in f_{i}}m_{f_{i}}\cdot f_{j}-\sum_{m_{f_{j}}\in f_{j}}m_{f_{j}}\cdot f_{i}.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Example
Простейшие отмеченные многочлены для инкрементального случая:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left(\HM(p),pf\right),p\in\mathcal{P}$
\end_inset

.
 Соответствует представлению вида 
\begin_inset Formula $pf=\sum_{m_{p}\in p}m_{p}\cdot f$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(0,g\right)$
\end_inset

 для 
\begin_inset Formula $g\in\left(G\right)$
\end_inset

.
 Соответствует любому представлению 
\begin_inset Formula $g$
\end_inset

 над 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\HM(g),0\right)$
\end_inset

 для 
\begin_inset Formula $g\in\left(G\right)$
\end_inset

.
 Соответствует представлению, получаемому для нуля из разбиения 
\begin_inset Formula $g$
\end_inset

 и 
\begin_inset Formula $f$
\end_inset

 на составляющие их мономы: 
\begin_inset Formula 
\[
0=gf-fg=\sum_{m_{g}\in g}m_{g}\cdot f-\sum_{m_{f}\in f}m_{f}\cdot g.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Алгоритм F5 в исходной формулировке
\end_layout

\begin_layout Standard
Первым сигнатурным алгоритмом, получившим широкое распространение, стал
 алгоритм F5, сформулированный в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

.
 Хотя он по сути является инкрементальным алгоритмом, его исходная формулировка
 не допускает строго инкрементальной записи в определённом выше смысле,
 поскольку на каждом следующем шаге используется не только базис, найденный
 на предыдущем, но и некоторая информация о сигнатурах элементов этого базиса.
 Наиболее близкая к исходному алгоритму строго инкрементальная формулировка
 описывается в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 (Следствие 33).
\end_layout

\begin_layout Standard
Подробное изложение идей алгоритма дано в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, поэтому сформулируем здесь лишь главные из них.
 Объектами, над которыми работает алгоритм, в большинстве случаев являются
 не просто многочлены, а отмеченные многочлены, над которыми производятся
 сигнатурные редукции и арифметические операции, дающие результат с известной
 сигнатурой.
 Каждый инкрементальный шаг алгоритма соответствует алгоритму Бухбергера
 со следующими дополнениями:
\end_layout

\begin_layout Itemize
разрешены только сигнатурные редукции
\end_layout

\begin_layout Itemize
при взятии S-пары из очереди выбирается S-пара с наименьшей сигнатурой
\end_layout

\begin_layout Itemize
при образовании S-пар, построении S-многочленов и выборе редуктора для редукции,
 проверяются критерии, которым должен удовлетворять домноженный многочлен,
 чтобы не быть отброшенным.
\end_layout

\begin_layout Standard
Помимо этого F5 добавляет требование однородности всех входных многочленов
 и проводит вычисления таким образом, что все получаемые многочлены также
 однородны.
 С более подробным сравнением шага алгоритма F5 с алгоритмом Бухбергера
 можно ознакомиться в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "F5InBBStyle"

\end_inset


\end_layout

\begin_layout Subsubsection
Псевдокод F5
\end_layout

\begin_layout Standard
Для удобства дальнейших рассуждений об остановке алгоритма, приведём здесь
 полный псевдокод F5, основанный на исходной формулировке.
 Алгоритмически он эквивалентен ей во всём, кроме порядка обработки входных
 многочленов.
 Приводимая версия обрабатывает многочлены начиная с первого, в то время
 как в первоисточнике многочлены обрабатываются, начиная с последнего, что
 вызвано противоположным направлением сравнения индексов в определении порядка
 
\begin_inset Formula $\prec_{P}$
\end_inset

 на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
 Остальные отличия приводимого псевдокода от исходного носят лишь характер
 упрощения символики и самого псевдокода, но не вносят никаких изменений
 в сам алгоритм.
 Большинство используемых обозначений, включая названия этапов алгоритма,
 взято из первоисточника.
\end_layout

\begin_layout Paragraph
Глобальные переменные:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $R$
\end_inset

 Пополняемый массив отмеченных многочленов, нумеруемый числовыми индексами,
 начинающимися с единичного.
 Большая часть процедур оперирует не с отмеченными многочленами, а с их
 индексами в этом массиве.
 При редукции, многочлен, однажды добавленный в 
\begin_inset Formula $R$
\end_inset

, может меняться, но сигнатура любого элемента 
\begin_inset Formula $R$
\end_inset

 остаётся неизменной после первого добавления.
 Изначально 
\begin_inset Formula $R$
\end_inset

 заполняется входными многочленами, которые всегда являются первыми 
\begin_inset Formula $m$
\end_inset

 элементами, а в процессе работы пополняется со стороны конца
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\#R$
\end_inset

 Обозначает число отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, меняется при добавлении элементов в 
\begin_inset Formula $R$
\end_inset

.
 Используется для получения индекса только что добавленного в 
\begin_inset Formula $R$
\end_inset

 элемента
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Rule Массив правил перезаписи, содержащий 
\begin_inset Formula $m$
\end_inset

 элементов.
 Каждый элемент соответствует ровно одному индексу сигнатуры и в свою очередь
 является пополняемым массивом чисел, являющихся индексами отмеченных многочлено
в в 
\begin_inset Formula $R$
\end_inset

.
 Изначально Rule состоит из 
\begin_inset Formula $m$
\end_inset

 пустых массивов, которые в процессе работы пополняется со стороны начала
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\prec$
\end_inset

 Мономиальный порядок, используемый при определении 
\begin_inset Formula $\HM$
\end_inset

 и 
\begin_inset Formula $\HC$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\prec_{P}$
\end_inset

 Используемый порядок на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:AddRule"

\end_inset

AddRule
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\begin_inset Formula $k$
\end_inset


\series default
 -- индекс элемента в 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
Добавить 
\begin_inset Formula $k$
\end_inset

 в начало массива Rule[
\shape italic

\begin_inset Formula $\sigidx\left(R[k]\right)$
\end_inset


\shape default
] 
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:Rewritten?"

\end_inset

Rewritten?
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $u$
\end_inset

 -- моном, 
\series bold

\begin_inset Formula $k$
\end_inset


\series default
 -- индекс элемента в 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
булево значение, равное истине, если произведение 
\begin_inset Formula $u\cdot R[k]$
\end_inset

 отбрасывается критерием перезаписи
\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $L\leftarrow$
\end_inset


\shape default
 Rule[
\begin_inset Formula $\sigidx\left(R[k]\right)$
\end_inset

]
\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $r\leftarrow$
\end_inset

 число элементов 
\begin_inset Formula $L$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\begin_inset Formula $i=1,\dots,r$
\end_inset

 do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default
\shape italic

\begin_inset Formula $u\Sig(R[k])$
\end_inset

 
\shape default
делится на 
\begin_inset Formula $\Sig(R[L[i]])$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $k\ne L[i]$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return false
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:IncrementalF5"

\end_inset

IncrementalF5
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $F=[f_{1},\dots,f_{m}]$
\end_inset

 -- упорядоченный массив однородных многочленов
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $i$
\end_inset

 -- этап алгоритма, 
\begin_inset Formula $G_{i}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера идеала 
\begin_inset Formula $(f_{1},\dots,f_{i})$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
множество, образующее базис Грёбнера идеала 
\begin_inset Formula $(f_{1},\dots,f_{m})$
\end_inset

 с точки зрения порядка 
\begin_inset Formula $\prec$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $R\leftarrow[((1,1),f_{1}),((1,2),f_{2}),\dots,((1,m),f_{m})]$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $G_{1}\leftarrow\{1\}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\begin_inset Formula $i=2,\dots,m$
\end_inset

 do
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\begin_inset Formula $G_{i}\leftarrow$
\end_inset

 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\begin_inset Formula $(((1,i),f_{i}),G_{i-1})$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\left\{ poly(R[r])|r\in G_{m}\right\} $
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:AlgorithmF5"

\end_inset

AlgorithmF5
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $((1,i),f_{i})$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $G_{i-1}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера некоторого идеала 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset

, 
\begin_inset Formula $d$
\end_inset

 -- число, соответствующее минимальной степени оставшихся S-пар, 
\begin_inset Formula $P$
\end_inset

 -- упорядоченный список S-пар отмеченных многочленов, 
\begin_inset Formula $P_{d}$
\end_inset

 -- подмножество S-пар фиксированной степени, 
\begin_inset Formula $F_{d},R_{d}$
\end_inset

 -- некоторые множества индексов 
\begin_inset Formula $R$
\end_inset

, соответствующие многочленам фиксированной степени, 
\begin_inset Formula $r,p$
\end_inset

 -- индексы элементов в 
\begin_inset Formula $R$
\end_inset

, используемые при итерировании
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default

\begin_inset Formula $G_{i}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера идеала 
\begin_inset Formula $\left(\left\{ poly(R[r])|r\in G_{i-1}\right\} \cup f_{i}\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}=G_{i-1}\cup\left\{ i\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $\varphi\leftarrow$
\end_inset


\shape default
 оператор нормальной формы, производящий полную редукцию по множеству многочлено
в 
\begin_inset Formula $\left\{ poly(R[r])|r\in G_{i-1}\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow$
\end_inset


\shape default
 отсортированный по возрастанию сокращаемого монома список 
\family typewriter
{
\family default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\family sans

\begin_inset Formula $(i,r,i,\varphi)|r\in G_{i-1}$
\end_inset

}
\end_layout

\begin_layout Enumerate

\family sans
\series bold
while 
\series default

\begin_inset Formula $P\ne\varnothing$
\end_inset

 
\series bold
do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $d\leftarrow\totaldeg\left(\HM\left(P[1]\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $P_{d}\leftarrow\{p\in P|\totaldeg($
\end_inset

сокращаемого монома
\begin_inset Formula $)=d\}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\setminus P_{d}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $F_{d}\leftarrow$
\end_inset


\family typewriter
\shape default
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset


\family sans

\begin_inset Formula $(P_{d})$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $R_{d}\leftarrow$
\end_inset


\shape default
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset


\begin_inset Formula $(F_{d},G_{i},\varphi)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\series default
\shape italic

\begin_inset Formula $r\in R_{d}$
\end_inset


\series bold
\shape default
 do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\cup\{$
\end_inset


\shape default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\begin_inset Formula $(r,p,i,\varphi)|p\in G_{i}\}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}\leftarrow G_{i}\cup\left\{ r\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
Отсортировать 
\begin_inset Formula $P$
\end_inset

 по возрастанию сокращаемого монома 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $G_{i}$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:CritPair"

\end_inset

CritPair
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $r_{1},r_{2}$
\end_inset

 -- индексы отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, 
\begin_inset Formula $k$
\end_inset

 -- число, обозначающее индекс сигнатур, для которого проверяется нормальная
 форма, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $t,t_{1},t_{2},u_{1},u_{2}$
\end_inset

 -- мономы
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
множество S-пар отмеченных многочленов, содержащее не более одного элемента
\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $t\leftarrow\LCM\left(\HM(R[r_{1}]),\HM(R[r_{2}])\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\series default
\shape italic

\begin_inset Formula $i=1,2$
\end_inset


\series bold
\shape default
 do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $u_{i}\leftarrow\frac{1}{\HC(R[r_{i}])}\frac{t}{\HM(R[r_{i}])}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $t_{i}\leftarrow$
\end_inset

 моном сигнатуры 
\begin_inset Formula $R[r_{i}]$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $u_{1}\Sig(R[r_{1}])\prec_{P}u_{2}\Sig(R[r_{2}])$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\family typewriter
\series default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\family sans

\begin_inset Formula $(r_{2},r_{1},k,\varphi)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $\varphi(u_{1}t_{1})\ne u_{1}t_{1}$
\end_inset

 
\series bold
then
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\varnothing$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
if 
\series default
\shape italic

\begin_inset Formula $\sigidx(R[r_{2}])=k$
\end_inset

 
\series bold
\shape default
and
\series default
 
\begin_inset Formula $\varphi(u_{2}t_{2})\ne u_{2}t_{2}$
\end_inset

 
\series bold
then
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\varnothing$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\left\{ \left(u_{1}\cdot R[r_{1}],u_{2}\cdot R[r_{2}]\right)\right\} $
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\begin_inset CommandInset label
LatexCommand label
name "par:Spol"

\end_inset


\series medium
Spol
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $P=\left\{ p_{1},\dots,p_{h}\right\} $
\end_inset

 -- множество S-пар фиксированной степени
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $(u\cdot R[r_{i}],v\cdot R[r_{j}])$
\end_inset

 -- S-пара отмеченных многочленов
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default

\begin_inset Formula $F$
\end_inset

 -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих отмеченным многочленам, полученным из входных S-пар как
 S-многочлены
\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $F\leftarrow\varnothing$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
for 
\begin_inset Formula $l=1,\dots,h$
\end_inset

 do 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(u\cdot R[r_{i}],v\cdot R[r_{j}])\leftarrow P[l]$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default
(
\series bold
not
\series default
 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\family sans

\begin_inset Formula $(u,r_{i})$
\end_inset

) 
\series bold
and
\series default
 (
\series bold
not
\series default
 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\family sans

\begin_inset Formula $(v,r_{j})$
\end_inset

) 
\series bold
then
\end_layout

\begin_deeper
\begin_layout Enumerate
Добавить 
\family sans

\begin_inset Formula $(u\Sig(R[r_{i}]),u\poly(R[r_{i}])-v\poly(R[r_{j}]))$
\end_inset


\family default
 в конец 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AddRule"

\end_inset


\family sans

\begin_inset Formula $\left(\#R\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $F\leftarrow F\cup\left\{ \#R\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default
\shape italic

\begin_inset Formula $F$
\end_inset


\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:Reduction"

\end_inset

Reduction
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default
ToDo, 
\begin_inset Formula $G$
\end_inset

 -- множества индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих отмеченным многочленам, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $h$
\end_inset

 -- индекс отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, Done
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

, ToDo
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

 -- множества индексов 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
Done -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих отмеченным многочленам из ToDo, редуцированным по многочленам
 из 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
while 
\series default
ToDo 
\begin_inset Formula $\ne\varnothing$
\end_inset

 
\series bold
do 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $h\leftarrow$
\end_inset


\family sans
 индекс из ToDo
\family default
,
\family sans
 соответствующий многочлену с минимальной по 
\begin_inset Formula $\prec_{P}$
\end_inset

 среди ToDo сигнатурой
\end_layout

\begin_layout Enumerate

\family sans
ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 ToDo
\begin_inset Formula $\setminus\left\{ h\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R[h]\leftarrow\left(\Sig(R[h]),\varphi(\poly(R[h]))\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $($
\end_inset


\shape default
Done
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

, ToDo
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset

) 
\family default

\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

(
\shape italic

\begin_inset Formula $h,G\cup$
\end_inset


\shape default
Done
\shape italic
, 
\begin_inset Formula $\varphi$
\end_inset


\shape default
) 
\end_layout

\begin_layout Enumerate

\family sans
Done
\family default
 
\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 Done
\shape italic
 
\shape default

\begin_inset Formula $\cup$
\end_inset

 Done
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\family sans
ToDo
\family default
 
\begin_inset Formula $\leftarrow$
\end_inset


\family sans
 ToDo 
\begin_inset Formula $\cup$
\end_inset

 ToDo
\begin_inset script subscript

\begin_layout Plain Layout

\family sans
1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default
Done
\shape italic
 
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:IsReducible"

\end_inset

IsReducible
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $r_{0}$
\end_inset

 -- индекс отмеченного многочлена в 
\begin_inset Formula $R$
\end_inset

, для которого выполняется поиск возможных сигнатурных редукций, 
\begin_inset Formula $G$
\end_inset

 -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих потенциальным редукторам, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $u$
\end_inset

 -- моном, 
\begin_inset Formula $r_{j}$
\end_inset

 -- индекс в 
\begin_inset Formula $R$
\end_inset

 для итерирования по 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $t_{j}$
\end_inset

 -- моном сигнатуры
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих возможным редукторам, содержащее не более одного элемента
\end_layout

\begin_layout Enumerate

\family sans
\series bold
for
\series default
 
\begin_inset Formula $r_{j}\in G$
\end_inset


\series bold
 do:
\series default
 
\series bold
if 
\series default
одновременно выполнены 4 нижеследующих условия
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-a"

\end_inset


\begin_inset Formula $u=\frac{HT(R[r_{0}])}{HT(R[r_{\text{j}}])}$
\end_inset

 -- корректный моном из 
\begin_inset Formula $\mathbb{T}$
\end_inset

, т.е.
 числитель делится на знаменатель
\end_layout

\begin_layout Enumerate

\family sans
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-b"

\end_inset


\begin_inset Formula $\varphi(ut_{j})=ut_{j}$
\end_inset

, где 
\begin_inset Formula $t_{j}$
\end_inset

 -- моном сигнатуры 
\begin_inset Formula $\Sig(R[r_{j}])$
\end_inset

.
\end_layout

\begin_layout Enumerate

\family sans
\series bold
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-c"

\end_inset

not
\series default
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $(u,r_{j})$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset CommandInset label
LatexCommand label
name "enu:IsRed-d"

\end_inset


\begin_inset Formula $u\Sig(R[r_{j}])\ne\Sig(R[r_{0}])$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
then return 
\series default

\begin_inset Formula $\left\{ r_{j}\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default

\begin_inset Formula $\varnothing$
\end_inset

 
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:TopReduction"

\end_inset

TopReduction
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $r_{0}$
\end_inset

 -- индекс отмеченного многочлена в 
\begin_inset Formula $R$
\end_inset

, для которого выполняется редукция, 
\begin_inset Formula $G$
\end_inset

 -- множество индексов 
\begin_inset Formula $R$
\end_inset

, соответствующих многочленам, используемых в качестве редукторов, 
\begin_inset Formula $\varphi$
\end_inset

 -- функция нормальной формы на 
\begin_inset Formula $\mathcal{P}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $r'$
\end_inset

 -- множество индексов элементов 
\begin_inset Formula $R$
\end_inset

, являющихся потенциальными редукторами, 
\begin_inset Formula $r_{1}$
\end_inset

 -- конкретный его элемент, 
\begin_inset Formula $u$
\end_inset

 -- моном
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default
Редуцированный многочлен перезаписывает 
\begin_inset Formula $R[r_{0}]$
\end_inset

.
 Возвращаемое значение -- пара множеств (ToDo, Done) содержащих индексы
 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $\poly(R[r_{0}])=0$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
Warning 
\series default

\begin_inset Quotes eld
\end_inset

На вход алгоритма подана нерегулярная последовательность” 
\end_layout

\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done
\family default
 
\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
, ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
) 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $R[r_{0}]\leftarrow\left(\Sig(R[r_{0}]),\frac{\poly(R[r_{0}])}{\HC(R[r_{0}])}\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
\begin_inset Formula $r'\leftarrow$
\end_inset


\family sans
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

(
\begin_inset Formula $h,G,\varphi$
\end_inset

) 
\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default
\shape italic

\begin_inset Formula $r'=\varnothing$
\end_inset


\series bold
\shape default
 then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done
\family default
 
\begin_inset Formula $\leftarrow\left\{ r_{0}\right\} $
\end_inset


\family sans
, ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
) 
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
else 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $r_{1}\leftarrow$
\end_inset


\shape default
любой элемент 
\begin_inset Formula $r'$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\begin_inset Formula $u\leftarrow\frac{HM(R[r_{0}])}{HM(R[r_{1}])}$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
if 
\series default

\begin_inset Formula $u\Sig(R[r_{1}])\prec_{\tau}\Sig(R[r_{1}])$
\end_inset

 
\series bold
then 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\begin_inset Formula $R[r_{0}]\leftarrow\left(\Sig(R[r_{0}]),\poly(R[r_{0}])-u\poly(R[r_{1}])\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done 
\family default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
, ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\left\{ r_{0}\right\} $
\end_inset

)
\end_layout

\end_deeper
\begin_layout Enumerate

\family sans
\series bold
else 
\end_layout

\begin_deeper
\begin_layout Enumerate
Добавить 
\family sans

\begin_inset Formula $(u\Sig(R[r_{1}]),\poly(R[r_{0}])-u\poly(R[r_{1}])$
\end_inset


\family default
 в конец 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family typewriter
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AddRule"

\end_inset


\family sans

\begin_inset Formula $\left(\#R\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\series bold
return 
\series default
(Done 
\family default

\begin_inset Formula $\leftarrow\varnothing$
\end_inset


\family sans
, ToDo
\shape italic
 
\family default
\shape default

\begin_inset Formula $\leftarrow\left\{ r_{0},\#R\right\} $
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Доказательство остановки
\end_layout

\begin_layout Standard
Алгоритм F5 является эффективным алгоритмом вычисления базисов Грёбнера,
 но обладает рядом проблем, связанных с его обоснованием.
 Корректность его работы при условии остановки показана в первоисточнике
 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 и в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "GermanF5Proof_ru,F5InBBStyle,NewF5Proof"

\end_inset

, предложивших другие способы её доказательства.
 Но остановка алгоритма, как в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, так и в детальных исследованиях 
\begin_inset CommandInset citation
LatexCommand cite
key "F5-revisited"

\end_inset

, показана только для случая отсутствия редукций к нулю.
 В свою очередь, отсутствие редукций к нулю доказано для случая, когда входное
 множество многочленов представлено регулярной последовательностью, а среди
 нерегулярных последовательностей известны примеры, приводящие к появлению
 в алгоритме F5 редукций к нулю.
 При этом, примеров, приводящих к отсутствию остановки алгоритма, найдено
 не было.
 Поскольку для большинства входных последовательностей их регулярность неизвестн
а, эти исследования не позволяют ответить на вопрос завершения практической
 реализации алгоритма на конкретных входных данных.
 Один из подходов к решению проблемы -- добавление в алгоритм дополнительных
 проверок и критериев, гарантирующих остановку алгоритма.
 Этот подход даёт строгое доказательство остановки, однако, получаемый результат
 есть доказательство остановки модифицированной версии F5, содержащей дополнител
ьные проверки, которая в силу этого может быть более сложна в реализации
 или иметь большее время работы на некоторых входных данных.
 Этот подход применяется в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "Modifying-for-termination,Ars05applicationsdes,Gash:2008:ECG,Hashemi-ExtF5,ZobninGeneralization_ru"

\end_inset

.
\end_layout

\begin_layout Standard
Другой подход состоит в доказательстве остановки семейства алгоритмов, основанны
х на идеях F5, с последующей попыткой переформулировать F5 таким образом,
 чтобы он являлся представителем этого семейства.
 Основная проблема этого подхода появляется в процессе переформулировки:
 описание F5 в других терминах может привести к незаметному внесению различий
 в поведение алгоритма, которые потребуют дополнительных рассуждений для
 доказательства эквивалентности с F5.
 К примеру, 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

 доказывает остановку алгоритма F5GEN, который отличается от исходного F5
 отсутствием проверки критериев при выборе редуктора.
 Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 даёт доказательство остановки алгоритма TRB-F5, который, как удалось осознать
 автору в процессе плодотворных дискуссий с Джоном Перри, имеет два существенных
 отличия от F5.
 Первое отличие -- другая схема построения правил, приводящая в конце концов
 к тому, что в процессе выполнения TRB-F5 правила в массивах Rule оказываются
 отсортированными по возрастанию сигнатуры.
 Второе отличие -- отсутствие в TRB-F5 применения оператора нормальной формы
 
\begin_inset Formula $\varphi$
\end_inset

 перед редукцией, что приводит к эффекту противоположному отличиям F5 от
 F5GEN: алгоритм TRB-F5 при выборе редуктора проверяет критерии для элементов
 с индексами сигнатуры, отличными от текущего, которые в F5 используются
 неявно в операторе нормальной формы и за счёт этого не подвергаются проверке
 критериев.
 Предположительно, эти алгоритмы могут быть изменены таким образом, чтобы
 в точности повторять поведение алгоритма F5, а доказательство остановки
 может быть перенесено на изменённые версии.
 Однако, подход с алгоритмами, эквивалентными F5, имеет и другой недостаток
 -- он усложняет понимание того, как теоремы, используемые для доказательства
 остановки, отражают поведение исходного алгоритма F5.
\end_layout

\begin_layout Standard
Подход к доказательству остановки, представляемый в данной работе, применяется
 к F5 без каких-либо модификаций.
 Первый шаг доказательства основан на предлагаемой ниже идее цепей S-пар.
 Второй шаг основывается на методе, использованном в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 (теорема 21) для доказательства корректности алгоритма F5C: сигнатурное
 представление S-многочлена над множеством, вычисленным F5C, может быть
 модифицировано последовательностью замен S-пар и их отброшенных частей,
 и за конечное число таких шагов приведено к состоянию, когда выполняются
 определённые 
\begin_inset Quotes fld
\end_inset

хорошие
\begin_inset Quotes frd
\end_inset

 свойства.
 Для применения этого метода к доказательству остановки F5 он сформулирован
 таким образом, что его предусловия ослаблены для применения к множеству
 на любом промежуточном шаге вычислений F5, а получаемые следствия усилены
 для их использования в доказательстве остановки.
\end_layout

\begin_layout Subsubsection
Потенциально бесконечные циклы в F5
\end_layout

\begin_layout Paragraph
Процедура 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
: увеличение 
\begin_inset Formula $d$
\end_inset


\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "iterations-d_grow"

\end_inset

Если при некоторых входных данных цикл 
\series bold
while
\series default
 внутри процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
 выполняется бесконечное число раз, то значение 
\begin_inset Formula $d$
\end_inset

 неограниченно возрастает.
\end_layout

\begin_layout Proof
Предположим существование последовательности многочленов 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 в кольце 
\begin_inset Formula $\mathcal{P}$
\end_inset

 для которой алгоритм F5 не завершается.
 Без ограничение общности будем считать что это самая короткая последовательност
ь такого рода -- алгоритм завершается на более короткой последовательности
 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m-1}\right\} $
\end_inset

.
 Это означает, что не завершается последняя итерация цикла внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IncrementalF5"

\end_inset

, то есть не завершается последний вызов процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
.
 Для исследования данной ситуации необходимо понять, как ведёт себя значение
 полной степени 
\begin_inset Formula $d$
\end_inset

 в процессе выполнения цикла внутри процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset


\family default
.
 Обозначим за 
\begin_inset Formula $d_{j}$
\end_inset

 значение 
\begin_inset Formula $d$
\end_inset

 на 
\begin_inset Formula $j$
\end_inset

-ой итерации цикла и положим 
\begin_inset Formula $d_{0}=-1$
\end_inset

.
 Простейшее свойство 
\begin_inset Formula $d_{j}$
\end_inset

 -- неубывание: 
\begin_inset Formula $d_{j}\geqslant d_{j-1}$
\end_inset

.
 Оно выполняется, поскольку на 
\begin_inset Formula $j-1$
\end_inset

-ой итерации все многочлены в 
\begin_inset Formula $R_{d}$
\end_inset

 имеют степень 
\begin_inset Formula $d_{j-1}$
\end_inset

, и поэтому все вновь создаваемые S-пары имеют степень не менее 
\begin_inset Formula $d_{j-1}$
\end_inset

.
 Предположим теперь, что 
\begin_inset Formula $j$
\end_inset

 -- фиксированный номер некоторой итерации.
 В начале итерации 
\begin_inset Formula $j$
\end_inset

 все критические пары степени 
\begin_inset Formula $d_{j}$
\end_inset

 извлекаются из 
\begin_inset Formula $P$
\end_inset

.
 После вызова процедуры 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset


\family default
 в 
\begin_inset Formula $P$
\end_inset

 добавляются некоторые новые S-пары в цикле, итерирующем по 
\begin_inset Formula $R_{d}$
\end_inset

.
 Существует возможность, что некоторые из них будут иметь полную степень
 равную 
\begin_inset Formula $d_{j}$
\end_inset

.
 Нижеследующие рассуждения призваны показать, что все критические пары такой
 полной степени будут отброшены на следующей итерации алгоритма и ни одна
 из них не породит S-многочлен.
\end_layout

\begin_layout Proof
Для каждой из S-пар 
\begin_inset Formula $\left(u_{1}\cdot R\left[r_{1}\right],u_{2}\cdot R\left[r_{2}\right]\right)$
\end_inset

, порождённых на итерации 
\begin_inset Formula $j$
\end_inset

, как минимум один из многочленов пары принадлежит 
\begin_inset Formula $R_{d}$
\end_inset

 и не более чем один многочлен из пары мог принадлежать 
\begin_inset Formula $G_{i}$
\end_inset

 на момент начала итерации.
 Все многочлены 
\begin_inset Formula $R_{d}$
\end_inset

 генерируются процедурой 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset


\family default
, путём добавления по одному многочлену к множеству Done.
 Поэтому, среди одного или двух многочленов критической пары, принадлежащих
 
\begin_inset Formula $R_{d}$
\end_inset

, мы можем выбрать индекс многочлена 
\begin_inset Formula $r_{k}$
\end_inset

, добавленный в Done позже.
 Тогда про другой многочлен S-пары 
\begin_inset Formula $r_{3-k}$
\end_inset

 можно утверждать, что он уже присутствовал в 
\begin_inset Formula $G\cup$
\end_inset

Done к моменту добавления 
\begin_inset Formula $r_{k}$
\end_inset

 в Done.
 Поэтому процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 пыталась редуцировать 
\begin_inset Formula $R\left[r_{k}\right]$
\end_inset

 по 
\begin_inset Formula $R\left[r_{3-k}\right]$
\end_inset

, но не сделала этого, поскольку, в функции 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset


\family default
 одна из проверок 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-a"

\end_inset

 - 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 запретила использование редуктора.
\end_layout

\begin_layout Proof
При этом, для критических пар с полной степенью равной 
\begin_inset Formula $d_{j}$
\end_inset

, мы имеем 
\begin_inset Formula $u_{k}=1$
\end_inset

, поскольку, полная степень критической пары равна полной степени её челна
 
\begin_inset Formula $\totaldeg\left(\HM\left(R\left[r_{k}\right]\right)\right)$
\end_inset

.
 Это означает, что значение 
\begin_inset Formula $u_{3-k}$
\end_inset

 равно 
\begin_inset Formula $\frac{\HM(R\left[r_{k}\right])}{\HM(R\left[r_{3-k}\right])}$
\end_inset

, поэтому в 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset


\family default
 правило 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-a"

\end_inset

 разрешает редукцию 
\begin_inset Formula $R\left[r_{k}\right]$
\end_inset

 по 
\begin_inset Formula $R\left[r_{3-k}\right]$
\end_inset

.
 Получается, что только правила 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 - 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 могли запретить редукцию.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

.
 Это означает, что в 
\begin_inset Formula $G_{i-1}$
\end_inset

 существует многочлен, редуцирующий 
\begin_inset Formula $u_{3-k}t_{3-k}$
\end_inset

, где 
\begin_inset Formula $t_{3-k}$
\end_inset

 -- моном сигнатуры 
\begin_inset Formula $\Sig\left(R\left[r_{3-k}\right]\right)$
\end_inset

.
 Для нашего случая отсюда следовало бы, что в функции 
\family typewriter

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset


\family default
 эквивалентная проверка 
\begin_inset Formula $\varphi(u_{3-k}t_{3-k})=u_{3-k}t_{3-k}$
\end_inset

 запретила бы создание критической пары.
 Получается, что правило 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 также не могло запретить редукцию.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

.
 Это означает существование перезаписи для домноженного редуктора.
 В нашем случае это значит, что 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 показала наличие перезаписи в процессе выполнения 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 и будет продолжать возвращать значение 
\begin_inset Quotes fld
\end_inset

Истина
\begin_inset Quotes frd
\end_inset

 на всех последующих этапах алгоритма, поскольку перезаписывающие многочлены
 не могут исчезнуть.
\end_layout

\begin_layout Proof
Предположим, что редукция была запрещена правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

.
 Это обозначает, что сигнатуры 
\begin_inset Formula $r_{k}$
\end_inset

 и 
\begin_inset Formula $u_{3-k}r_{3-k}$
\end_inset

 равны.
 Значит, вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 будет возвращать 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

 после добавления правила, соответствующего 
\begin_inset Formula $r_{k}$
\end_inset

, поскольку, 
\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 перезаписывается 
\begin_inset Formula $\left(1,r_{k}\right)$
\end_inset

.
 Получается, что как и в случае с правилом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 возвращает 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

 при выполнении 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 и позже.
\end_layout

\begin_layout Proof
Теперь рассмотрим функцию 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

, выполняемую для некоторой S-пары полной степени 
\begin_inset Formula $d_{j}$
\end_inset

, добавленной в 
\begin_inset Formula $P$
\end_inset

 на итерации 
\begin_inset Formula $j$
\end_inset

.
 Она выполняется внутри 
\begin_inset Formula $j+1$
\end_inset

 итерации цикла в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, то есть уже после того, как закончилось выполнение 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 для 
\begin_inset Formula $r_{k}$
\end_inset

.
 Поэтому для случаев 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\begin_inset Formula $\left(u_{3-k},r_{3-k}\right)$
\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 вернёт 
\begin_inset Quotes fld
\end_inset

Истину
\begin_inset Quotes frd
\end_inset

.
 Значит, на итерации 
\begin_inset Formula $j+1$
\end_inset

 ни одна из S-пар полной степени 
\begin_inset Formula $d_{j}$
\end_inset

 не добавит многочлена в 
\begin_inset Formula $F_{d}$
\end_inset

.
\end_layout

\begin_layout Proof
Итого, получено: 
\end_layout

\begin_deeper
\begin_layout Itemize
первая возможность относительного расположения 
\begin_inset Formula $d_{j+1}$
\end_inset

 и 
\begin_inset Formula $d_{j}$
\end_inset

 -- их равенство: 
\begin_inset Formula $d_{j+1}=d_{j}$
\end_inset

.
 В этом случае 
\begin_inset Formula $F_{d}$
\end_inset

 оказывается пустым на итерации 
\begin_inset Formula $j+1$
\end_inset

, и, таким образом, 
\begin_inset Formula $P$
\end_inset

 не содержит ни одной пары с полной степенью 
\begin_inset Formula $d_{j}$
\end_inset

 после того как итерация 
\begin_inset Formula $j+1$
\end_inset

 завершится.
 Значит 
\begin_inset Formula $d_{j+2}>d_{j+1}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Другая возможность относительного расположения -- строгое возрастание 
\begin_inset Formula $d_{j+1}>d_{j}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Вместе эти факты дают 
\begin_inset Formula $\forall j\,\, d_{j+2}>d_{j}$
\end_inset

, что доказывает утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterations-d_grow"

\end_inset

.
\end_layout

\begin_layout Paragraph
Процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

: конечность ToDo
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "Every_cycle_iteration_finish"

\end_inset

Каждая итерация цикла внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 останавливается, в частности останавливаются все вызовы процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

.
\end_layout

\begin_layout Proof
Факт остановки известен для вызовов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, соответствующих многочленам 
\begin_inset Formula $f_{1},\dots,f_{m-1}$
\end_inset

, поэтому будет рассматриваться лишь один оставшийся вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, обрабатывающий последний элемент входного набора многочленов 
\begin_inset Formula $f_{m}$
\end_inset

.
 Вначале покажем несколько общих утверждений о многочленах в множествах
 ToDo и Rule в процессе 
\begin_inset Formula $j$
\end_inset

-ой итераций цикла внутри этого вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

.
 Старшая по сигнатуре часть S-пары всех критических пар, добавляемых функцией
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 вначале выполнения 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, обладает индексом сигнатуры равным 
\begin_inset Formula $m$
\end_inset

.
 Все прочие критические пары порождаются с индексом сигнатуры, соответствующим
 некоторому отмеченному многочлену, перемещённому из множества ToDo в множество
 Done.
 В свою очередь, все элементы ToDo создаются или на основе критических пар
 или внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Многочлены, генерируемые 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 имеют сигнатуру, превышающую сигнатуру многочлена, который редуцирует данный
 вызов процедуры и который является элементом ToDo.
 Поэтому, многочлен или критическая пара с индексом сигнатуры, отличным
 от 
\begin_inset Formula $m$
\end_inset

 не могут появиться в рассматриваемом вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

.
 С другой стороны, все многочлены в ToDo имеют одну и ту же полную степень
 
\begin_inset Formula $d_{j}$
\end_inset

.
 Вместе с равенством индексов это позволяет заключить, что полная степень
 мономов сигнатур равна 
\begin_inset Formula $d_{j}-\totaldeg(f_{m})$
\end_inset

 для всех элементов ToDo.
\end_layout

\begin_layout Proof
Каждое добавление элемента в массив Rule соответствует добавлению в множество
 ToDo.
 Поэтому, элементы добавляемые в начало Rule
\begin_inset Formula $[m]$
\end_inset

 на итерации 
\begin_inset Formula $j$
\end_inset

 имеют полную степень равную 
\begin_inset Formula $d_{j}$
\end_inset

.
 Вспоминая неубывание 
\begin_inset Formula $d_{j}$
\end_inset

, получаем что на 
\begin_inset Formula $j$
\end_inset

-ой итерации все элементы Rule с индексом сигнатуры 
\begin_inset Formula $m$
\end_inset

 имеют полную степень 
\begin_inset Formula $\leqslant d_{j}$
\end_inset

 и полную степень монома сигнатуры 
\begin_inset Formula $\leqslant d_{j}-\totaldeg(f_{m})$
\end_inset

.
 Также это даёт следующий факт:
\end_layout

\begin_deeper
\begin_layout Fact
Полная степень элементов Rule
\begin_inset Formula $[m]$
\end_inset

 не возрастает.
\end_layout

\end_deeper
\begin_layout Proof
Алгоритм производит только сигнатурные редукции: процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 производит редукцию по неотброшенному редуктору, если он сигнатурный, и
 добавляет элемент в ToDo в противном случае.
 Элементы ToDo обрабатываются в порядке возрастания сигнатур, поэтому ни
 один из элементов 
\begin_inset Formula $G\cup$
\end_inset

Done не может иметь сигнатуры, превышающей сигнатуру многочлена 
\begin_inset Formula $R\left[r_{k}\right]$
\end_inset

, редуцируемого в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Рассмотрим неотброшенный проверками редуктор 
\begin_inset Formula $R\left[r_{q}\right]$
\end_inset

.
 Если он имеет полную степень 
\begin_inset Formula $\totaldeg(R\left[r_{q}\right])=\totaldeg(R\left[r_{k}\right])$
\end_inset

, мы получаем свойства 
\begin_inset Formula $t=1$
\end_inset

 и 
\begin_inset Formula $\Sig(R\left[r_{k}\right])\succ\Sig(R\left[r_{q}\right])$
\end_inset

, гарантирующие что редукция по нему будет сигнатурной.
 Случай 
\begin_inset Formula $\Sig(R\left[r_{k}\right])=\Sig(R\left[r_{q}\right])$
\end_inset

 невозможен, поскольку такие редукторы отбрасываются в правиле 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Таким образом, ситуация 
\begin_inset Formula $\Sig(R\left[r_{k}\right])\prec t\cdot\Sig(R\left[r_{q}\right])$
\end_inset

 возможна только при 
\begin_inset Formula $\totaldeg(R\left[r_{q}\right])<\totaldeg(R\left[r_{k}\right])$
\end_inset

 и все добавления в ToDo в процессе 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 соответствуют этому случаю.
 Моном сигнатуры многочлена, добавляемого таким образом, равен 
\begin_inset Formula $t\cdot\Sig(R\left[r_{q}\right])$
\end_inset

 и тот факт что 
\begin_inset Formula $r_{q}$
\end_inset

 не был отброшен проверкой правила 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 гарантирует, что ни одного многочлена с сигнатурой 
\begin_inset Formula $t\Sig(R\left[r_{q}\right])$
\end_inset

 не было порождено, потому что иначе такой многочлен имел бы связанное с
 ним правило в Rule с большей полной степенью, чем правило, соответствующее
 
\begin_inset Formula $r_{q}$
\end_inset

, и 
\begin_inset Formula $r_{q}$
\end_inset

 был бы отброшен в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Таким образом, показан вспомогательный факт
\end_layout

\begin_deeper
\begin_layout Fact
Добавление в ToDo элемента с сигнатурой 
\begin_inset Formula $t\in\mathbf{T}$
\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 возможно, только если элемент с такой сигнатурой не добавлялся в ToDo ранее.
\end_layout

\end_deeper
\begin_layout Proof
Мы хотим показать, что единственная возможность отсутствия остановки алгоритма
 соответствует случаю неограниченного возрастания 
\begin_inset Formula $d_{j}$
\end_inset

.
 Мы показали, что отсутствие остановки алгоритма происходит в случае, когда
 не завершается вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, и что он не может зациклиться, обрабатывая бесконечное число итераций
 итерации с одним и тем же значением 
\begin_inset Formula $d$
\end_inset

.
 Остаются два варианта: неограниченное возрастание 
\begin_inset Formula $d$
\end_inset

 и зацикливание внутри одной из итераций с фиксированным значением.
 Далее показано, что такое зацикливание невозможно.
 Процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 содержит 3 цикла помимо главного:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
for
\series default
-цикл внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 завершается, поскольку, число его итераций ограничено числом критических
 пар к моменту начала выполнения цикла;
\end_layout

\begin_layout Itemize

\series bold
for
\series default
-цикл внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 проходит по элементам 
\begin_inset Formula $R_{d}$
\end_inset

 и также завершается, поскольку, число элементов 
\begin_inset Formula $R_{d}$
\end_inset

 зафиксировано к моменту начала выполнения цикла;
\end_layout

\begin_layout Itemize
наиболее сложный случай соответствует 
\series bold
while
\series default
-циклу внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

, который выполняется до тех пор, пока множество ToDo не станет пустым.
 Множество ToDo изначально заполняется процедурой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и потом дополняется новыми элементами в процессе выполнения 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 порождает конечное число элементов, поскольку она завершается, а все элементы
 добавляемые 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 имеют различные сигнатуры индекса 
\begin_inset Formula $m$
\end_inset

, поэтому их число ограничено числом различных сигнатур полной степени 
\begin_inset Formula $d_{j}-\totaldeg(f_{1})$
\end_inset

, поэтому в ToDo добавляется лишь конечное число элементов.
 Теперь мы покажем, что все типы шагов, происходящих внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 могут быть выполнены лишь конечное число раз:
\end_layout

\begin_deeper
\begin_layout Itemize
шаг, на котором 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращает пустое множество, соответствует переносу элемента множества
 ToDo в Done и число таких шагов ограничено числом элементов, добавляемых
 в ToDo
\end_layout

\begin_layout Itemize
шаг, на котором 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращает не сигнатурный редуктор, соответствует добавлению нового элемента
 в ToDo и число таких шагов ограничено числом возможных добавлений
\end_layout

\begin_layout Itemize
шаг, на котором 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращает сигнатурный редуктор, соответствует редукции одного из элементов
 ToDo.
 Это может произойти лишь конечное число раз, поскольку в ToDo добавляется
 конечное число многочленов и не может существовать бесконечной цепочки
 редукций для одного многочлена, поскольку в процессе редукции его старший
 моном 
\begin_inset Formula $\HM$
\end_inset

 строго 
\begin_inset Formula $\prec$
\end_inset

-убывает, а множество мономов вполне упорядочено по 
\begin_inset Formula $\prec$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Proof
Мы получили, что все циклы внутри процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, кроме главного, завершаются, что доказывает утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "Every_cycle_iteration_finish"

\end_inset

.
\end_layout

\begin_layout Standard
Отсюда получается следующий факт о поведении алгоритма в ситуации, когда
 он не завершается:
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "d-does-grow"

\end_inset

Если алгоритм не завершается на некоторых входных данных, то значение 
\begin_inset Formula $d$
\end_inset

 неограниченно возрастает в процессе итераций.
\end_layout

\begin_layout Proof
Следует из комбинирования утверждений 
\begin_inset CommandInset ref
LatexCommand ref
reference "iterations-d_grow"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "Every_cycle_iteration_finish"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Цепи S-пар
\end_layout

\begin_layout Standard
Утверждение 
\begin_inset CommandInset ref
LatexCommand ref
reference "d-does-grow"

\end_inset

 показывает, что в случае отсутствия остановки, работа алгоритма приводит
 к появлению бесконечной последовательности ненулевых отмеченных многочленов
 с неограниченно возрастающей полной степенью, добавляемых в 
\begin_inset Formula $G_{i}$
\end_inset

.
 То есть, в этом случае, алгоритм порождает в 
\begin_inset Formula $R$
\end_inset

 бесконечную последовательность отмеченных многочленов 
\begin_inset Formula $\left\{ R[1],\ldots,R[m],\ldots,R[l],\ldots\right\} $
\end_inset

, в которой 
\begin_inset Formula $R[1],\ldots,R[m]$
\end_inset

 соответствуют 
\begin_inset Formula $m$
\end_inset

 исходным многочленам, а остальные были получены в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 В обоих случаях новый элемент 
\begin_inset Formula $R[l]$
\end_inset

 порождается как S-многочлен двух, уже ранее добавленных в последовательность
 многочленов.
 Будем обозначать за 
\begin_inset Formula $l^{*}$
\end_inset

 и 
\begin_inset Formula $l_{*}$
\end_inset

 позиции многочленов, использовавшихся для генерации 
\begin_inset Formula $l$
\end_inset

-го многочлена последовательности и за 
\begin_inset Formula $\overline{u_{l}}$
\end_inset

, 
\begin_inset Formula $\underline{u_{l}}$
\end_inset

 -- мономы, на которые они умножались.
 При этом 
\begin_inset Formula $l^{*}$
\end_inset

 соответствует части с большей сигнатурой: 
\begin_inset Formula $\poly(R[l])=\overline{u_{l}}\poly(R[l^{*}])-\underline{u_{l}}\poly(R[l_{*}])$
\end_inset

 и 
\begin_inset Formula $\Sig(R[l])=\overline{u_{l}}\Sig(R[l^{*}])\succ\underline{u_{l}}\Sig(R[l_{*}])$
\end_inset

.
 Значение 
\begin_inset Formula $\poly(R[l])$
\end_inset

 может меняться в процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 на многочлен с меньшим 
\begin_inset Formula $\HM$
\end_inset

, но 
\begin_inset Formula $\Sig(R[l])$
\end_inset

 никогда не меняется после добавления многочлена в последовательность.
 Далее, будем пытаться найти бесконечную подпоследовательность 
\begin_inset Formula $\left\{ R[k_{1}],R[k_{2}],\ldots,R[k_{n}],\ldots\right\} $
\end_inset

 в этой последовательности, обладающую свойством, что 
\begin_inset Formula $R[k_{n}]$
\end_inset

 является S-многочленом 
\begin_inset Formula $R[k_{n-1}]=R[k_{n}^{*}]$
\end_inset

 и некоторого другого многочлена меньшей сигнатуры.
 То есть 
\begin_inset Formula $\Sig(R[k_{n}])=\overline{u_{k_{n}}}\Sig(R[k_{n-1}])$
\end_inset

, откуда вытекает делимость: 
\begin_inset Formula 
\begin{equation}
\Sig(R[k_{n-1}])|\Sig(R[k_{n}]).\label{eq:s-pair-chain-def}
\end{equation}

\end_inset


\end_layout

\begin_layout Definition
Конечную или бесконечную последовательность отмеченных многочленов из 
\begin_inset Formula $H$
\end_inset

, соседние элементы которой удовлетворяют свойству 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:s-pair-chain-def"

\end_inset

, будем называть 
\emph on
цепью S-пар
\emph default
.
\end_layout

\begin_layout Standard
Каждый порождаемый многочлен 
\begin_inset Formula $R[l]$
\end_inset

 имеет конечную цепь S-пар, оканчивающуюся этим многочленом.
 Эта цепь может быть последовательно построена, начиная с последнего элемента
 
\begin_inset Formula $R[l]$
\end_inset

, если на каждом шаге переходить от текущего многочлена 
\begin_inset Formula $R[n]$
\end_inset

 к многочлену 
\begin_inset Formula $R[n^{*}]$
\end_inset

, который использовался при генерации 
\begin_inset Formula $R[n]$
\end_inset

 как S-многочлена.
 Результирующая цепь S-пар имеет вид 
\begin_inset Formula $\{R[q],\ldots,R[l^{**}],R[l^{*}],R[l]\}$
\end_inset

, где все многочлены имеют одинаковый индекс сигнатуры 
\begin_inset Formula $q=\sigidx(R[l])$
\end_inset

, и первый элемент является входным многочленом этого индекса.
\end_layout

\begin_layout Standard
Первое свойство цепей S-пар основано на критерии перезаписи и заключается
 в следующей теореме.
\end_layout

\begin_layout Theorem
Любой отмеченный многочлен может являться начальным элементом лишь конечного
 числа различных цепей S-пар длины 2.
\end_layout

\begin_layout Proof
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 считает S-многочлены в двух местах: процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Важно заметить, что в обоих случаях проверка 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 для части S-многочлена с большей сигнатурой выполняется непосредственно
 перед созданием S-многочлена.
 В первом случае такая проверка производится в самой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

, а в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 проверка присутствует в вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 И в обоих случаях, получаемый S-многочлен немедленно добавляется в список
 Rule первым элементом.
 Поэтому, в момент построения S-многочлена с сигнатурой 
\begin_inset Formula $s$
\end_inset

 можно утверждать, что старшая часть S-пары соответствует первому из правил
 с сигнатурой, делящей 
\begin_inset Formula $s$
\end_inset

 -- она даже может быть найдена, исходя лишь из списка Rule и сигнатуры
 
\begin_inset Formula $s$
\end_inset

 без знания какой-либо ещё информации об алгоритме.
\end_layout

\begin_layout Proof
Рассмотрим произвольный отмеченный многочлен 
\begin_inset Formula $R[L]$
\end_inset

 с сигнатурой 
\begin_inset Formula $\Sig(R[L])=s$
\end_inset

 и упорядоченное по порядку добавления подмножество 
\begin_inset Formula $\{R[l_{1}],\ldots,R[l_{i}],\ldots\}$
\end_inset

 отмеченных многочленов с сигнатурами удовлетворяющими условию 
\begin_inset Formula $\Sig(R[l_{i}])=v_{i}\Sig(R[L])$
\end_inset

.
 С точки зрения делимости, любая из потенциально бесконечного числа пар
 
\begin_inset Formula $\{R[L],R[l_{i}]\}$
\end_inset

 может быть цепью S-пар длины 2.
 Но идеал 
\begin_inset Formula $\left(v_{1},\ldots,v_{i},\ldots\right)$
\end_inset

 в 
\begin_inset Formula $\mathbb{T}$
\end_inset

 является конечно порождённым по лемме Диксона, поэтому, после некоторого
 шага 
\begin_inset Formula $i_{0}$
\end_inset

 будет выполняться 
\begin_inset Formula $\forall i>i_{0}\,\exists j\leqslant i_{0}$
\end_inset

 такое что 
\begin_inset Formula $v_{j}|v_{i}$
\end_inset

.
 Поэтому, при 
\begin_inset Formula $\forall i>i_{0}$
\end_inset

 последовательность 
\begin_inset Formula $\{R[L],R[l_{i}]\}$
\end_inset

 не может являться цепью S-пар, поскольку 
\begin_inset Formula $\Sig(R[L])\cdot v_{i}$
\end_inset

 перезаписывается 
\begin_inset Formula $\Sig(R[l_{j}])\cdot\frac{v_{i}}{v_{j}}$
\end_inset

 и существует не более чем 
\begin_inset Formula $i_{0}$
\end_inset

 цепей S-пар длины 2, начинающихся с многочлена 
\begin_inset Formula $R[L]$
\end_inset

.
\end_layout

\begin_layout Definition
Конечное множество концов цепей S-пар длины 2, начинающихся с 
\begin_inset Formula $R[L]$
\end_inset

, будет называться 
\emph on
множеством S-порождённых
\emph default
 
\begin_inset Formula $R[L]$
\end_inset

.
\end_layout

\begin_layout Theorem
Если алгоритм не останавливается на некоторых входных данных, то он порождает
 бесконечную цепь S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

.
\end_layout

\begin_layout Proof
Поскольку при работе с понятием бесконечности требуется некоторая строгость,
 дадим следующее определение.
\end_layout

\begin_deeper
\begin_layout Definition
Отмеченный многочлен 
\begin_inset Formula $R[l]$
\end_inset

 называется 
\emph on
генератором цепи S-пар
\emph default
, если существует бесконечное множество различных конечных цепей S-пар,
 начинающихся с 
\begin_inset Formula $R[l]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
Если алгоритм не останавливается, то многочлен входного множества 
\begin_inset Formula $R[m]=((1,m),f_{m})$
\end_inset

 является генератором цепи S-пар, поскольку каждый многочлен 
\begin_inset Formula $R[l]$
\end_inset

, порождаемый в последнем не завершающемся вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, имеет индекс сигнатуры 
\begin_inset Formula $m$
\end_inset

 и является концом цепи S-пар 
\begin_inset Formula $\{R[m],\ldots,R[l^{**}],R[l^{*}],R[l]\}$
\end_inset

.
\end_layout

\begin_layout Proof
Теперь предположим, что про некоторый отмеченный многочлен 
\begin_inset Formula $R[l]$
\end_inset

 известно, что он является генератором цепи S-пар.
 Один из конечного множества S-порождённых 
\begin_inset Formula $R[l]$
\end_inset

 также должен являться генератором цепи S-пар, поскольку в противном случае
 число различных цепей, исходящих из 
\begin_inset Formula $R[l]$
\end_inset

, было бы ограничено конечной суммой конечных количеств цепей, выходящих
 из S-порождённых, плюс конечным количеством цепей длины 2, выходящих из
 
\begin_inset Formula $R[l]$
\end_inset

.
 Поэтому, если отмеченный многочлен 
\begin_inset Formula $R[l]$
\end_inset

 является генератором цепи S-пар, среди его S-порождённых всегда может быть
 выбран другой генератор цепи S-пар.
 Таким образом, может быть построена бесконечная цепь S-пар, начинающаяся
 с 
\begin_inset Formula $R\left[m\right]$
\end_inset

, и состоящая из генераторов, что доказывает теорему.
\end_layout

\begin_layout Standard
Для следующей теоремы необходимо ввести порядок на частных, образованных
 мономами, путём транзитивного расширения порядка на мономах: 
\begin_inset Formula $\frac{m_{1}}{m_{2}}\succ_{q}\frac{m_{3}}{m_{4}}\Leftrightarrow m_{1}m_{4}\succ m_{3}m_{2}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:f_g_3_props"

\end_inset

Если алгоритм не останавливается на некоторых входных данных, то после некоторог
о конечного шага множество 
\begin_inset Formula $G$
\end_inset

 содержит индексы пары отмеченных многочленов 
\begin_inset Formula $f',f$
\end_inset

, причём 
\begin_inset Formula $f$
\end_inset

 сгенерирован после 
\begin_inset Formula $f'$
\end_inset

 и выполняются следующие 3 свойства:
\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\HM(f')|\HM(f),
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\frac{\HM(f')}{\Sig(f')}\succ_{q}\frac{\HM(f)}{\Sig(f)},
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Formula 
\[
\Sig(f')|\Sig(f).
\]

\end_inset


\end_layout

\begin_layout Proof
При работе с цепями S-пар является важным тот факт, что многочлен никогда
 не редуцируется дальше, после того как он был использован для создания
 S-пары в качестве старшей по сигнатуре части.
 Факт выполняется, поскольку, индексы всех многочлены, которые ещё могут
 быть подвергнуты редукции находятся в множестве ToDo, а индексы многочленов,
 используемых как старшая часть S-пары, находятся в 
\begin_inset Formula $G$
\end_inset

 или в Done.
 Поэтому, многочлен 
\begin_inset Formula $h_{n}$
\end_inset

, предшествующий многочлену 
\begin_inset Formula $h_{n+1}$
\end_inset

 в цепи S-пар, сохраняет одно и то же значение 
\begin_inset Formula $\poly(h_{n})$
\end_inset

 после того как был использован для создания какой-либо S-пары.
 И можно утверждать, что выполняется равенство 
\begin_inset Formula 
\[
\poly(h_{n+1})=c\frac{\Sig(h_{n+1})}{\Sig(h_{n})}\poly(h_{n})+g_{n},
\]

\end_inset

где 
\begin_inset Formula $g_{n}$
\end_inset

 -- многочлен, соответствующей младшей части S-пары, использованный при
 генерации 
\begin_inset Formula $h_{n+1}$
\end_inset

 из 
\begin_inset Formula $h_{n}$
\end_inset

, удовлетворяющее следующему:
\begin_inset Formula 
\begin{equation}
\begin{array}{ccccc}
\HM(h_{n+1}) & \prec & \HM\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right) & = & \HM(g_{n}),\\
\Sig(h_{n+1}) & = & \Sig\left(\frac{\Sig(h_{n+1})}{\Sig(h_{n})}h_{n}\right) & \succ & \Sig(g_{n}).
\end{array}\label{eq:spair-chain}
\end{equation}

\end_inset

Из первого неравенства в 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:spair-chain"

\end_inset

 получаем, что 
\begin_inset Formula $\frac{\HM(h_{n})}{\Sig(h_{n})}\succ_{q}\frac{\HM(h_{n+1})}{\Sig(h_{n+1})}$
\end_inset

, поэтому в цепи S-пар частные 
\begin_inset Formula $\frac{\HM(h_{i})}{\Sig(h_{i})}$
\end_inset

 строго убывают в смысле порядка на частных.
 Этот факт не может быть напрямую использован для доказательства конечности
 цепей, поскольку порядок на частных, в отличии от порядка на мономах, не
 даёт вполне упорядоченности: к примеру, последовательность 
\begin_inset Formula $\frac{x}{x}\succ_{q}\frac{x}{x^{2}}\succ_{q}\cdots\succ_{q}\frac{x}{x^{n}}>_{q}\cdots$
\end_inset

 является бесконечно убывающей.
\end_layout

\begin_layout Proof
Существует две возможности для отношения между 
\begin_inset Formula $\HM$
\end_inset

 соседних элементов.
 Известно что 
\begin_inset Formula $\Sig(h_{n})|\Sig(h_{n+1})$
\end_inset

, поэтому они или имеют равные сигнатуры или 
\begin_inset Formula $\totaldeg(h_{n})<\totaldeg(h_{n+1})$
\end_inset

.
 В первом случае 
\begin_inset Formula $\HM(h_{n+1})\prec\HM(h_{n})$
\end_inset

 при равенстве полной степени, а во втором -- 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(h_{n+1})\succ\HM(h_{n})$
\end_inset

, поскольку полные степени 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\HM$
\end_inset

 отличаются
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
 Поэтому, последовательность
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\HM$
\end_inset

 элементов бесконечной цепи S-пар состоит из блоков с фиксированной полной
 степенью, где 
\begin_inset Formula $\HM$
\end_inset

 внутри блока строго убывают.
 Длины блоков могут быть равными единице, и полные степени блоков возрастают.
 Это приводит к следующим свойствам: цепь S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

 не может содержать элементов с равными 
\begin_inset Formula $\HM$
\end_inset

 и 
\begin_inset Formula $\HM(h_{i})|\HM(h_{j})$
\end_inset

 возможно только в случае 
\begin_inset Formula $i<j$
\end_inset

 и 
\begin_inset Formula $\totaldeg(h_{i})<\totaldeg(h_{j})$
\end_inset

.
\end_layout

\begin_layout Proof
Это позволяет использовать метод, аналогичный используемому в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

 (Предложение 14): рассмотрим 
\begin_inset Formula $\HM$
\end_inset

 бесконечной цепи S-пар 
\begin_inset Formula $\{h_{i}\}$
\end_inset

.
 Они порождают бесконечную последовательность в 
\begin_inset Formula $\mathbb{T}$
\end_inset

, поэтому по лемме Диксона существует два многочлена, с 
\begin_inset Formula $\HM(h_{i})|\HM(h_{j})$
\end_inset

.
 Из предыдущего абзаца следует, что при этом 
\begin_inset Formula $i<j$
\end_inset

, а при помощи свойств цепи S-пар мы получаем, что 
\begin_inset Formula $\Sig(h_{i})|\Sig(h_{i+1})|\cdots|\Sig(h_{j})$
\end_inset

 и 
\begin_inset Formula $\frac{\HM(h_{i})}{\Sig(h_{i})}\succ_{q}\frac{\HM(h_{i+1})}{\Sig(h_{i+1})}\succ_{q}\cdots\succ_{q}\frac{\HM(h_{j})}{\Sig(h_{j})}$
\end_inset

, поэтому можно взять 
\begin_inset Formula $f'=h_{i}$
\end_inset

 и 
\begin_inset Formula $f=h_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
Последнее свойство о делимости сигнатур из утверждения теоремы является
 побочным эффектом от использования цепей S-пар и не используется в дальнейшем.
 При этом, первые два свойства используются для построения сигнатурного
 редуктора.
\end_layout

\begin_layout Fact
Если никакие многочлены не были отброшены проверками критериев 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

, рассматриваемый алгоритм завершается.
\end_layout

\begin_layout Proof
Данное выше доказательство теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 не опирается на соответствие между порядком 
\begin_inset Formula $\succ_{P}$
\end_inset

 на сигнатурах и порядком 
\begin_inset Formula $\succ$
\end_inset

 на мономах многочленов.
 Но алгоритм F5 использует один и тот же порядок в обоих случаях, и теперь
 мы можем воспользоваться этим фактом и переформулировать отношение на частных
 мономов из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 в отношение на сигнатурах: 
\begin_inset Formula 
\[
\Sig(f)\succ_{P}t\cdot\Sig(f'),\mbox{ где }t=\frac{\HM(f)}{\HM(f')}\in\mathbb{T}.
\]

\end_inset

Это неравенство вместе с делимостью 
\begin_inset Formula $\HM$
\end_inset

, из утверждения теоремы, показывает, что 
\begin_inset Formula $tf'$
\end_inset

 является редуктором для 
\begin_inset Formula $f$
\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 с точки зрения сигнатуры он проходит проверки 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-a"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 и его сигнатура меньше.
 При отсутствии проверки критериев 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

, это напрямую приводило бы к противоречию, так как в момент добавления
 
\begin_inset Formula $f$
\end_inset

 в 
\begin_inset Formula $G$
\end_inset

 отмеченный многочлен 
\begin_inset Formula $f'$
\end_inset

 уже был там, и процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 должна была бы редуцировать 
\begin_inset Formula $f$
\end_inset

 по 
\begin_inset Formula $f'$
\end_inset

.
\end_layout

\begin_layout Standard
Но существование критериев делает возможной ситуацию, в которой 
\begin_inset Formula $tf'$
\end_inset

 отбрасывается проверками 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

 процедуры 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Идея дальнейших рассуждений состоит в том, чтобы показать что в этом случае
 может быть найден другой сигнатурный редуктор 
\begin_inset Formula $f$
\end_inset

, который не будет отброшен проверками и таким образом прийти к противоречию.
 Последующие главы работы посвящены этому.
\end_layout

\begin_layout Subsubsection
S-пары с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset


\end_layout

\begin_layout Standard
В этом и последующих разделах доказательства остановки 
\begin_inset Formula $g$
\end_inset

 подразумевается некоторым фиксированным отмеченным многочленом с индексом
 сигнатуры 
\begin_inset Formula $m$
\end_inset

, позиция которого в 
\begin_inset Formula $R$
\end_inset

 добавлена на некоторой итерации алгоритма в Done.
 Мы будем анализировать состояние алгоритма в момент, непосредственно предшеству
ющий добавлению 
\begin_inset Formula $g$
\end_inset

 в Done в вызове 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 с 
\begin_inset Formula $i=m$
\end_inset

.
 Рассмотрим в этот момент конечное множество 
\begin_inset Formula $G_{m}\cup$
\end_inset

Done.
 Оно состоит из чисел, являющихся позициями отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, поэтому его элементы могут быть упорядочены в соответствии с позицией
 в 
\begin_inset Formula $R$
\end_inset

, и оно окажется записанным в виде упорядоченной последовательности целых
 чисел 
\begin_inset Formula $G_{g}=\{b_{1},\ldots,b_{N}\}$
\end_inset

 с 
\begin_inset Formula $b_{j}<b_{j+1}$
\end_inset

.
 Необходимо отметить, что этот порядок является обратным по отношению к
 порядку отмеченных многочленов в последовательности, получаемой склеиванием
 массивов правил 
\begin_inset Formula $\mbox{Rule}[m]:\mbox{Rule}[m-1]:\cdots:\mbox{Rule}[1]$
\end_inset

, поскольку добавление нового многочлена в 
\begin_inset Formula $R$
\end_inset

 всегда сопровождается добавлением соответствующего правила.
 Но этот порядок может отличаться от порядка, в котором многочлены добавлялись
 в множество 
\begin_inset Formula $G_{m}\cup$
\end_inset

Done, поскольку, многочлены одной полной степени добавляются в Done в порядке
 возрастания сигнатуры, при том что добавление многочленов одной полной
 степени в 
\begin_inset Formula $R$
\end_inset

 производится в довольно случайном порядке в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 Далее для простоты мы будем говорить о отмеченных многочленах 
\begin_inset Formula $b_{j}$
\end_inset

 в 
\begin_inset Formula $G_{g}$
\end_inset

, подразумевая что 
\begin_inset Formula $G_{g}$
\end_inset

 является не упорядоченным списком позиций, а упорядоченным списком отмеченных
 многочленов, расположенных на этих позициях.
 В этой терминологии можно сказать, что все входные многочлены 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 присутствуют в 
\begin_inset Formula $G_{g}$
\end_inset

, поскольку они присутствуют в 
\begin_inset Formula $G_{m}$
\end_inset

 в момент его создания.
\end_layout

\begin_layout Standard
S-пары могут обрабатываться в алгоритме различным путями, но главный факт,
 описывающий порядок их обработки, выражается следующими свойствами, соответству
ющими свойствам, использованным в Теореме 21 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

, но рассматриваемыми на произвольной итерации алгоритма, а не после его
 остановки.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exist-gg-repr"

\end_inset

К моменту добавления 
\begin_inset Formula $g$
\end_inset

 в Done каждая S-пара элементов 
\begin_inset Formula $G_{g}$
\end_inset

, сигнатура которой меньше 
\begin_inset Formula $\Sig(g)$
\end_inset

, удовлетворяет одному из трёх свойств:
\end_layout

\begin_layout Enumerate
S-пара имеет часть, которая была отброшена критерием проверки нормальной
 формы 
\begin_inset Formula $\varphi$
\end_inset

 (в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 или в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

).
 Такие S-пары будут называться 
\emph on
S-парами с частью, удовлетворяющей критерию F5
\emph default
.
 
\end_layout

\begin_layout Enumerate
S-пара имеет часть, которая была отброшена проверкой 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 (в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 или в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

).
 Такие S-пары будут называться 
\emph on
S-парами с частью, удовлетворяющей критерию Перезаписи
\emph default
.
\end_layout

\begin_layout Enumerate
S-пара не была отброшена, поэтому её S-многочлен был сигнатурно редуцирован
 по некоторым элементам 
\begin_inset Formula $G_{g}$
\end_inset

, и результат был добавлен как элемент 
\begin_inset Formula $G_{g}$
\end_inset

.
 Такие S-пары будут называться 
\emph on
S-парами с известным 
\begin_inset Formula $G_{g}$
\end_inset

-представлением
\emph default
.
\end_layout

\begin_layout Proof
S-пары элементов 
\begin_inset Formula $G_{g}$
\end_inset

 обрабатываются в алгоритме двумя основными путями.
 Основной путь используется для S-пар, полная степень которых больше, чем
 полная степень породивших их многочленов.
 Такие S-пары обрабатываются в следующем порядке:
\end_layout

\begin_deeper
\begin_layout Itemize
в процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 они рассматриваются функцией 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 при перемещении элементов 
\begin_inset Formula $G_{i}$
\end_inset

 из 
\begin_inset Formula $R_{d}=Done$
\end_inset

 и при обработке входного многочлена 
\begin_inset Formula $f_{i}$
\end_inset


\end_layout

\begin_layout Itemize
функция 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 или отбрасывает пару после проверки нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 или добавляет пару в 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Itemize
S-пара извлекается из 
\begin_inset Formula $P$
\end_inset

 и передаётся в функцию 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset


\end_layout

\begin_layout Itemize
функция 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 или отбрасывает пару после проверки 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 или добавляет S-многочлен в 
\begin_inset Formula $F_{d}=ToDo$
\end_inset


\end_layout

\begin_layout Itemize
на некоторой итерации процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 берёт S-многочлен из ToDo, производит некоторые сигнатурные редукции и
 добавляет результат в Done.
\end_layout

\end_deeper
\begin_layout Proof
Второй путь обработки используется для S-пар, соответствующих редукциям,
 запрещённым алгоритмом -- эти S-пары порождаются многочленами 
\begin_inset Formula $R[l^{*}]$
\end_inset

 и 
\begin_inset Formula $R[l_{*}]$
\end_inset

, такими что 
\begin_inset Formula $\HM(R[l^{*}])|\HM(R[l_{*}])$
\end_inset

, и S-многочлен им соответствующий имеет вид 
\begin_inset Formula $\overline{u_{l}}\cdot\poly(R[l^{*}])-1\cdot\poly(R[l_{*}])$
\end_inset

.
 Такая ситуация возможна, если для элементов 
\begin_inset Formula $G_{g}$
\end_inset

 редукция 
\begin_inset Formula $R[l_{*}]$
\end_inset

 по 
\begin_inset Formula $R[l^{*}]$
\end_inset

 была запрещена сравнением сигнатур в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 или проверками в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 Для этого случая порядок 
\begin_inset Quotes fld
\end_inset

обработки
\begin_inset Quotes frd
\end_inset

 S-пары такой:
\end_layout

\begin_deeper
\begin_layout Itemize
часть S-пары 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset

 проверяется в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-a"

\end_inset

 выполнено, поскольку 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(R[l^{*}])|\HM(R[l_{*}])$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 Она может быть отброшена другими проверками:
\end_layout

\begin_deeper
\begin_layout Itemize
отбрасывание пунктом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-b"

\end_inset

 соответствует проверке нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 для 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset


\end_layout

\begin_layout Itemize
отбрасывание пунктом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

 соответствует проверке 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 для 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset


\end_layout

\begin_layout Itemize
отбрасывание пунктом 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-d"

\end_inset

 означает, что один из многочленов 
\begin_inset Formula $\overline{u_{l}}\cdot R[l^{*}]$
\end_inset

 и 
\begin_inset Formula $1\cdot R[l_{*}]$
\end_inset

 может быть перезаписан другим, поэтому, если S-пара не была отброшена проверкой
 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:IsRed-c"

\end_inset

, данный тип отбрасывания означает, что часть S-пары 
\begin_inset Formula $1\cdot R[l_{*}]$
\end_inset

 не проходит проверку 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
S-пары, не отброшенные в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 возвращаются в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Сравнение сигнатур в 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 запрещает редукцию 
\begin_inset Formula $R[l_{*}]$
\end_inset

 по 
\begin_inset Formula $R[l^{*}]$
\end_inset

 и помещает вычисленный S-многочлен, соответствующий S-паре, в множество
 ToDo
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 добавляет этот многочлен в ToDo
\end_layout

\begin_layout Itemize
последний шаг совпадает для обоих путей обработки S-пар: на некоторой итерации
 процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 берёт S-многочлен из ToDo, производит некоторые сигнатурные редукции и
 добавляет результат в Done.
\end_layout

\end_deeper
\begin_layout Proof
Из путей обработки S-пар видно, что после окончания обработки каждая S-пара
 или редуцирована и добавлена в Done, или одна из частей S-пары была отброшена
 проверкой нормальной формы 
\begin_inset Formula $\varphi$
\end_inset

 или критерием 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

.
 Некоторые S-пары могут оказываться на путях обработки несколько раз, к
 примеру это происходит на итерации 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 со значением 
\begin_inset Formula $d$
\end_inset

, не изменившимся с прошлой итерации.
 Если S-пара была отброшена при первой попытке обработки, то она будет точно
 также отброшена и на следующей попытке.
 Если первая обработка добавила редуцированный многочлен в Done, то пара
 будет отбрасываться при следующих попытках обработки проверкой
\family typewriter
 
\family default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Rewritten?"

\end_inset

 за счёт этого многочлена.
 Поэтому все попытки обработки, кроме первой, не дают ничего нового.
\end_layout

\begin_layout Proof
Путь обработки не является одной процедурой, и в случае, если алгоритм не
 останавливается, некоторые S-пары всегда находятся в середине обработки,
 при этом или соответствующая S-пара находится в очереди 
\begin_inset Formula $P$
\end_inset

 или S-многочлен в очереди ToDo.
 Поэтому необходимо понять обработка каких S-пар уже завершилась в рассматриваем
ый нами момент.
 Элементы 
\begin_inset Formula $P$
\end_inset

 и ToDo извлекаются в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 в порядке возрастания сигнатур.
 S-пары с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset

, могут быть разделены на 3 класса:
\end_layout

\begin_deeper
\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)<\sigidx(\Sig(g))=m$
\end_inset

.
 Они обрабатывались на предыдущих вызовах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

.
\end_layout

\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)=\sigidx(\Sig(g))=m,\totaldeg(w)<\totaldeg(\Sig(g))$
\end_inset

.
 Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, который обрабатывает 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Itemize
S-пары с сигнатурой 
\begin_inset Formula $w$
\end_inset

, такой что 
\begin_inset Formula $\sigidx(w)=\sigidx(\Sig(g))=m,\totaldeg(w)=\totaldeg(\Sig(g)),w\prec\Sig(g)$
\end_inset

.
 Они обрабатывались на предыдущих итерациях цикла внутри того же вызова
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

, который обрабатывает 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
S-пары из этих классов не могут находиться в середине пути обработки, потому
 что в рассматриваемом состоянии алгоритма обработка только что завершена
 для 
\begin_inset Formula $g$
\end_inset

, поэтому ни 
\begin_inset Formula $P$
\end_inset

, ни ToDo не содержат необработанных элементов с сигнатурами, меньшими 
\begin_inset Formula $\Sig(g)$
\end_inset

.
 Осталось показать, что для всех S-пар из утверждения теоремы, обработка
 начиналась хотя бы один раз.
 Это просто проверить для первых двух классов: обработка соответствующих
 S-пар была начата по крайней мере один раз путём вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:AlgorithmF5"

\end_inset

, непосредственно перед тем, как наибольший из порождающих S-пару был добавлен
 в 
\begin_inset Formula $G$
\end_inset

.
 Для S-пар третьего класса ситуация зависит от полной степени её порождающих.
 Если оба порождающих S-пару многочлена имеют полную степень 
\begin_inset Formula $<\totaldeg(g)$
\end_inset

, то её обработка была начата в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:CritPair"

\end_inset

 аналогично S-парам первых двух классов.
 Но некоторые S-пары третьего класса могут иметь старший по сигнатуре порождающи
й 
\begin_inset Formula $R[l]$
\end_inset

, такой что 
\begin_inset Formula $\totaldeg(R[l])=\totaldeg(g),\,\Sig(R[l])\prec\Sig(g)$
\end_inset

.
 Они обрабатываются вторым из рассмотренных путей обработки S-пар, поэтому
 обработка таких S-пар ещё не стартовала к моменту последнего вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

.
 Однако, их обработка начинается внутри 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Reduction"

\end_inset

 до изучаемого нами момента: процедура выбирает многочлены из ToDo в порядке
 возрастания сигнатуры, поэтому 
\begin_inset Formula $R[l]$
\end_inset

 редуцируется перед 
\begin_inset Formula $g$
\end_inset

, и в процессе редукции 
\begin_inset Formula $R[l]$
\end_inset

, непосредственно перед добавлением 
\begin_inset Formula $R[l]$
\end_inset

 в Done, вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

 начинает обработку всех таких S-пар.
\end_layout

\begin_layout Standard
Понятия 
\emph on
удовлетворять критерию F5 
\emph default
и 
\emph on
удовлетворять критерию Перезаписи
\emph default
 могут быть расширены на произвольные, умноженные на моном отмеченные многочлены
 
\begin_inset Formula $sh,\, h\in G_{g}$
\end_inset

:
\end_layout

\begin_layout Definition
Умноженный на моном отмеченный многочлен 
\begin_inset Formula $sR\left[i\right],\, R\left[i\right]\in G_{g}$
\end_inset

 называется 
\emph on
удовлетворяющим критерию F5
\emph default
, если 
\begin_inset Formula $\varphi(s\Sig(R\left[i\right]))\ne s\Sig(R\left[i\right])$
\end_inset

, где 
\begin_inset Formula $\varphi$
\end_inset

 -- оператор нормальной формы по отношению к 
\begin_inset Formula $G_{index(R\left[i\right])-1}$
\end_inset

.
\end_layout

\begin_layout Standard
Это определение эквивалентно тому, что 
\begin_inset Formula $sR\left[i\right]$
\end_inset

 является ненормализованным отмеченным многочленом с точки зрения определения
 2 в части 5 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

.
\end_layout

\begin_layout Definition
Умноженный на моном отмеченный многочлен 
\begin_inset Formula $sR\left[i\right],\, R\left[i\right]\in G_{g}$
\end_inset

 называется 
\emph on
удовлетворяющим критерию Перезаписи
\emph default
, если 
\begin_inset Formula $\exists j>i$
\end_inset

 такое что 
\begin_inset Formula $\Sig(R\left[j\right])|s\Sig(R\left[i\right])$
\end_inset

.
\end_layout

\begin_layout Standard
В случае, если 
\begin_inset Formula $sR\left[i\right]$
\end_inset

 является частью S-пары, эти определения эквиваленты проверкам, производимым
 в алгоритме, в том смысле, что часть S-пары отбрасывается алгоритмом тогда
 и только тогда, когда она удовлетворяет данному определению как умноженный
 на моном отмеченный многочлен.
 Для обоих критериев выполняется важное свойство, утверждающее, что если
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $sR\left[i\right]$
\end_inset

 удовлетворяет критерию, то и дополнительно домноженный многочлен 
\begin_inset Formula $s_{1}sR\left[i\right]$
\end_inset

 также ему удовлетворяет.
\end_layout

\begin_layout Subsubsection
Представления
\end_layout

\begin_layout Standard
Для описания способов, которыми многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан как элемент идеала 
\begin_inset Formula $\left(G_{g}\right)$
\end_inset

, мы будем использовать сигнатурные представления над 
\begin_inset Formula $G_{g}$
\end_inset

, называемые также сигнатурными 
\begin_inset Formula $G_{g}$
\end_inset

-представлениями.
\end_layout

\begin_layout Paragraph
Примеры
\end_layout

\begin_layout Example
Первый важный пример 
\begin_inset Formula $G_{g}$
\end_inset

-представления тривиален: отмеченный многочлен из 
\begin_inset Formula $G_{g}$
\end_inset

 равен сумме одного слагаемого -- самого себя с единичным коэффициентом:
 
\begin_inset Formula 
\[
b_{j}=1\cdot b_{j}.
\]

\end_inset


\end_layout

\begin_layout Standard
Это 
\begin_inset Formula $G_{g}$
\end_inset

-представление сигнатурно.
 Запрет на наличие в представлении нескольких элементов, имеющих одинаковый
 моном 
\begin_inset Formula $t_{k}$
\end_inset

 и многочлен 
\begin_inset Formula $b_{i_{k}}$
\end_inset

 гарантирует, что все элементы представления, отличающиеся только коэффициентом,
 скомбинированы вместе путём суммирования коэффициентов в поле 
\begin_inset Formula $\mathcal{K}$
\end_inset

.
 Поэтому выражения вида 
\begin_inset Formula $b_{j}=-1\cdot b_{j}+2\cdot b_{j}$
\end_inset

 и 
\begin_inset Formula $b_{j}=2x\cdot b_{k}+1\cdot b_{j}-2x\cdot b_{k}$
\end_inset

 не являются корректными 
\begin_inset Formula $G_{g}$
\end_inset

-представлениями.
\end_layout

\begin_layout Example
Отмеченный многочлен 
\begin_inset Formula $b_{j}\in G_{g}$
\end_inset

, домноженный на произвольный многочлен 
\begin_inset Formula $h$
\end_inset

, также имеет простое 
\begin_inset Formula $G_{g}$
\end_inset

-представление, получающееся из записи 
\begin_inset Formula $h$
\end_inset

 в виде суммы термов: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $h=\sum_{k}m_{k},\, m_{k}\in\mathcal{K}\times\mathbb{T}$
\end_inset

.
 Это 
\begin_inset Formula $G_{g}$
\end_inset

-представление имеет форму 
\begin_inset Formula 
\begin{equation}
b_{j}h=\sum_{k}m_{k}\cdot b_{j}\label{eq:repr-ex-2}
\end{equation}

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
и также является сигнатурным.
\end_layout

\begin_layout Standard
Отмеченный многочлен может иметь бесконечное множество различных представлений:
 к любому представлению можно добавить элементы, соответствующие сизигии,
 сгруппировать элементы с одновременно равными мономами и многочленами и
 получить другое корректное представление.
 Это будет представление того же многочлена, поскольку сумма многочленов,
 соответствующих элементам сизигии равна 0.
\end_layout

\begin_layout Example
Произведение двух многочленов из 
\begin_inset Formula $G_{g}$
\end_inset

 имеет 2 представления вида 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:repr-ex-2"

\end_inset

, которые отличаются прибавлением сизигии:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
 & b_{j}b_{i}=\sum_{k}m_{i_{k}}\cdot b_{j}=\sum_{k}m_{i_{k}}\cdot b_{j}+0=\\
 & =\sum_{k}m_{i_{k}}\cdot b_{j}+\left(\sum_{k}m_{j_{k}}\cdot b_{i}-\sum_{k}m_{i_{k}}\cdot b_{j}\right)=\sum_{k}m_{j_{k}}\cdot b_{i},
\end{eqnarray*}

\end_inset

где 
\begin_inset Formula $m_{i_{k}}$
\end_inset

 -- термы 
\begin_inset Formula $b_{i}$
\end_inset

, а 
\begin_inset Formula $m_{j_{k}}$
\end_inset

 -- термы 
\begin_inset Formula $b_{j}$
\end_inset

.
\end_layout

\begin_layout Example
Нулевой многочлен имеет пустое представление и представление, соответствующее
 каждой сизигии:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
0=\sum_{\varnothing}\mbox{(пустая сумма)}=\sum_{k}m_{j_{k}}\cdot b_{i}+\sum_{k}(-m_{i_{k}})\cdot b_{j},
\]

\end_inset

где 
\begin_inset Formula $m_{i_{k}}$
\end_inset

 и 
\begin_inset Formula $m_{j_{k}}$
\end_inset

 взяты из предыдущего примера.
 Все непустые представления нулевого многочлена не сигнатурны.
\end_layout

\begin_layout Standard
Другой важный пример 
\begin_inset Formula $G_{g}$
\end_inset

-представлений получается из определений сигнатуры и идеала.
 Все отмеченные многочлены, вычисляемые алгоритмом, принадлежат идеалу 
\begin_inset Formula $\left(f_{1},\ldots,f_{m}\right)$
\end_inset

.
 Поэтому любой отмеченный многочлен 
\begin_inset Formula $p$
\end_inset

 может быть записан в виде 
\begin_inset Formula $\sum_{i}f_{i}g_{i}$
\end_inset

, где 
\begin_inset Formula $g_{i}$
\end_inset

 -- однородные многочлены.
 Все входные многочлены 
\begin_inset Formula $f_{i}$
\end_inset

 принадлежат 
\begin_inset Formula $G_{g}$
\end_inset

, поэтому 
\begin_inset Formula $f_{i}g_{i}$
\end_inset

 имеют 
\begin_inset Formula $G_{g}$
\end_inset

-представления вида 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:repr-ex-2"

\end_inset

.
\end_layout

\begin_layout Example
Сумма этих представлений даёт следующее сигнатурное представление: 
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot b_{i_{k}},\, m_{k}\in\mathcal{K}\times\mathbb{T},\, b_{i_{k}}\in\left\{ f_{1},\ldots,f_{m}\right\} \subset G_{g}.
\]

\end_inset


\end_layout

\begin_layout Definition
Частный случай 
\begin_inset Formula $G_{g}$
\end_inset

-представления, при котором 
\begin_inset Formula $b_{i_{k}}$
\end_inset

 ограничены лишь входными многочленами, будет называться 
\emph on
входным представлением
\emph default
.
\end_layout

\begin_layout Standard
Входные представления всегда имеют единственный элемент максимальной сигнатуры.
 Произвольные 
\begin_inset Formula $G_{g}$
\end_inset

-представления не всегда обладают этим свойством, поскольку могут иметь
 несколько разных элементов с одинаковой максимальной сигнатурой, так как
 для них возможна ситуация 
\begin_inset Formula $m_{1}\Sig(b_{i_{1}})=m_{2}\Sig(b_{i_{2}})$
\end_inset

 при 
\begin_inset Formula $i_{1}\ne i_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее утверждение устанавливает связь между входными представлениями
 и понятием сигнатуры:
\end_layout

\begin_layout Claim
Отмеченный многочлен 
\begin_inset Formula $p$
\end_inset

 с известной сигнатурой 
\begin_inset Formula $\Sig(p)$
\end_inset

 имеет входное представление, состоящее из элемента 
\begin_inset Formula $c\Sig(p)\cdot f_{index(p)}$
\end_inset

 и некоторых других элементов с меньшими сигнатурами.
\end_layout

\begin_layout Proof
Утверждение вытекает из условия корректности в определении отмеченного многочлен
а.
\end_layout

\begin_layout Standard
Теорема 1 из 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

 утверждает, что все многочлены, порождаемые алгоритмом, допустимы, а определени
е допустимости ссылается на функцию 
\begin_inset Formula $v$
\end_inset

, которая соответствует суммированию элементов входного представления --
 поэтому, в силу этой теоремы, все элементы 
\begin_inset Formula $R$
\end_inset

 удовлетворяют условию корректности допустимых многочленов, и мы будем применять
 предыдущее утверждение ко всем таким многочленам.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example-of-having-gg-repr"

\end_inset

Последний пример восходит к S-парам с известным 
\begin_inset Formula $G_{g}$
\end_inset

-представлением.
 S-многочлен, порождённый 
\begin_inset Formula $b_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $b_{l_{*}}$
\end_inset

 из 
\begin_inset Formula $G_{g}$
\end_inset

, имеет вид 
\begin_inset Formula $p=\overline{u_{l}}\poly(b_{l^{*}})-\underline{u_{l}}\poly(b_{l_{*}})$
\end_inset

.
 Из процесса редукции вытекает, что 
\begin_inset Formula $p$
\end_inset

 сигнатурно редуцируется, и результат добавляется в 
\begin_inset Formula $G_{g}$
\end_inset

 как некоторый отмеченный многочлен 
\begin_inset Formula $b_{l}$
\end_inset

.
 Отсюда его 
\begin_inset Formula $G_{g}$
\end_inset

-представление имеет вид:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p=\sum_{k}m_{k}\cdot b_{n_{k}}+1\cdot b_{l},
\]

\end_inset

где сигнатуры элементов 
\begin_inset Formula $m_{k}\cdot b_{n_{k}}$
\end_inset

 меньше чем 
\begin_inset Formula $\Sig(b_{l})=\Sig(p)$
\end_inset

.
 Значение 
\begin_inset Formula $l$
\end_inset

 -- позиция 
\begin_inset Formula $b_{l}$
\end_inset

 в упорядоченном списке 
\begin_inset Formula $G_{g}$
\end_inset

.
 В данном представлении 
\begin_inset Formula $l$
\end_inset

 больше чем 
\begin_inset Formula $l^{*}$
\end_inset

 и 
\begin_inset Formula $l_{*}$
\end_inset

, поскольку соответствующий отмеченный многочлен 
\begin_inset Formula $b_{l}$
\end_inset

 был добавлен в 
\begin_inset Formula $R$
\end_inset

 в момент подсчёта S-многочлена в процедурах 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:Spol"

\end_inset

 или 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

, поэтому многочлены 
\begin_inset Formula $b_{l^{*}}$
\end_inset

 и 
\begin_inset Formula $b_{l_{*}}$
\end_inset

, использованные для создания не отброшенной S-пары, уже присутствовали
 в 
\begin_inset Formula $R$
\end_inset

 к тому моменту, а порядок 
\begin_inset Formula $G_{g}$
\end_inset

 соответствует порядку добавления элементов в 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Paragraph
Порядок на представлениях
\end_layout

\begin_layout Definition
Для введения порядка на 
\begin_inset Formula $G_{g}$
\end_inset

-представлениях, мы начнём с 
\emph on
порядка на элементах представления
\emph default
 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

: будем говорить, что 
\begin_inset Formula $c_{i}t_{i}\cdot b_{i}\gtrdot_{1}c_{j}t_{j}\cdot b_{j}$
\end_inset

 если выполняется один из следующих случаев:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $t_{i}\Sig(b_{i})\succ_{P}t_{j}\Sig(b_{j})$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
\end_inset

 и 
\begin_inset Formula $i<j$
\end_inset

 (сравнение позиций -- в обратную сторону).
\end_layout

\end_deeper
\begin_layout Standard
Этот порядок основан лишь на сравнение сигнатур и позиций отмеченных многочленов
 в упорядоченном списке 
\begin_inset Formula $G_{g}$
\end_inset

, но не зависит от коэффициента из поля.
 Единственный случай, в котором два элемента не могут быть упорядочены --
 одновременное равенство сигнатур 
\begin_inset Formula $t_{i}\Sig(b_{i})=t_{j}\Sig(b_{j})$
\end_inset

 и позиций в списке 
\begin_inset Formula $i=j$
\end_inset

.
 Равенство позиций означает равенство многочленов 
\begin_inset Formula $b_{i}=b_{j}$
\end_inset

, что вместе с равенством сигнатур даёт 
\begin_inset Formula $t_{i}=t_{j}$
\end_inset

.
 Поэтому любые два элемента, принадлежащие одному корректному 
\begin_inset Formula $G_{g}$
\end_inset

 представлению являются сравнимыми с точки зрения порядка 
\begin_inset Formula $\lessdot_{1}$
\end_inset

, поскольку они имеют различные 
\begin_inset Formula $\left(t_{k},b_{k}\right)$
\end_inset

 по определению.
 Ниже приведены некоторые примеры сравнений элементов по 
\begin_inset Formula $\lessdot_{1}$
\end_inset

 для списка 
\begin_inset Formula $G_{g}=\left\{ b_{1},\, b_{2},\, b_{3}\right\} $
\end_inset

 из 3-х элементов с порядком на сигнатурах 
\begin_inset Formula $x\mathbf{F}_{i}\succ y\mathbf{F}_{i}$
\end_inset

 и сигнатурами 
\begin_inset Formula $\Sig(b_{1})=\mathbf{F}_{1},\Sig(b_{2})=\mathbf{F}_{2},\Sig(b_{3})=x\mathbf{F}_{1}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $y\cdot b_{1}\gtrdot_{1}100y\cdot b_{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части  
\begin_inset Formula $\succ_{P}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $x\cdot b_{1}\gtrdot_{1}y\cdot b_{1}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части 
\begin_inset Formula $\succ_{P}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $-x\cdot b_{1}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
и
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $2x\cdot b_{1}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 не сравнимы, поскольку сигнатуры и позиции в списке равны
\end_layout

\begin_layout Itemize
\begin_inset Formula $y^{2}\cdot b_{1}\lessdot_{1}y\cdot b_{3}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поскольку сигнатура левой части
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\prec_{P}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot_{1}x\cdot b_{3}$
\end_inset

 поскольку сигнатуры равны, а позиция в списке отмеченного многочлена левой
 части равна 1, что меньше чем позиция многочлена правой части, равная 3.
\end_layout

\begin_layout Standard
Для расширения этого порядка на 
\begin_inset Formula $G_{g}$
\end_inset

-представления целиком будем рассматривать 
\emph on
упорядоченную форму
\emph default
 представления, состоящую из всех его элементов, записанных в 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-убывающий список.
 Эта форма может быть использована для проверки на равенство, поскольку
 представления равны тогда и только тогда, когда равны их упорядоченные
 формы.
\end_layout

\begin_layout Definition
При помощи упорядоченных форм введём 
\emph on
порядок на 
\begin_inset Formula $G_{g}$
\end_inset

-представлениях
\emph default
: представление 
\begin_inset Formula $\sum_{k}m'_{k}\cdot b_{i'_{k}}$
\end_inset

 является 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем 
\begin_inset Formula $\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

, если упорядоченные формы для первого и второго представления удовлетворяют
 лексикографически расширенному на формы отношению 
\begin_inset Formula $\lessdot_{1}$
\end_inset

.
 Для особого случая, когда упорядоченные формы отличаются лишь длиной, более
 короткая форма будет называться 
\begin_inset Formula $\lessdot$
\end_inset

-меньшей.
 Если наибольшие различные элементы в упорядоченных формах двух представлений
 отличаются лишь коэффициентов поля, то представления являются не сравнимыми.
\end_layout

\begin_layout Standard
Далее даны некоторые примеры этого порядка для того же трёх-элементного
 списка 
\begin_inset Formula $G_{g}$
\end_inset

.
 Все 
\begin_inset Formula $G_{g}$
\end_inset

-представления записаны в упорядоченных формах:
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}+xy\cdot b_{1}+y^{2}b_{1}\gtrdot x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}$
\end_inset

 поскольку 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $xy\cdot b_{1}\gtrdot_{1}y^{2}\cdot b_{1}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}+100y^{2}\cdot b_{1}\gtrdot x^{2}\cdot b_{1}$
\end_inset

 поскольку правая часть является началом левой
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 поскольку 
\begin_inset Formula $x^{2}\cdot b_{1}\gtrdot_{1}xy\cdot b_{1}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $xy\cdot b_{1}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}\gtrdot y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 поскольку 
\begin_inset Formula $xy\cdot b_{1}\gtrdot_{1}y\cdot b_{3}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $y\cdot b_{3}+y^{2}\cdot b_{1}+x^{2}\cdot b_{2}$
\end_inset

 и 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $2y\cdot b_{3}+y^{2}\cdot b_{2}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 не сравнимы, поскольку наибольшие различные элементы -- это 
\begin_inset Formula $y\cdot b_{3}$
\end_inset

 и 
\begin_inset Formula $2y\cdot b_{3}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Standard
Порядок на представлениях совместим с понятием сигнатурности представления:
\end_layout

\begin_layout Theorem
Если для пары представлений отмеченного многочлена 
\begin_inset Formula $p$
\end_inset

 выполняется отношение 
\begin_inset Formula $\sum_{k}m'_{k}\cdot b_{i'_{k}}\lessdot\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

, и правое представление сигнатурно, то и левое представление сигнатурно.
\end_layout

\begin_layout Proof
Теорема легко следует из того, что сигнатуры элементов 
\begin_inset Formula $\lessdot$
\end_inset

-меньшего представления не могут быть 
\begin_inset Formula $\succ_{P}$
\end_inset

-больше, чем максимальная сигнатура 
\begin_inset Formula $\gtrdot$
\end_inset

-большего представления.
\end_layout

\begin_layout Standard
Важным фактом, позволяющим брать 
\begin_inset Formula $\lessdot$
\end_inset

-минимальный элемент, является вполне упорядоченность:
\end_layout

\begin_layout Theorem
Представления вполне упорядочены порядком 
\begin_inset Formula $\lessdot$
\end_inset

.
\end_layout

\begin_layout Proof
Количество различных отмеченных многочленов, входящих в элементы представления,
 конечно, поскольку оно равно 
\begin_inset Formula $|G_{g}|$
\end_inset

 для некоторого фиксированного 
\begin_inset Formula $g$
\end_inset

.
 Поэтому существование бесконечной 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-убывающей последовательности элементов представлений привело бы к существованию
 бесконечной 
\begin_inset Formula $\succ_{P}$
\end_inset

-убывающей последовательности сигнатур.
 Учитывая вполне упорядоченность сигнатур по 
\begin_inset Formula $\prec_{P}$
\end_inset

, мы получаем доказательство вполне упорядоченности элементов представлений
 по 
\begin_inset Formula $\lessdot{}_{1}$
\end_inset

.
\end_layout

\begin_layout Proof
Прямое доказательство вполне упорядоченности представлений по 
\begin_inset Formula $\lessdot$
\end_inset

 на основе вполне упорядоченности их элементов по 
\begin_inset Formula $\lessdot_{1}$
\end_inset

 не является очень сложным, однако, дабы не вдаваться в детали, используем
 теорему 2.5.5 книги 
\begin_inset CommandInset citation
LatexCommand cite
key "Baader.Nipkow98Term"

\end_inset

.
 Она утверждает вполне упорядоченность конечных наборов с порядком, являющимся
 лексикографическим расширением порядка на элементах набора.
 Это применимо к представлениям, так как они являются наборами своих элементов.
\end_layout

\begin_layout Paragraph
Последовательность представлений
\end_layout

\begin_layout Standard
Идея этой части состоит в построении конечной последовательности строго
 
\begin_inset Formula $\lessdot$
\end_inset

-убывающих сигнатурных 
\begin_inset Formula $G_{g}$
\end_inset

-представлений для некоторого отмеченного многочлена 
\begin_inset Formula $mh,\, m\in\mathcal{K}\times\mathbb{T},\, h\in G_{g}$
\end_inset

 со свойством 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

.
 Первым сигнатурным представлением в последовательности является 
\begin_inset Formula $mh=m\cdot h$
\end_inset

, а последнее представление имеет вид 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 со свойствами, выполняющимися для 
\begin_inset Formula $\forall k$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m_{k}b_{i_{k}}$
\end_inset

 не удовлетворяет критерию F5.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m_{k}b_{i_{k}}$
\end_inset

 не удовлетворяет критерию Перезаписи.
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\HM(m_{k}b_{i_{k}})\leqslant\HM(mh)$
\end_inset


\end_layout

\begin_layout Standard
Доказательство существования такой последовательности довольно похоже на
 доказательство Теоремы 21 из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 и основано на том, что если некоторое сигнатурное представление 
\begin_inset Formula $mh$
\end_inset

 содержит не удовлетворяющий одному из свойств элемент 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

, то может быть найдено 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее представление.
 Метод построения отличается для разных свойств, однако схема замены одинакова:
\end_layout

\begin_layout Itemize
выбирается некоторый элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 в представлении 
\begin_inset Formula $mh$
\end_inset

.
 Следует отметить, что 
\begin_inset Formula $K'$
\end_inset

 может как совпадать, так и отличаться от 
\begin_inset Formula $K$
\end_inset


\end_layout

\begin_layout Itemize
строится некоторое представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 для этого элемента
\end_layout

\begin_layout Itemize
показывается что построенное представление 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\end_layout

\begin_layout Standard
Построение такого представления для 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 позволяет применить следующую лемму:
\end_layout

\begin_layout Lemma
Если элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 сигнатурного представления 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 имеет представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

, 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

, то 
\begin_inset Formula $mh$
\end_inset

 имеет сигнатурное представление, 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
\end_layout

\begin_layout Proof
Заменим элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 в представлении 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 на 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 и скомбинируем коэффициенты при элементах с одновременно одинаковыми мономами
 и многочленами, получив, таким образом, изменённое представления для 
\begin_inset Formula $mh$
\end_inset

.
 Оно будет 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 поскольку: все элементы 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-большие 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 идентичны в исходном и изменённом представлениях; элемент 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 содержится в исходном, но не в изменённом представлении; все остальные
 элементы в представлениях являются 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-меньшими, чем 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 поэтому они не играют роли при сравнении.
 Сравнение выполняется даже в случае, когда при комбинировании коэффициентов
 все элементы обнулились.
 Этот случай может возникнуть, если исходное представление было равно 
\begin_inset Formula $mh=m_{K'}\cdot b_{i_{K'}}+\sum_{l}(-m_{l})\cdot b_{i_{l}}$
\end_inset

, что привело к изменённому представлению, вообще не содержащему элементов:
 
\begin_inset Formula $mh=0$
\end_inset

.
 Оно является 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем любое непустое представление.
\end_layout

\begin_layout Standard
Теперь покажем, что представление элемента по вышеуказанной схеме может
 быть построено, если исходное представление содержит элемент, не удовлетворяющи
й по крайней мере одному из свойств.
\end_layout

\begin_layout Lemma
Если сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 содержит элемент, не удовлетворяющий свойству 1, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

, обладающий 
\begin_inset Formula $G_{g}$
\end_inset

-представлением 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

.
\end_layout

\begin_layout Standard
Элемент, не обладающий первым свойством, удовлетворяет критерию F5, что
 позволяет использовать соображение о том, что 
\begin_inset Formula $m_{K}\Sig(b_{i_{K}})$
\end_inset

 не является его сигнатурой 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 аналогично теореме 20 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

.
 Для этого случая берётся 
\begin_inset Formula $K'=K$
\end_inset

.
\end_layout

\begin_layout Proof
Рассмотрим входное представление 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 с сигнатурой 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимального элемента, равной 
\begin_inset Formula $m_{K}\Sig(b_{i_{K}})=(s_{0},j_{0})\in\mathbf{T}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{equation}
m_{K}b_{i_{K}}=c_{0}s_{0}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.\label{eq:input-repr-case1}
\end{equation}

\end_inset

Из удовлетворения критерия F5 следует, что 
\begin_inset Formula $s_{0}$
\end_inset

 может быть представлено как 
\begin_inset Formula $s_{0}=s_{1}\HM(f_{j_{1}}),\, j_{1}<j_{0}$
\end_inset

, откуда 
\begin_inset Formula $s_{0}f_{j_{0}}=s_{1}f_{j_{0}}f_{j_{1}}-s_{1}(f_{j_{1}}-\HM(f_{j_{1}}))f_{j_{0}}$
\end_inset

.
 На основе этого выражения можно получить другое представление для 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

, обозначая за 
\begin_inset Formula $m_{0i}$
\end_inset

 упорядоченные термы 
\begin_inset Formula $f_{j_{0}}$
\end_inset

, за 
\begin_inset Formula $m_{1i}$
\end_inset

 -- упорядоченные термы 
\begin_inset Formula $f_{j_{1}}$
\end_inset

, и за 
\begin_inset Formula $N_{0,}N_{1}$
\end_inset

 число термов в этих многочленах:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
m_{K}b_{i_{K}}=\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}+\sum_{i=2}^{N_{1}}-c_{0}s_{1}m_{1i}\cdot f_{j_{0}}+\sum_{l}m_{l}\cdot f_{i_{l}}.
\]

\end_inset

Это представление 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

 поскольку сигнатуры всех его элементов меньше чем 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(s_{0},j_{0})$
\end_inset

.
 Для элементов третьей суммы 
\begin_inset Formula $\sum_{l}m_{l}\cdot f_{i_{l}}$
\end_inset

 это следует из 
\family default
\series bold
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, где эти элементы являются меньшими элементами входного представления.
 Для элементов первой суммы 
\begin_inset Formula $\sum_{i=1}^{N_{0}}c_{0}s_{1}m_{0i}\cdot f_{j_{1}}$
\end_inset

 это следует из неравенства индексов сигнатур 
\begin_inset Formula $j_{1}<j_{0}$
\end_inset

.
 А для второй суммы используем совпадение порядка на сигнатурах и на термах:
 все термы 
\begin_inset Formula $m_{1i},\, i\geqslant2$
\end_inset

 меньше, чем 
\begin_inset Formula $m_{11}$
\end_inset

, поэтому и выполняется неравенство для сигнатур: 
\begin_inset Formula $s_{1}(m_{1i},j_{0})\prec_{P}s_{1}(m_{11},j_{0})=(s_{0},j_{0})$
\end_inset

.
 
\end_layout

\begin_layout Lemma
Если сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 содержит элемент, не удовлетворяющий свойству 2, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

, обладающий 
\begin_inset Formula $G_{g}$
\end_inset

-представлением 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшим, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Standard
Для элементов, не удовлетворяющих критерию Перезаписи 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее представление строится методом, аналогичным из 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C"

\end_inset

 (Предложение 17).
 В этом случае также берётся 
\begin_inset Formula $K'=K$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим, что сигнатура 
\begin_inset Formula $\Sig(m_{K}b_{i_{K}})=(s_{0},j_{0})$
\end_inset

,
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 и она перезаписывается отмеченным многочленом 
\begin_inset Formula $b_{i'}$
\end_inset

 из 
\begin_inset Formula $R$
\end_inset

.
 Поскольку, представление сигнатурно, мы имеем 
\begin_inset Formula $\Sig(b_{i'})\preccurlyeq_{P}(s_{0},j_{0})\preccurlyeq_{P}\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

.
 Поэтому 
\begin_inset Formula $b_{i'}$
\end_inset

 обрабатывался в процедуре 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 раньше 
\begin_inset Formula $g$
\end_inset

.
 Значит 
\begin_inset Formula $b_{i'}$
\end_inset

 был редуцирован и результат его редукции или был нулевым или присутствует
 в 
\begin_inset Formula $G_{g}$
\end_inset

, поэтому, он может использоваться как многочлен элемента 
\begin_inset Formula $G_{g}$
\end_inset

-представления.
 Из критерия Перезаписи известно, что 
\begin_inset Formula $i'>i_{K}$
\end_inset

 и существует 
\begin_inset Formula $s'\in\mathbb{T}$
\end_inset

, такое что 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $s'\Sig(b_{i'})=(s_{0},j_{0})$
\end_inset

.
 Для 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 есть входное представление 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset

, а для 
\begin_inset Formula $s'b_{i'}$
\end_inset

 входным представлением является:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
s'b_{i'}=c's_{0}\cdot f_{j_{0}}+\sum_{l'}m_{l'}\cdot f_{i_{l'}}.
\]

\end_inset

Преобразованием этого выражения получим 
\begin_inset Formula $G_{g}$
\end_inset

-представление для 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{0}s_{0}f_{j_{0}}$
\end_inset

:
\end_layout

\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\[
c_{0}s_{0}f_{j_{0}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}.
\]

\end_inset

Используя его для замены первого элемента в 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:input-repr-case1"

\end_inset

 получим желаемый результат:
\begin_inset Formula 
\[
m_{K}b_{i_{K}}=c'^{-1}c_{0}s'\cdot b_{i'}+\sum_{l'}-c'^{-1}c_{0}m_{l'}\cdot f_{i_{l'}}+\sum_{l}m_{l}\cdot f_{i_{l}}
\]

\end_inset

Он 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}b_{i_{K}}=m_{K}\cdot b_{i_{K}}$
\end_inset

 поскольку, элементы обоих сумм имеют сигнатуры, меньшие 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(s_{0},j_{0})$
\end_inset

, а для первого элемента, если 
\begin_inset Formula $b_{i'}$
\end_inset

 не нулевой, имеем 
\begin_inset Formula $\Sig(c'^{-1}c_{0}s'\cdot b_{i'})=\Sig(m_{K}\cdot b_{i_{K}})=(s_{0},j_{0})$
\end_inset

 с 
\begin_inset Formula $i'>i_{K}$
\end_inset

, откуда, применяя правило 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-сравнения для равных сигнатур и различных позиций в списке, получаем, что
 элемент 
\begin_inset Formula $c'^{-1}c_{0}s'\cdot b_{i'}$
\end_inset

 также 
\begin_inset Formula $\lessdot_{1}$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

.
 Если же 
\begin_inset Formula $b_{i'}=0$
\end_inset

, то он отбрасывается, и желаемое представление состоит только из оставшихся
 2-х сумм.
\end_layout

\begin_layout Lemma
Если все элементы сигнатурного представления 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 удовлетворяют свойствам 1 и 2, но один из них не удовлетворяет свойству
 3, то найдётся элемент 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

, имеющий представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем представление 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

.
\end_layout

\begin_layout Proof
Существует по крайней мере один элемент 
\begin_inset Formula $m_{K}\cdot b_{i_{K}}$
\end_inset

, не удовлетворяющий свойству 3.
 Обозначим за 
\begin_inset Formula $m_{\max}$
\end_inset

 максимальный 
\begin_inset Formula $\HM$
\end_inset

 отмеченных многочленов, соответствующих элементам представления, и за 
\begin_inset Formula $H_{\max}$
\end_inset

 список элементов, на котором 
\begin_inset Formula $m_{\max}$
\end_inset

 достигается.
 Возьмём в качестве 
\begin_inset Formula $K'$
\end_inset

 номер элемента представления, являющегося 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимальным в 
\begin_inset Formula $H_{\max}$
\end_inset

.
 Имеем 
\begin_inset Formula $\HM(m_{K'}b_{i_{K'}})=m_{\max}\succcurlyeq\HM(m_{K}b_{i_{K}})\succ\HM(mh)$
\end_inset

, поэтому 
\begin_inset Formula $\HM$
\end_inset

 суммы всех элементов, кроме 
\begin_inset Formula $K'$
\end_inset

-го равен 
\begin_inset Formula $\HM(mh-m_{K'}b_{i_{K'}})=\HM(m_{K'}b_{i_{K'}})=m_{\max}$
\end_inset

, поэтому существует другой элемент 
\begin_inset Formula $K''$
\end_inset

, обладающий 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(m_{K''}b_{i_{K''}})=m_{\max}$
\end_inset

.
 Отсюда 
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}\in H_{\max}$
\end_inset

 и 
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}\lessdot_{1}m_{K'}\cdot b_{i_{K'}}$
\end_inset

 поскольку 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\begin_inset Formula $\gtrdot_{1}$
\end_inset

-максимален в 
\begin_inset Formula $H_{\max}$
\end_inset

.
\end_layout

\begin_layout Proof
Равенство 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\HM(m_{K''}b_{i_{K''}})=\HM(m_{K'}b_{i_{K'}})$
\end_inset

 означает, что S-пара 
\begin_inset Formula $b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $b_{i_{K''}}$
\end_inset

 имеет вид 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $[m'^{-1}m_{\max},\, m'^{-1}m_{K'},\, b_{i_{K'}},\, m'^{-1}m_{K''},\, b_{i_{K''}}]$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 где 
\begin_inset Formula $m'=\mbox{gcd}(m_{K'},m_{K''})$
\end_inset

.
 Пусть 
\begin_inset Formula $q$
\end_inset

 -- соответствующий S-многочлен.
 Тогда 
\begin_inset Formula $m'\Sig(q)\preccurlyeq_{P}\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 поскольку 
\begin_inset Formula $m'\Sig(q)=\Sig(m_{K'}b_{i_{K'}})$
\end_inset

 и представление сигнатурно.
 Части S-многочлена 
\begin_inset Formula $m'^{-1}m_{K'}b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $m'^{-1}m_{K''}b_{i_{K''}}$
\end_inset

 не удовлетворяют критериям F5 и Перезаписи, поскольку они же, умноженные
 на 
\begin_inset Formula $m'$
\end_inset

, равны 
\begin_inset Formula $m_{K'}b_{i_{K'}}$
\end_inset

 и 
\begin_inset Formula $m_{K''}b_{i_{K''}}$
\end_inset

 -- отмеченным многочленам, соответствующим элементам, про которые известно,
 что они не удовлетворяют критериям по предположению леммы.
 Из 
\begin_inset Formula $m'\Sig(q)\prec\Sig(g)$
\end_inset

 имеем 
\begin_inset Formula $\Sig(q)\prec\Sig(g)$
\end_inset

, а значит можно применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-gg-repr"

\end_inset

 и получить, что 
\begin_inset Formula $(b_{i_{K'}},b_{i_{K''}})$
\end_inset

 -- S-пара с 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
известным
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $G_{g}$
\end_inset

-представлением, что означает существование представления, описанного в
 примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example-of-having-gg-repr"

\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
q=1\cdot b_{i'}+\sum_{l}m_{l}\cdot b_{i_{l}},
\]

\end_inset

причём выполняются свойства, показанные после примера: 
\begin_inset Formula $\Sig(q)=\Sig(b_{i'})$
\end_inset

, 
\begin_inset Formula $\forall l\,\Sig(q)\succ_{P}\Sig(m_{l}b_{i_{l}})$
\end_inset

 и 
\begin_inset Formula $i'>K'$
\end_inset

.
\end_layout

\begin_layout Proof
С другой стороны, по определению S-многочлена мы имеем 
\begin_inset Formula $m'q=c_{0}m_{K'}b_{i_{K'}}-c_{1}m_{K''}b_{i_{K''}}$
\end_inset

, откуда получаем следующее представление:
\begin_inset Formula 
\[
m_{K'}b_{i_{K'}}=c_{0}^{-1}c_{1}m_{K''}\cdot b_{i_{K''}}+c_{0}^{-1}m'\cdot b_{i'}+\sum_{l}c_{0}^{-1}m'm_{l}\cdot b_{i_{l}}.
\]

\end_inset

Оно 
\begin_inset Formula $\lessdot$
\end_inset

-меньше, чем 
\begin_inset Formula $m_{K'}b_{i_{K'}}=m_{K'}\cdot b_{i_{K'}}$
\end_inset

: 
\end_layout

\begin_layout Proof
\begin_inset Formula $m_{K''}\cdot b_{i_{K''}}$
\end_inset

 уже сравнивалось с 
\begin_inset Formula $m_{K'}\cdot b_{i_{K'}}$
\end_inset

 
\end_layout

\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $m'\cdot b_{i'}$
\end_inset

 имеет ту же сигнатуру, но больший номер позиции 
\begin_inset Formula $i'>i_{K'}$
\end_inset


\end_layout

\begin_layout Proof
последняя сумма состоит из элементов с сигнатурами, меньшими чем 
\begin_inset Formula $m'\Sig(b_{i'})=\Sig(m_{K'}\cdot b_{i_{K'}})$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-smaller-signature-safe-representation"

\end_inset

Или сигнатурное представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 удовлетворяет свойствам 1-3, или существует другое сигнатурное представление
 
\begin_inset Formula $mh=\sum_{l}m_{l}\cdot b_{i_{l}}$
\end_inset

 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее, чем 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
\end_layout

\begin_layout Proof
Теорема немедленно следует из комбинации четырёх предыдущих лемм.
\end_layout

\begin_layout Standard
Это привод нас к следующему ключевому результату:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Exists-Gg-repr"

\end_inset

Для любого отмеченного многочлена 
\begin_inset Formula $mh,\, m\in\mathcal{K}\times\mathbb{T},\, h\in G_{g}$
\end_inset

 с 
\begin_inset Formula $\Sig(mh)\prec_{P}\Sig(g)$
\end_inset

 существует удовлетворяющее свойствам 1-3 сигнатурное 
\begin_inset Formula $G_{g}$
\end_inset

-представление 
\begin_inset Formula $mh=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
.
\end_layout

\begin_layout Proof
Начнём с представления 
\begin_inset Formula $mh=m\cdot h$
\end_inset

 и будем заменять текущее представление на 
\begin_inset Formula $\lessdot$
\end_inset

-меньшее из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-smaller-signature-safe-representation"

\end_inset

 до тех пор, пока текущее представление не будет удовлетворять свойствам
 1-3.
 Конечность процесса гарантируется вполне упорядоченностью представлений
 по 
\begin_inset Formula $\lessdot$
\end_inset

.
\end_layout

\begin_layout Standard
Этот результат представляет интерес сам по себе, однако для целей доказательства
 остановки нужно лишь одно следствие из него:
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "cor:all-needed-for-terminaton"

\end_inset

Рассмотрим произвольный многочлен 
\begin_inset Formula $f$
\end_inset

 без ограничений на его сигнатуру.
 Если существует сигнатурный редуктор 
\begin_inset Formula $f'\in G_{g}$
\end_inset

 для 
\begin_inset Formula $f$
\end_inset

 с 
\begin_inset Formula $\Sig(f')\frac{\HM(f)}{\HM(f')}\prec_{P}\Sig(g)$
\end_inset

 то 
\begin_inset Formula $G_{g}$
\end_inset

 содержит сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

, который не отбрасывается критериями F5 и перезаписи.
\end_layout

\begin_layout Proof
Пусть 
\begin_inset Formula $mf',\, m=\frac{\HM(f)}{\HM(f')}\in\mathcal{K}\times\mathbb{T},\, f'\in G_{g}$
\end_inset

 умноженный редуктор с 
\begin_inset Formula $\Sig(mf')\prec_{P}\Sig(g)$
\end_inset

.
 Из предыдущей теоремы мы можем найти удовлетворяющее свойствам 1-3 представлени
е 
\begin_inset Formula $mf'=\sum_{k}m_{k}\cdot b_{i_{k}}$
\end_inset

.
 Свойство 3 означает отсутствие элементов с 
\begin_inset Formula $\HM$
\end_inset

, большим чем у 
\begin_inset Formula $mf'$
\end_inset

, откуда, поскольку сумма всех элементов этого представления имеет 
\begin_inset Formula $\HM$
\end_inset

 равный 
\begin_inset Formula $\HM(mf')$
\end_inset

, существует элемент 
\begin_inset Formula $K$
\end_inset

, на котором достигается равенство 
\begin_inset Formula $\HM$
\end_inset

: 
\begin_inset Formula $\HM(m_{K}\cdot b_{i_{K}})=\HM(mf')=\HM(f)$
\end_inset

.
 Поскольку представление сигнатурно, имеем 
\begin_inset Formula $\Sig(m_{K}\cdot b_{i_{K}})\preccurlyeq_{P}\Sig(mf')\prec_{P}\Sig(f)$
\end_inset

, а значит 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 и выполнение свойств 1-2 гарантирует, что 
\begin_inset Formula $m_{K}b_{i_{K}}$
\end_inset

 не отбрасывается критериями.
\end_layout

\begin_layout Subsubsection
Обнаружение противоречия с учётом критериев
\end_layout

\begin_layout Standard
Теперь мы можем вернуться к результату теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

, утверждающей, что в случае, если алгоритм не останавливается, существуют
 многочлены 
\begin_inset Formula $f',f$
\end_inset

, с индексами в 
\begin_inset Formula $G_{m}$
\end_inset

 такие что 
\begin_inset Formula $\HM(f')|\HM(f)$
\end_inset

, 
\begin_inset Formula $\frac{\HM(f')}{\Sig(f')}\succ_{q}\frac{\HM(f)}{\Sig(f)}$
\end_inset

.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Используя этот результат и последнее следствие, мы построим два многочлена,
 приводящие к противоречию в случае отсутствия остановки алгоритма
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:always-exist-ok-reductor"

\end_inset

Если алгоритм не останавливается на некоторых входных данных, то найдётся
 шаг, после которого конечное множество 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G_{m}\cup$
\end_inset

Done
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 содержит пару отмеченных многочленов 
\begin_inset Formula $f'_{1},f$
\end_inset

, для которых выполняется:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $f'_{1}$
\end_inset

 было добавлено в 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G_{m}\cup$
\end_inset

Done
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 до 
\begin_inset Formula $f$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{1}f'_{1}$
\end_inset

 не удовлетворяет критериям F5 и Перезаписи, где 
\begin_inset Formula $t_{1}=\frac{\HM(f)}{\HM(f'_{1})}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $f'_{1}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Пусть 
\begin_inset Formula $f',f$
\end_inset

 -- многочлены из теоремы
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:f_g_3_props"

\end_inset

 и
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $t=\frac{\HM(f)}{\HM(f')}$
\end_inset

.
 Индекс многочлена 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $f$
\end_inset

 лежит в 
\begin_inset Formula $G$
\end_inset

, поэтому, построенная выше теория о представлениях может быть рассмотрена
 применительно к случаю 
\begin_inset Formula $g$
\end_inset

 равного 
\begin_inset Formula $f$
\end_inset

, и можно говорить о множестве 
\begin_inset Formula $G_{f}$
\end_inset

 и 
\begin_inset Formula $G_{f}$
\end_inset

-представлениях.
 Поскольку,
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $tf'$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 -- мы имеем 
\begin_inset Formula $\Sig(f')t\prec\Sig(f)$
\end_inset

, и следствие 
\begin_inset CommandInset ref
LatexCommand ref
reference "cor:all-needed-for-terminaton"

\end_inset

 может быть применено для нахождения сигнатурного редуктора 
\begin_inset Formula $t_{1}f'_{1}$
\end_inset

 для 
\begin_inset Formula $f$
\end_inset

, который не удовлетворяет критериям.
 Помимо этого известно, что он принадлежит 
\begin_inset Formula $G_{f}$
\end_inset

, поэтому выполняется и первое свойство: в процессе работы алгоритма 
\begin_inset Formula $f'_{1}$
\end_inset

 был добавлен в 
\begin_inset Formula $G_{m}\cup$
\end_inset

Done раньше 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Theorem
Алгоритм F5, описанный в 
\begin_inset CommandInset citation
LatexCommand cite
key "FaugereF5"

\end_inset

, останавливается на любых входных данных.
\end_layout

\begin_layout Proof
Покажем, что существование многочленов 
\begin_inset Formula $f'_{1},f$
\end_inset

 из теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 приводит к противоречию.
 Рассмотрим вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

, после которого многочлен 
\begin_inset Formula $f$
\end_inset

 был добавлен в Done.
 Этот вызов вернул многочлен 
\begin_inset Formula $f$
\end_inset

 как первую половину значения, возвращаемого 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:TopReduction"

\end_inset

, что означает, что предшествующий вызов 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 вернул пустое множество.
 Это значит, что для каждого многочлена в 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $G_{m}\cup$
\end_inset

Done, в том числе
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $f'_{1}$
\end_inset

, хотя бы одно из условий 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-a"

\end_inset

 - 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-d"

\end_inset

 не выполнилось.
 Это невозможно, поскольку:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-a"

\end_inset

удовлетворяется, так как 
\begin_inset Formula $f'_{1}$
\end_inset

 -- редуктор для 
\begin_inset Formula $f$
\end_inset

 по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-b"

\end_inset

и 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-c"

\end_inset

 удовлетворяются, поскольку 
\begin_inset Formula $\frac{\HM(f)}{\HM(f'_{1})}f'_{1}$
\end_inset

 не удовлетворяет критериям F5 и Перезаписи по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:IsRed-d"

\end_inset

удовлетворяется, поскольку 
\begin_inset Formula $f'_{1}$
\end_inset

 -- сигнатурный редуктор для 
\begin_inset Formula $f$
\end_inset

 по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:always-exist-ok-reductor"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
Упрощение F5
\end_layout

\begin_layout Standard
Приведённая исходная формулировка алгоритма F5 сильно разнесена по процедурам,
 что приводит к довольно сложному порядку обработки S-пар, описанному в
 доказательстве остановки.
 Для построения более простого аналога будем действовать следующим образом:
 сформулируем некоторые свойства, которыми обладает алгоритм F5, и попытаемся
 построить наиболее простой алгоритм, обладающий этими же свойствами.
 Такой подход не позволяет сделать заключение ни о корректности построенного
 алгоритма, ни об его эквивалентности F5, поэтому его корректность будет
 доказана отдельно.
\end_layout

\begin_layout Standard
Определим, какими свойствами должна обладать старшая часть S-пары, чтоб
 быть рассмотренной в алгоритме.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:high-sp-part"

\end_inset

Если 
\begin_inset Formula $\sigma$
\end_inset

 -- сигнатура старшей части некоторой S-пары, она не отбрасывается в F5
 тогда и только тогда, когда не удовлетворяет критерию F5 и образована многочлен
ом максимальным по индексу в 
\begin_inset Formula $R$
\end_inset

 из множества многочленов с 
\begin_inset Formula $\Sig(R[r])|\sigma$
\end_inset

, взятого на момент обработки S-многочлена сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
Проверки в процедурах 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:CritPair"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Spol"

\end_inset

 приводят к тому что рассматриваются S-пары, со старшей частью, не отбрасываемой
 критериями F5 и перезаписи.
 Если S-пара отбрасывается критерием F5, то все S-пары будут им отбрасываться,
 поскольку известно, что многочлен такой сигнатуры имеет сигнатурное представлен
ие, в котором все элементы имеют меньшую сигнатуру, и поэтому редуцируется
 к нулю относительно текущего множества 
\begin_inset Formula $G\cup$
\end_inset

Done.
 Если же часть S-пары 
\begin_inset Formula $u\cdot R[r]$
\end_inset

 отбрасывается критерием перезаписи, то существует элемент 
\begin_inset Formula $r'>r,\Sig(R[r'])|u\Sig(R[r])$
\end_inset

.
 То есть по сигнатуре 
\begin_inset Formula $\sigma$
\end_inset

 и множеству 
\begin_inset Formula $R$
\end_inset

 на момент обработки S-многочлена сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

, можно определить единственно возможную не перезаписываемую часть S-пары
 сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

, что доказывает утверждение.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:low-sp-part"

\end_inset

Если старшая часть 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

 некоторой S-пары, появляющейся в алгоритме F5, не отбрасывается, то будет
 редуцирована ровно одна S-пара с такой старшей частью, при этом младшая
 часть будет образована многочленом 
\begin_inset Formula $R[r_{3}]$
\end_inset

 из множества 
\begin_inset Formula $R$
\end_inset

 на момент обработки S-многочлена сигнатуры 
\begin_inset Formula $\Sig\left(u_{1}\cdot R[r_{1}]\right)$
\end_inset

, таким что 
\begin_inset Formula $\Sig(u_{3}\cdot R[r_{3}])\preccurlyeq_{P}\Sig(u_{*}\cdot R[r_{*}])$
\end_inset

 для всех 
\begin_inset Formula $u_{*},r_{*}$
\end_inset

, удовлетворяющих 
\begin_inset Formula $\HM(u_{*}\cdot R[r_{*}])=\HM(u_{1}\cdot R[r_{1}])$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим что в алгоритме обрабатываются две пары с различными младшими
 частями 
\begin_inset Formula $(u_{1}\cdot R[r_{1}],u'_{2}\cdot R[r'_{2}])$
\end_inset

 и 
\begin_inset Formula $(u_{1}\cdot R[r_{1}],u''_{2}\cdot R[r''_{2}])$
\end_inset

.
 Тогда S-пара 
\begin_inset Formula $R[r'_{2}]$
\end_inset

 и 
\begin_inset Formula $R[r''_{2}]$
\end_inset

 имеет вид 
\begin_inset Formula $(\frac{u'_{2}}{v}\cdot R[r'_{2}],\frac{u''_{2}}{v}\cdot R[r''_{2}])$
\end_inset

.
 Она уже была рассмотрена и отброшена или редуцирована.
 Если она была отброшена критериями, то они же отбросят 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 или 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

.
 Если она была редуцирована, то результат редукции будет иметь сигнатуру,
 перезаписывающую 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 или 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

.
 В обоих случаях одна из младших частей будет отброшена, что показывает
 единственность не отбрасываемой S-пары со старшей частью 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

.
\end_layout

\begin_layout Proof
Для доказательства существования рассмотрим обрабатываемую в алгоритме S-пару
 с сокращаемым мономом 
\begin_inset Formula $t$
\end_inset

, младшей частью 
\begin_inset Formula $u_{2}\cdot R[r_{2}]$
\end_inset

 и не отброшенной старшей частью 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

.
 Поскольку сигнатура 
\begin_inset Formula $u_{2}\cdot R[r_{2}]$
\end_inset

 меньше текущей обрабатываемой, к 
\begin_inset Formula $u_{2}\cdot R[r_{2}]$
\end_inset

 можно применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exists-Gg-repr"

\end_inset

, и выбрать из этого представления по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset

 элемент 
\begin_inset Formula $u_{3}\cdot R[r_{3}]$
\end_inset

 с 
\begin_inset Formula $\Sig(u_{3}\cdot R[r_{3}])\preccurlyeq_{P}\Sig(u_{2}\cdot R[r_{2}])$
\end_inset

 и 
\begin_inset Formula $\HM(u_{3}\cdot R[r_{3}])=\HM(u_{2}\cdot R[r_{2}])$
\end_inset

, проходящий критерии.
 При этом может оказаться, что 
\begin_inset Formula $r_{3}=r_{2}.$
\end_inset


\end_layout

\begin_layout Proof
Сокращаемый моном 
\begin_inset Formula $t'$
\end_inset

 S-пары многочленов 
\begin_inset Formula $R[r_{1}]$
\end_inset

 и 
\begin_inset Formula $R[r_{3}]$
\end_inset

 делит 
\begin_inset Formula $t$
\end_inset

.
 Предположим, что он имеет меньшую полную степень -- в этом случае соответствующ
ая S-пара была бы уже рассмотрена.
 Она не была бы отброшена, поскольку дополнительно домноженные на 
\begin_inset Formula $\frac{t}{t'}$
\end_inset

 её части имеют вид 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

 и 
\begin_inset Formula $u_{3}\cdot R[r_{3}]$
\end_inset

 проходят критерии.
 В силу этого она была бы редуцирована, дав в результате многочлен сигнатуры
 делящей 
\begin_inset Formula $\Sig\left(u_{1}\cdot R[r_{1}]\right)$
\end_inset

, который привёл бы к отбрасыванию 
\begin_inset Formula $u_{1}\cdot R[r_{1}]$
\end_inset

 по критерию перезаписи, что невозможно.
 Поэтому 
\begin_inset Formula $t'=t$
\end_inset

, что доказывает существование не отбрасываемой алгоритмом S-пары 
\begin_inset Formula $(u_{1}\cdot R[r_{1}],u_{3}\cdot R[r_{3}])$
\end_inset

, а из свойства 
\begin_inset Formula $\Sig(u_{3}\cdot R[r_{3}])\preccurlyeq_{P}\Sig(u_{2}\cdot R[r_{2}])$
\end_inset

 вытекает утверждаемая теоремой минимальность сигнатуры.
\end_layout

\begin_layout Standard
Из доказанных теорем вытекает следующее заключение, описывающее работу алгоритма
 с S-парами.
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "clm:how-sigs"

\end_inset

По любой сигнатуре 
\begin_inset Formula $\sigma$
\end_inset

 и множеству 
\begin_inset Formula $R$
\end_inset

 можно единственным образом определить потенциально проходящую критерии
 S-пару сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

.
 Старшая часть S-пары определяется по сигнатуре, согласно теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:high-sp-part"

\end_inset

, откуда, по сокращаемому моному, можно однозначно определить младшую часть
 S-пары по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:low-sp-part"

\end_inset

.
 При этом, если алгоритм F5 хотя бы один раз создал S-пару с подходящей
 старшей частью для сигнатуры 
\begin_inset Formula $\sigma$
\end_inset

 -- то для этой сигнатуры существует проходящая критерии S-пара, и алгоритм
 будет проводить редукцию этой S-пары.
 Описанные S-пары покрывают все S-пары, редуцируемые алгоритмом.
\end_layout

\begin_layout Standard
Теперь рассмотрим работу алгоритма при редукции.
 При выборе редуктора процедура 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 может вернуть как многочлен, выступающий в роли редуктора, так и многочлен
 большей сигнатуры, используемый при создании S-пары.
 Покажем, что порядок обхода множества 
\begin_inset Formula $G$
\end_inset

 в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 не играет роли.
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "clm:how-reds"

\end_inset

К моменту вызова 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 не более чем один многочлен из 
\begin_inset Formula $R$
\end_inset

 может быть сигнатурным редуктором, удовлетворяющем критериям.
 При этом, если множество сигнатурных редукторов непусто, удовлетворять
 критериям будет многочлен с наименьшей домноженной сигнатурой.
\end_layout

\begin_layout Proof
Предположим наличие двух потенциальных редукторов, записываемых в домноженном
 виде как 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 и 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

.
 У них равные 
\begin_inset Formula $\HM$
\end_inset

 и сигнатуры, меньшие текущей рассматриваемой, поэтому можно рассмотреть
 их S-пару и, поступая аналогично доказательству единственности в теореме
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:low-sp-part"

\end_inset

, получить, что один из них не проходит критерии.
 Единственность доказана.
\end_layout

\begin_layout Proof
Второе утверждение немедленно вытекает из теорем 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exists-Gg-repr"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset


\end_layout

\begin_layout Standard
Таким образом получается, что правило выбора проходящего критерии редуктора
 идентично правилу выбора подходящей критерии младшей части S-пары.
\end_layout

\begin_layout Standard
Одной из особенностей исходного алгоритма F5, отличающей его от большинства
 порождённых на его основе является генерация S-пар одновременно с процессом
 редукции в случае, если 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:IsReducible"

\end_inset

 вернула редуктор, не являющийся сигнатурным редуктором.
 Оказывается, что этого можно не делать: если при поиске редукторов для
 многочлена 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $R[r{}_{1}]$
\end_inset

 в множестве 
\begin_inset Formula $G$
\end_inset

 одновременно присутствуют сигнатурный редуктор 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

 и редуктор 
\begin_inset Formula $u''_{2}\cdot R[r''_{2}]$
\end_inset

, не являющийся сигнатурным, то добавление S-пары 
\begin_inset Formula $R[r{}_{2}'']$
\end_inset

 и 
\begin_inset Formula $R[r{}_{1}]$
\end_inset

 является излишним, поскольку её младшая часть 
\begin_inset Formula $R[r{}_{1}]$
\end_inset

 имеет большую сигнатуру, чем имеющий тот же старший моном домноженный многочлен
 
\begin_inset Formula $u'_{2}\cdot R[r'_{2}]$
\end_inset

, а значит добавленной ранее S-пары 
\begin_inset Formula $R[r{}_{2}'']$
\end_inset

 и 
\begin_inset Formula $R[r'_{2}]$
\end_inset

 достаточно.
 Более строгое доказательство этого факта дано в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 (Предложение 6).
 Добавление S-пар, после того как сигнатурные редукции закончились, остаётся
 необходимым.
\end_layout

\begin_layout Standard
Перечисленные утверждения позволяют предположить, что упрощённая версия
 F5 может быть сформулирована в следующем виде:
\end_layout

\begin_layout Paragraph

\family typewriter
\series medium
\begin_inset CommandInset label
LatexCommand label
name "par:SimplifiedF5"

\end_inset

SimplifiedF5
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход:
\series bold
 
\series default

\begin_inset Formula $((1,i),f_{i})$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $G_{i-1}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера некоторого идеала 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $P$
\end_inset

 -- упорядоченный список старших частей S-пар отмеченных многочленов, 
\begin_inset Formula $p$
\end_inset

 -- некоторая старшая часть S-пары, 
\begin_inset Formula $h\in H$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $r$
\end_inset

 -- индекс элементов в 
\begin_inset Formula $R$
\end_inset

, используемый при итерировании
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат:
\series bold
 
\series default

\begin_inset Formula $G_{i}$
\end_inset

 -- множество индексов отмеченных многочленов в 
\begin_inset Formula $R$
\end_inset

, образующих базис Грёбнера идеала 
\begin_inset Formula $\left(\left\{ poly(R[r])|r\in G_{i-1}\right\} \cup f_{i}\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}=G_{i-1}\cup\left\{ i\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow$
\end_inset


\shape default
 Отсортированные по сигнатуре старшие части S-пар, образуемых 
\family typewriter
{
\family sans

\begin_inset Formula $(R[i],R[r])|r\in G_{i-1}$
\end_inset

}
\end_layout

\begin_layout Enumerate

\family sans
\series bold
while 
\series default

\begin_inset Formula $P\ne\varnothing$
\end_inset

 
\series bold
do 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $p\leftarrow P[1]$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\setminus\left\{ p\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if 
\begin_inset Formula $p$
\end_inset

 
\family sans
\series default
является подходящей старшей частью S-пары для своей сигнатуры в терминах
 утверждения 
\begin_inset CommandInset ref
LatexCommand ref
reference "clm:how-sigs"

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $h\leftarrow$
\end_inset

 
\family sans
многочлен, получаемый перемножением 
\family default

\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $h\leftarrow$
\end_inset

 
\family sans
пока в 
\begin_inset Formula $G$
\end_inset

 есть сигнатурные редукторы для 
\family default

\begin_inset Formula $h$
\end_inset


\family sans
, редуцировать его относительно сигнатурного редуктора наименьшей домноженной
 степени в терминах утверждения 
\begin_inset CommandInset ref
LatexCommand ref
reference "clm:how-reds"

\end_inset


\end_layout

\begin_layout Enumerate

\family sans
Добавить 
\begin_inset Formula $h$
\end_inset

 в конец 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $P\leftarrow P\cup$
\end_inset


\shape default
 старшие части S-пар, образуемых 
\family typewriter
{
\family sans

\begin_inset Formula $(R[\#R],R[r])|r\in G_{i}$
\end_inset

}
\end_layout

\begin_layout Enumerate

\family sans
\shape italic
\begin_inset Formula $G_{i}\leftarrow G_{i}\cup\left\{ \#R\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\family sans
Отсортировать 
\begin_inset Formula $P$
\end_inset

 по возрастанию сокращаемого монома 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\family sans
\series bold
return 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $G_{i}$
\end_inset


\end_layout

\begin_layout Standard
Данный алгоритм не совсем эквивалентен F5, поскольку может иметь отличный
 от него порядок добавления элементов в 
\begin_inset Formula $R$
\end_inset

, что влияет на работу правил перезаписи, выражаемых в этом алгоритме в
 правиле проверки старшей части S-пары.
 
\end_layout

\begin_layout Standard
Мы также оставляем открытым вопрос корректности этого алгоритма, рассматривая
 в следующем разделе вместо него другой алгоритм, в котором правило проверки
 старшей части S-пары сформулировано в терминах старших мономов и сигнатур
 и не использует порядок добавления.
 Сравнение этих двух правил описано в главе 7 работы 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

, однако не является необходимым для формулировки доказательства нижеследующего
 алгоритма.
\end_layout

\begin_layout Section
Простой алгоритм, основанный на сигнатурах
\end_layout

\begin_layout Standard
Предлагаемый ниже алгоритм формулируется в виде шага инкрементального алгоритма
 вычисления базиса Грёбнера.
 Поскольку, случаи 
\begin_inset Formula $f=0\Rightarrow\left(G\cup f\right)=\left(G\right)$
\end_inset

 и 
\begin_inset Formula $\exists k\ne0\, k\in\mathcal{K}\cap G\Rightarrow\left(G\right)=\left(G\cup f\right)=\mathcal{P}=\left(1\right)$
\end_inset

 не представляют вычислительной сложности, далее предполагается что 
\begin_inset Formula $f\neq0$
\end_inset

 и 
\begin_inset Formula $G=\left\{ g_{1},\dots,g_{m}\right\} ,g_{i}\notin\mathcal{K}$
\end_inset

.
 Заметим, что в отличии от исходного алгоритма F5, однородность входных
 многочленов не требуется.
\end_layout

\begin_layout Subsection
Определения
\end_layout

\begin_layout Standard
Множество сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 для одноэтапного случая может быть расширено нулём по аналогии с 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

: 
\begin_inset Formula $\mathbf{T}_{0}\eqdef\mathbf{T}\cup\{0\}$
\end_inset

.
 При этом, заданный на 
\begin_inset Formula $\mathbf{T}$
\end_inset

 порядок расширяется с сохранением линейно-упорядоченности так, что ноль
 оказывается наименьшим элементом.
\end_layout

\begin_layout Standard
Введём несколько определений, применимых для понятия сигнатуры из множества
 
\begin_inset Formula $\tau_{0}$
\end_inset

, соответствующего 
\begin_inset Formula $\mathbf{T}_{0}$
\end_inset

 или 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

, и линейного порядка 
\begin_inset Formula $\prec_{\tau0}$
\end_inset

 на нём.
 В этом множестве определено умножение на ненулевые мономы 
\begin_inset Formula $\mathbb{T}$
\end_inset

, сохраняющее порядок, а также умножение на элементы 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

, не сохраняющее порядок.
\end_layout

\begin_layout Standard
Ключевым понятием для данного алгоритма является порядок на отмеченных многочлен
ах, определяемый по аналогии с порядками 
\begin_inset Formula $\prec_{p}$
\end_inset

 из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

 и 
\begin_inset Formula $\prec_{l}$
\end_inset

 из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "2012GrbTermination"

\end_inset

:
\end_layout

\begin_layout Definition
Зададим частичный порядок 
\begin_inset Formula $\GVWl$
\end_inset

 на множестве отмеченных многочленов 
\begin_inset Formula $H$
\end_inset

: 
\begin_inset Formula 
\[
h_{1}=(\sigma_{1},p_{1})\GVWl h_{2}=(\sigma_{2},p_{2})\equivdef\HM(p_{1})\sigma_{2}\prec_{\tau0}\HM(p_{2})\sigma_{1},
\]

\end_inset


\end_layout

\begin_layout Definition
где последнее неравенство рассматривается в 
\begin_inset Formula $\tau_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Для неравных элементов 
\begin_inset Formula $(\sigma_{1},p_{1})\ne(\sigma_{2},p_{2})$
\end_inset

 выполняется ровно одно из отношений 
\begin_inset Formula $<_{H},>_{H}$
\end_inset

 во всех случаях кроме следующих:
\end_layout

\begin_layout Itemize
Один из них равен 
\begin_inset Formula $(0,0)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $p_{1}=p_{2}=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma_{1}=\sigma_{2}=0$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $(\sigma_{1},p_{1})=(t\sigma_{2},tp_{2})$
\end_inset


\end_layout

\begin_layout Standard
В указанных случаях элементы несравнимы.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "remark:follows-from-lessH"

\end_inset

Из определения следует, что 
\begin_inset Formula $(\sigma_{1},p_{1})<_{H}(\sigma_{2},p_{2})$
\end_inset

 возможно только тогда, когда 
\begin_inset Formula $0\ne\HM(p_{2})\sigma_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
Согласно этому определению, элементы с нулевым старшим мономом оказываются
 нестрогими экстремумами:
\begin_inset Formula 
\[
\forall\sigma_{1},\sigma_{2},p_{2}\,\left(\sigma_{1},0\right)\not\GVWg\left(\sigma_{2},p_{2}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Для случая инкрементального алгоритма с порядком 
\begin_inset Formula $\prec_{0}$
\end_inset

, элементы с нулевой сигнатурой -- также нестрогие экстремумы:
\begin_inset Formula 
\[
\forall\sigma_{2},p_{1},p_{2}\in\mathbb{T}_{0}\,\left(0,p_{1}\right)\not\GVWl\left(\sigma_{2},p_{2}\right).
\]

\end_inset


\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,t\in\mathbb{T}$
\end_inset

, тогда 
\begin_inset Formula $h_{1}\GVWg h_{2}\Leftrightarrow h_{1}\GVWg th_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Выводится из того, что умножение на 
\begin_inset Formula $t$
\end_inset

 одного из сравниваемых отмеченных многочленов приводит к умножению на 
\begin_inset Formula $t$
\end_inset

 обоих частей в определении 
\begin_inset Formula $\GVWg$
\end_inset

.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1},h_{2}\in H,\HM(h_{1})|\HM(h_{2}),\HM(h_{2})\neq0$
\end_inset

.
 Тогда сигнатурная редукция 
\begin_inset Formula $h_{2}$
\end_inset

 по 
\begin_inset Formula $h_{1}$
\end_inset

 возможна если и только если 
\begin_inset Formula $h_{1}\GVWg h_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Следует из того, что оба утверждения равносильны неравенству 
\begin_inset Formula $\Sig(h_{2})\succ_{\tau}\Sig(h_{1})\frac{\HM(h_{2})}{\HM(h_{1})}$
\end_inset

.
\end_layout

\begin_layout Standard
Следующее определение эквивалентно определению согласованности порядков
 из 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception"

\end_inset

:
\end_layout

\begin_layout Definition
Порядок на сигнатурах 
\begin_inset Formula $\prec_{\tau}$
\end_inset

 называется 
\emph on
согласованным с порядком на мономах
\emph default
 
\begin_inset Formula $\prec$
\end_inset

, если 
\begin_inset Formula $\forall t_{1},t_{2}\in\mathbb{T},\sigma\in\tau\, t_{1}\prec t_{2}\Longleftrightarrow t_{1}\sigma\prec_{\tau}t_{2}\sigma$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:precP_compatible"

\end_inset

Порядок 
\begin_inset Formula $\prec_{P}$
\end_inset

 согласован с порядком 
\begin_inset Formula $\prec$
\end_inset

.
\end_layout

\begin_layout Proof
Пусть 
\begin_inset Formula $\sigma=(s,i)\in\mathbf{T}$
\end_inset

.
 Тогда
\begin_inset Formula 
\[
t_{1}\sigma\prec_{P}t_{2}\sigma\Longleftrightarrow\left(t_{1}s,i\right)\prec_{P}\left(t_{2}s,i\right)\Longleftrightarrow t_{1}s\prec t_{2}s\Longleftrightarrow t_{1}\prec t_{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Все конкретные порядки на сигнатурах, рассматриваемые в данной работе являются
 согласованными с порядком на мономах.
 Поэтому во всех последующих утверждениях на порядок 
\begin_inset Formula $\prec_{\tau}$
\end_inset

 накладывается требование согласованности.
\end_layout

\begin_layout Lemma
Пусть 
\begin_inset Formula $h_{1}\in H$
\end_inset

 -- результат сигнатурной редукции 
\begin_inset Formula $h_{1}'$
\end_inset

 по некоторому многочлену.
 Тогда 
\begin_inset Formula $h_{1}\GVWl h_{1}'$
\end_inset

.
\end_layout

\begin_layout Proof
Следует из 
\begin_inset Formula $\Sig(h_{1})=\Sig(h_{1}')$
\end_inset

 и уменьшения 
\begin_inset Formula $\HM$
\end_inset

 при редукции: 
\begin_inset Formula $\HM(h_{1})\prec_{0}\HM(h_{1}').$
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:greater-or-smaller"

\end_inset

Пусть 
\begin_inset Formula $h_{1}\GVWl h_{2}$
\end_inset

 отмеченные многочлены.
 Тогда 
\begin_inset Formula $\forall h_{3}\in H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

 выполняется хотя бы одно из двух неравенств: 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

 или 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
Из условия леммы известно, что
\begin_inset Formula 
\begin{equation}
\HM(h_{1})\Sig(h_{2})\prec_{\tau}\HM(h_{2})\Sig(h_{1})\label{eq:gvw-order-3}
\end{equation}

\end_inset

откуда по замечанию 
\begin_inset CommandInset ref
LatexCommand ref
reference "remark:follows-from-lessH"

\end_inset

 
\begin_inset Formula $\HM(h_{2})\neq0,\Sig(h_{1})\neq0$
\end_inset

.
 Поэтому, если 
\begin_inset Formula $\HM(h_{3})=0$
\end_inset

, имеем 
\begin_inset Formula $h_{3}\GVWl h_{2}$
\end_inset

, а если 
\begin_inset Formula $\Sig(h_{3})=0$
\end_inset

 -- то 
\begin_inset Formula $h_{1}\GVWl h_{3}$
\end_inset

.
 Иначе можно домножить неравенство 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:gvw-order-3"

\end_inset

 на ненулевой элемент 
\begin_inset Formula $\HM(h_{3})\Sig(h_{3})$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
\HM(h_{3})\Sig(h_{3})\HM(h_{1})\Sig(h_{2})\prec_{\tau0}\HM(h_{3})\Sig(h_{3})\HM(h_{2})\Sig(h_{1}).\label{eq:left-or-right-monom}
\end{equation}

\end_inset

Поскольку 
\begin_inset Formula $\succ_{\tau0}$
\end_inset

 -- линейный порядок, 
\begin_inset Formula $\HM(h_{3})^{2}\Sig(h_{2})\Sig(h_{1})\in\mathbb{T}_{0}$
\end_inset

 будет или 
\begin_inset Formula $\succ_{\tau0}$
\end_inset

 левой или 
\begin_inset Formula $\prec_{\tau0}$
\end_inset

 правой части 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:left-or-right-monom"

\end_inset

.
 Это даёт неравенство на 
\begin_inset Formula $\HM(h_{3})^{2}\Sig(h_{2})\Sig(h_{1})$
\end_inset

, которое после сокращения даст неравенство, эквивалентное утверждению леммы.
\end_layout

\begin_layout Subsection
Алгоритм
\end_layout

\begin_layout Standard
Сформулируем шаг инкрементального алгоритма базиса Грёбнера, подразумевая
 под 
\begin_inset Formula $<_{H}$
\end_inset

 отношение отмеченных многочленов, индуцированное порядком 
\begin_inset Formula $\prec_{0}$
\end_inset

 на сигнатурах 
\begin_inset Formula $\mathbb{T}_{0}$
\end_inset

.
 Для простоты дальнейших рассуждений будем предполагать, что входные многочлены
 имеют 
\begin_inset Formula $\HC=1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Псевдокод инкрементального алгоритма 
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:SimpleSignatureGroebner"

\end_inset


\family typewriter
SimpleSignatureGroebner
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход: многочлены 
\begin_inset Formula $\{g_{1},\dots,g_{m}\}$
\end_inset

, образующие базис Грёбнера, многочлен 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $\HC(g_{i})=\HC(f)=1$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 -- подмножества 
\begin_inset Formula $H$
\end_inset

, 
\begin_inset Formula $(\sigma,p')\in H$
\end_inset

 -- отмеченный многочлен текущего шага до редукции, 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- он же после редукции, 
\begin_inset Formula $r,b$
\end_inset

 -- элементы 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(g_{1},\dots,g_{m},f\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\{\left(\HM(g_{1}),0\right),\dots,\left(\HM(g_{m}),0\right),(0,g_{1}),\dots,(0,g_{m})\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(\sigma,p')\leftarrow(1,f)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do forever:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-before-reduce"

\end_inset


\begin_inset Formula $p\leftarrow$
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

((
\begin_inset Formula $\sigma,p'),R$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-after-reduce"

\end_inset


\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-from-B"

\end_inset


\begin_inset Formula $B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\Sig(r)|\Sig(b)\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if 
\begin_inset Formula $B\neq\varnothing$
\end_inset

: 
\series default

\begin_inset Formula $(\sigma,p')\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec_{0}$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate

\series bold
else: break
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)\,|\, r\in R,\poly(r)\ne0\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:ReduceCheckingSignatures"

\end_inset


\family typewriter
\series medium
ReduceCheckingSignatures
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход: 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- отмеченный многочлен, 
\begin_inset Formula $R$
\end_inset

 -- подмножество 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $r$
\end_inset

 -- элемент 
\begin_inset Formula $R$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат: 
\begin_inset Formula $p$
\end_inset

 -- многочлен, сигнатурно редуцированный по 
\begin_inset Formula $R$
\end_inset

 нормализованный единичным старшим коэффициентом
\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $\exists r\in R\, r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 сигнатурно редуцировать 
\begin_inset Formula $p$
\end_inset

 по 
\begin_inset Formula $\GVWg$
\end_inset

-максимальному элементу 
\begin_inset Formula $r$
\end_inset

 среди указанных в условии цикла
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
if 
\series default

\begin_inset Formula $p\ne0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow\frac{p}{\HC(p)}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $p$
\end_inset


\end_layout

\begin_layout Lemma
Все пары из 
\begin_inset Formula $\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

 в алгоритме -- элементы 
\begin_inset Formula $H\setminus\left\{ \left(0,0\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Proof
Элементы, формируемые до начала главного цикла, являются рассмотренными
 в примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:labeled-polys"

\end_inset

 отмеченными многочленами.
 Все остальные отмеченные многочлены в алгоритме формируются или умножением
 на 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

 или редукцией с сохранением сигнатуры, поэтому они корректны и лежат в
 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Условия циклов, расширяющих 
\begin_inset Formula $B$
\end_inset

, таковы, что в
\series bold
 
\series default

\begin_inset Formula $B$
\end_inset

 нет ни нулевых сигнатур, ни нулевых старших мономов.
 Поэтому 
\begin_inset Formula $\sigma$
\end_inset

 никогда не обращается в 0 и нулевые сигнатуры в 
\begin_inset Formula $R$
\end_inset

 лишь у элементов 
\begin_inset Formula $(0,g_{1}),...,(0,g_{m}).$
\end_inset

 Нулевой старший моном может быть у любого многочлена, добавляемого в 
\begin_inset Formula $R$
\end_inset

, а нулевых многочленов с одновременно нулевой сигнатурой в 
\begin_inset Formula $R$
\end_inset

 нет.
\end_layout

\begin_layout Subsection
Остановка алгоритма
\end_layout

\begin_layout Standard
Дадим теоретическое обоснование представленного алгоритма.
 Для этого покажем его остановку и корректность результата.
 Данные результаты показаны без использования фактов, полученных ранее при
 доказательстве остановки F5, поскольку приведённый алгоритм позволяет дать
 значительно более простое обоснование без ссылок на них.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:exist-reductor"

\end_inset

В любой момент работы алгоритма, любой отмеченный многочлен из 
\begin_inset Formula $B$
\end_inset

 может быть редуцирован с сохранением сигнатуры по некоторому элементу 
\begin_inset Formula $R.$
\end_inset


\end_layout

\begin_layout Proof
Отмеченные многочлены добавляются в 
\begin_inset Formula $B$
\end_inset

 таким образом, чтобы иметь хотя бы один подходящий редуктор.
 
\begin_inset Formula $(\sigma,p)\in R$
\end_inset

 является таким редуктором при добавлении в первом цикле 
\series bold
for
\series default
, 
\begin_inset Formula $r\in R$
\end_inset

 -- во втором.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-small"

\end_inset

До редукции многочлена 
\begin_inset Formula $p'$
\end_inset

, то есть на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-before-reduce"

\end_inset

 любой итерации алгоритма, сигнатуры элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $
\end_inset

 не делят 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
На первой итерации алгоритма это выполняется, поскольку 
\begin_inset Formula $\sigma=1$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

 не содержит элементы с сигнатурами, делящими 1.
 На последующих итерациях это выполнено, поскольку если бы в 
\begin_inset Formula $R$
\end_inset

 существовали такие элементы, то 
\begin_inset Formula $\left(\sigma,p'\right)$
\end_inset

 был бы убран из 
\begin_inset Formula $B$
\end_inset

 в предыдущей итерации на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-big"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, старшие мономы элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $
\end_inset

 не делят 
\begin_inset Formula $\HM(p)$
\end_inset

.
\end_layout

\begin_layout Proof
Вытекает из того, что цикл в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 останавливается по достижении 
\begin_inset Formula $p$
\end_inset

, для которого такие элементы в 
\begin_inset Formula $R$
\end_inset

 не существуют.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:adds-really-new"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, элементы 
\begin_inset Formula $R$
\end_inset

 не могут одновременно иметь старшие мономы, делящие 
\begin_inset Formula $\HM(p)$
\end_inset

, и сигнатуры, делящие 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor"

\end_inset

, будет произведена хотя бы одна редукция 
\begin_inset Formula $p'$
\end_inset

, поэтому 
\begin_inset Formula $(\sigma,p')\GVWg(\sigma,p)$
\end_inset

.
 Отсюда, по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:greater-or-smaller"

\end_inset

, для 
\begin_inset Formula $\forall r\in R$
\end_inset

 имеем 
\begin_inset Formula $r\GVWg(\sigma,p)$
\end_inset

 или 
\begin_inset Formula $r\GVWl(\sigma,p')$
\end_inset

.
 Выполнение одного из неравенств позволяет применить одну из лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-small"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:SSG-stop"

\end_inset

Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 останавливается
\end_layout

\begin_layout Proof
Для доказательства остановки нужно показать, что все циклы 
\series bold
do
\series default
 выполняются лишь конечное число раз.
 В 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 при ненулевых 
\begin_inset Formula $p$
\end_inset

 на каждой итерации 
\begin_inset Formula $\HM(p)$
\end_inset

 уменьшается по 
\begin_inset Formula $\prec_{0}$
\end_inset

, что возможно лишь конечное число раз.
 При обнулении 
\begin_inset Formula $p$
\end_inset

 он завершится в силу 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $(\sigma,0)$
\end_inset

.
\end_layout

\begin_layout Proof
На каждом шаге основного цикла пополняется множество 
\begin_inset Formula $R\subset\mathbb{T}_{0}\times\mathcal{P}$
\end_inset

.
 Оно может быть разбито как 
\begin_inset Formula $R_{*0}\cup R_{0*}\cup R_{**},$
\end_inset

 где 
\begin_inset Formula $R_{*0}\subset\mathbb{T}\times\left\{ 0\right\} ,R_{0*}\subset\left\{ 0\right\} \times\mathcal{P}\setminus\left\{ 0\right\} ,R_{**}\subset\mathbb{T}\times\mathcal{P}\setminus\left\{ 0\right\} $
\end_inset

.
 
\begin_inset Formula $R_{0*}$
\end_inset

 не пополняется в силу 
\begin_inset Formula $\sigma\neq0$
\end_inset

.
 Для 
\begin_inset Formula $R_{*0}$
\end_inset

 и 
\begin_inset Formula $R_{**}$
\end_inset

 применим подход, основанный на понятии идеалов моноидов, предложенном в
 
\begin_inset CommandInset citation
LatexCommand cite
key "KreuzerRobbianoBook1"

\end_inset

 как ``monoid ideal''.
 Рассмотрим следующие множества, являющиеся идеалами моноидов: 
\begin_inset Formula $L_{*0}=\left(\left\{ \sigma\,|\,(\sigma,0)\in R_{*0}\right\} \right)\subset\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $L_{**}=\left(\left\{ (\sigma,t)\,|\,\exists(\sigma,p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$
\end_inset

.
 В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new"

\end_inset

 добавляемые в 
\begin_inset Formula $R$
\end_inset

 элементы расширяют на каждом шаге 
\begin_inset Formula $L_{*0}$
\end_inset

 или 
\begin_inset Formula $L_{**}$
\end_inset

.
 Поскольку моноиды 
\begin_inset Formula $\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\mathbb{T}\times\mathbb{T}$
\end_inset

 изоморфны 
\begin_inset Formula $\mathbb{N}^{n}$
\end_inset

 и 
\begin_inset Formula $\mathbb{N}^{2n}$
\end_inset

, к их идеалам может быть применена лемма Диксона, которая и утверждает,
 что расширение может происходить лишь конечное число раз.
\end_layout

\begin_layout Subsection
Корректность результата
\end_layout

\begin_layout Standard
Следующее определение расширяет понятие S-базиса из работы 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

:
\end_layout

\begin_layout Definition
Назовём 
\begin_inset Formula $R\subset H$
\end_inset


\emph on
 S-базисом
\emph default
 (соответственно 
\emph on
S
\begin_inset Formula $_{\sigma}$
\end_inset

-базисом
\emph default
) идеала отмеченных многочленов 
\begin_inset Formula $I\subset H$
\end_inset

, если все элементы 
\begin_inset Formula $I$
\end_inset

 (соответственно 
\begin_inset Formula $\left\{ h\in I\,|\,\Sig(h)\prec_{0}\sigma\right\} $
\end_inset

)
\emph on
 
\emph default
имеют сигнатурное представление
\emph on
 
\emph default
над 
\begin_inset Formula $R$
\end_inset


\emph on
.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:s-basis-and-no-reductions"

\end_inset

Пусть 
\begin_inset Formula $\sigma\succ_{0}0,R=\left\{ r_{i}\right\} $
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис, и выбраны 
\begin_inset Formula $h_{1},h_{2}\in H,\Sig(h_{i})=\sigma$
\end_inset

, которые нельзя сигнатурно редуцировать по 
\begin_inset Formula $R$
\end_inset

.
 Тогда 
\begin_inset Formula $\HM(h_{1})=\HM(h_{2})$
\end_inset

 и у 
\begin_inset Formula $h_{1}$
\end_inset

 есть сигнатурное представление над 
\begin_inset Formula $R\cup\left\{ h_{2}\right\} $
\end_inset

.
\end_layout

\begin_layout Proof
Из определения 
\begin_inset Formula $H$
\end_inset

 имеем 
\begin_inset Formula $\exists u_{i}\in\mathcal{P}\,\HM(u_{i})=\sigma,u_{i}f\equiv\poly(h_{i})\pmod{\left(G\right)},i=1,2.$
\end_inset

 Значит, некоторой линейной комбинации 
\begin_inset Formula $\poly(h_{i})$
\end_inset

 сопоставляется 
\begin_inset Formula $\prec_{0}\sigma$
\end_inset

 сигнатура: 
\begin_inset Formula 
\[
\exists K\in\mathcal{K},v\in\mathcal{P}\,\HM(v)=\sigma'\prec_{0}\sigma,vf\equiv\poly(h_{1})-K\poly(h_{2})\pmod{\left(G\right)},
\]

\end_inset

то есть, 
\begin_inset Formula $\left(\sigma',p'\right)=\left(\sigma',\poly(h_{1})-K\poly(h_{2})\right)\in H$
\end_inset

.
 Из определения S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базиса и 
\begin_inset Formula $\sigma'\prec_{0}\sigma$
\end_inset

 вытекает 
\begin_inset Formula $\exists r_{j}\in R,t\in\mathbb{T}\,\Sig(tr_{j})\preccurlyeq_{0}\sigma',\HM(tr_{j})=\HM(p')$
\end_inset

.
 Отсюда 
\begin_inset Formula $\HM(h_{i})\neq\HM(p'),i=1,2$
\end_inset

, иначе 
\begin_inset Formula $r_{j}$
\end_inset

 редуцировало бы 
\begin_inset Formula $h_{i}$
\end_inset

 сигнатурно.
 Значит, 
\begin_inset Formula $\HM(h_{i})$
\end_inset

 сокращаются при вычитании с 
\begin_inset Formula $\mathcal{K}$
\end_inset

-коэффициентом, что даёт 
\begin_inset Formula $\HM(h_{1})=\HM(h_{2})$
\end_inset

.
 Сигнатурное представление 
\begin_inset Formula $h_{1}$
\end_inset

 получается добавлением 
\begin_inset Formula $K\cdot\poly(h_{2})$
\end_inset

 к сигнатурному представлению 
\begin_inset Formula $\left(\sigma',p'\right)$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:S-basis-is-a-basis"

\end_inset

Если 
\begin_inset Formula $R$
\end_inset

 -- S-базис идеала 
\begin_inset Formula $I$
\end_inset

, то 
\begin_inset Formula $\{\poly(r)\,|\, r\in R\}$
\end_inset

 является базисом Грёбнера идеала 
\begin_inset Formula $I$
\end_inset

.
\end_layout

\begin_layout Proof
Для 
\begin_inset Formula $\forall p\in I$
\end_inset

 можно взять некоторый 
\begin_inset Formula $h=\left(\sigma,p\right)\in H$
\end_inset

 и применить теорему 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-r-sigma"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен инвариант: для 
\begin_inset Formula $\forall\sigma\in\mathbb{T},\sigma\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, найдутся 
\begin_inset Formula $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\Sig(t_{\sigma}r_{\sigma})=\sigma$
\end_inset

, и 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 не редуцируется сигнатурно по 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Множество 
\begin_inset Formula $R_{\sigma}=\left\{ r\in R\,|\,\Sig(r)|\sigma\right\} $
\end_inset

 непусто, так как содержит добавленный на первой итерации элемент 
\begin_inset Formula $r_{0}$
\end_inset

 с 
\begin_inset Formula $\Sig(r_{0})=1$
\end_inset

.
 Обозначим за 
\begin_inset Formula $r_{\sigma}$
\end_inset

 его 
\begin_inset Formula $\GVWl$
\end_inset

-минимальный элемент.
 Обозначим 
\begin_inset Formula $t_{\sigma}=\frac{\sigma}{\Sig(r_{\sigma})}$
\end_inset

.
 Предположим, что 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 может быть редуцирован с сохранением сигнатуры относительно некоторого
 
\begin_inset Formula $r_{1}\in R$
\end_inset

.
 Отсюда следует, что 
\begin_inset Formula $r_{1}\GVWg r_{\sigma}$
\end_inset

, а также что они не нулевые.
 Значит, на той же итерации, когда в 
\begin_inset Formula $R$
\end_inset

 был добавлен последний из 
\begin_inset Formula $\{r_{\sigma},r_{1}\}$
\end_inset

, в множество 
\begin_inset Formula $B$
\end_inset

 был добавлен многочлен 
\begin_inset Formula $t'r_{\sigma}$
\end_inset

, где 
\begin_inset Formula $t'=\frac{\LCM(\HM(r_{1}),\HM(r_{\sigma}))}{\HM(r_{\sigma})}$
\end_inset

, причём 
\begin_inset Formula $t'|t_{\sigma}$
\end_inset

.
 Отсюда 
\begin_inset Formula $\Sig(t'r_{\sigma})|\Sig(t_{\sigma}r_{\sigma})=\sigma\Rightarrow\Sig(t'r_{\sigma})\preccurlyeq\sigma\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

.
 В силу этого неравенства на сигнатуры получается, что 
\begin_inset Formula $t'r_{\sigma}$
\end_inset

 уже не может быть элементом 
\begin_inset Formula $B$
\end_inset

, а значит, был выкинут на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 одной из итераций, то есть 
\begin_inset Formula $\exists r_{2}\in R\, r_{2}\GVWl t'r_{\sigma},\Sig(r_{2})|\Sig(t'r_{\sigma})$
\end_inset

.
 Это невозможно, поскольку влечёт 
\begin_inset Formula $r_{2}\GVWl r_{\sigma},r_{2}\in R_{\sigma}$
\end_inset

, что противоречит 
\begin_inset Formula $\GVWl$
\end_inset

-минимальности 
\begin_inset Formula $r_{\sigma}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:has-s-repr"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

 выполнен инвариант: 
\begin_inset Formula $\forall h\in H,\Sig(h)\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, имеет сигнатурное представление над 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим нарушение инварианта на какой-то итерации и рассмотрим 
\begin_inset Formula $\prec_{0}$
\end_inset

-минимальную 
\begin_inset Formula $\sigma$
\end_inset

, для которой непусто 
\begin_inset Formula $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\Sig(h)=\sigma\}$
\end_inset

.
 Тогда 
\begin_inset Formula $R$
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис.
 Для 
\begin_inset Formula $\forall g\in\left(G\right)$
\end_inset

 соответствующие отмеченные многочлены 
\begin_inset Formula $\left(0,g\right)$
\end_inset

 имеют сигнатурные представления над 
\begin_inset Formula $\{(0,g_{1}),...,(0,g_{m})\}\subset R$
\end_inset

, поэтому 
\begin_inset Formula $\sigma\succ_{0}0$
\end_inset

.
 Выберем 
\begin_inset Formula $v_{\sigma}$
\end_inset

 -- один из элементов 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\prec_{0}$
\end_inset

-наименьшим 
\begin_inset Formula $\HM$
\end_inset

.
 Он не может быть редуцирован с сохранением сигнатуры по 
\begin_inset Formula $R$
\end_inset

, поскольку результат редукции 
\begin_inset Formula $v_{1}$
\end_inset

 был бы элементом 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\HM(v_{1})\prec_{0}\HM(v_{\sigma})$
\end_inset

.
 Возьмём 
\begin_inset Formula $w_{\sigma}\eqdef t_{\sigma}r_{\sigma}$
\end_inset

 из инварианта теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-r-sigma"

\end_inset

 и применим лемму 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:s-basis-and-no-reductions"

\end_inset

 к 
\begin_inset Formula $v_{\sigma},w_{\sigma}$
\end_inset

 и 
\begin_inset Formula $R$
\end_inset

.
 Получим что 
\begin_inset Formula $v_{\sigma}$
\end_inset

 имеет сигнатурное представление над 
\begin_inset Formula $R\cup\{w_{\sigma}\}$
\end_inset

.
 Вхождения 
\begin_inset Formula $w_{\sigma}$
\end_inset

 в нём можно заменить на 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

, получив представление 
\begin_inset Formula $v_{\sigma}$
\end_inset

 над 
\begin_inset Formula $R$
\end_inset

, что приводит к противоречию.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 возвращает базис Грёбнера
\end_layout

\begin_layout Proof
К моменту остановки 
\begin_inset Formula $B=\varnothing$
\end_inset

, значит, по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr"

\end_inset

 
\begin_inset Formula $R$
\end_inset

 -- S-базис, а значит, и базис Грёбнера.
\end_layout

\begin_layout Subsection
Сравнение с аналогами
\end_layout

\begin_layout Standard
Представленный алгоритм принадлежит к семейству алгоритмов вычисления базисов
 Грёбнера, которые вычисляют S-базис и в той или иной степени являются развитием
 алгоритма F5.
 Одно из основных направлений его развития -- упрощение теоретических обосновани
й и расширение области применимости -- представлено в 
\begin_inset CommandInset citation
LatexCommand cite
key "F5InBBStyle,GermanF5Proof_ru,ZobninGeneralization_ru"

\end_inset

.
 Другое -- повышение эффективности, путём ввода дополнительных критериев
 отбрасывания некоторых вычислений -- описывается в 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C,G2V,SignatureBasedGBs"

\end_inset

 и позволяет проводить вычисления так, чтобы до конца редуцировались лишь
 многочлены, являющиеся новыми элементами S-базиса или дающие новую сигнатуру
 нулевого многочлена, расширяющую идеал моноида, содержащий такие сигнатуры,
 называемые также 
\emph on
сигнатурами сизигий.

\emph default
 Обобщение с одновременным применением всех критериев в алгоритмах TRB-MJ
 и SB 
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception,PracticalGB"

\end_inset

 позволяет добиться большей эффективности благодаря тому, что все отбрасывания
 применяются до проведения таких вычислительно трудоёмких операций, как
 редукция многочлена или подсчёт старшего монома S-пары, -- в результате
 не оказывается, что результаты каких-то вычислений были отброшены.
\end_layout

\begin_layout Standard
Предположительно, ход работы алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 совпадает с ходом алгоритмов TRB-MJ и SB, однако в силу некоторого различия
 их формулировок, усложняющего сравнение, мы не будем останавливаться на
 строгом обосновании это факта.
 Вместо этого, приведём определённое подтверждение эффективности приведённого
 алгоритма среди алгоритмов, вычисляющих S-базис, заключающееся в отсутствии
 вычислений лишних элементов S-базиса.
\end_layout

\begin_layout Theorem
S-базис, вычисляемый 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

, -- минимален
\end_layout

\begin_layout Proof
Предположим, что S-базис не минимален.
 Это означает, что один из элементов 
\begin_inset Formula $\left(\sigma,p\right),p\ne0$
\end_inset

, добавленный в 
\begin_inset Formula $R$
\end_inset

 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 имеет сигнатурное представление над остальными элементами.
 Элементы, добавляемые в 
\begin_inset Formula $R$
\end_inset

 после него, имеют сигнатуры 
\begin_inset Formula $\succ_{0}\sigma$
\end_inset

, поэтому в таком представлении используются только элементы, добавленные
 в 
\begin_inset Formula $R$
\end_inset

 ранее.
 По теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Exist-hm-in-deg-repr"

\end_inset

 в этом представлении есть элемент 
\begin_inset Formula $m_{1}\cdot h_{1},h_{1}\in R$
\end_inset

 c 
\begin_inset Formula $\HM(h_{1})|\HM(p)$
\end_inset

.
 В силу сигнатурности 
\begin_inset Formula $m_{1}\Sig(h_{1})\preccurlyeq_{0}\sigma$
\end_inset

.
 При этом строгое неравенство невозможно в силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

, а равенство -- в силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new"

\end_inset

, что даёт противоречие.
\end_layout

\begin_layout Standard
Во многих сигнатурных алгоритмах, в том числе исходном F5, формулируется
 два типа критериев отброса: критерии, связанные с сизигиями, называемые
 
\begin_inset Quotes fld
\end_inset

критериями F5
\begin_inset Quotes frd
\end_inset

 в данной работе и 
\begin_inset Quotes fld
\end_inset

критериями Фожера
\begin_inset Quotes frd
\end_inset

 в работах 
\begin_inset CommandInset citation
LatexCommand cite
key "F5C,Modifying-for-termination"

\end_inset

, а также критерии перезаписи.
 Корректность каждого из типов доказывается независимо.
 Описанный алгоритм несколько проще: он использует лишь единственный критерий
 отброса на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B"

\end_inset

, основанный на 
\begin_inset Formula $\GVWl$
\end_inset

-упорядочивании множества 
\begin_inset Formula $R$
\end_inset

, сохраняя при этом гарантию минимальности S-базиса.
 Однако, вопрос наиболее эффективного способа выбора редуктора в 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 является в какой-то степени открытым.
 Представленный в описании алгоритма способ выбора продиктован утверждением
 
\begin_inset CommandInset ref
LatexCommand ref
reference "clm:how-reds"

\end_inset

 о работе исходного алгоритма F5, и использует всё то же 
\begin_inset Formula $\GVWl$
\end_inset

-упорядочение 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Standard
Также, даже в алгоритмах, не вычисляющих S-многочлены в процессе работы,
 теоретическое обоснование корректности алгоритма на них как правило опирается.
 Приведённое доказательство алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 не использует S-многочлены и доказывает алгебраические инварианты, выполняющиес
я в процессе работы алгоритма, что позволяет применять к нему, почти без
 изменений, простую алгебраическую интерпретацию из 
\begin_inset CommandInset citation
LatexCommand cite
key "ZobninGeneralization_ru"

\end_inset

.
\end_layout

\begin_layout Standard
Упрощение формулировки алгоритма, по сравнению с аналогами, повлекло значительно
е уменьшение времени на его написание и отладку на компьютере, как за счёт
 меньшего количества множеств, так и за счёт общего порядка 
\begin_inset Formula $<_{H}$
\end_inset

 для критериев отбрасывания и процедуры редукции.
 Простота реализации и нетребовательность к структурам данных позволяет
 за небольшое время внедрять эффективную версию алгоритма в любую систему
 компьютерной алгебры.
 Реализация, упоминаемая ниже, была создана автором за 8 часов, что на порядок
 меньше, чем время, затраченное автором на экспериментальные реализации
 других алгоритмов в подобных условиях.
 
\end_layout

\begin_layout Standard
Алгоритм был реализован на С++ с использованием функций ядра программного
 комплекса Singular 3-1-4 и открытых наработок Кристиана Эдера (одного из
 авторов 
\begin_inset CommandInset citation
LatexCommand cite
key "SignatureBasedGBs"

\end_inset

) по реализации F5-подобных алгоритмов на этом ядре.
 Исходный код реализации содержится в функции ssg файла, доступного по адресу
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc"

\end_inset


\end_layout

\begin_layout Subsection
Одноэтапный вариант
\end_layout

\begin_layout Standard
В работе 
\begin_inset CommandInset citation
LatexCommand cite
key "Eder2012inhomogeneous"

\end_inset

 показано, что шаг большинства инкрементальных алгоритмов, основанных на
 сигнатурах, включая исходный F5, может быть легко модифицирован для использован
ия в виде одноэтапного алгоритма при использовании множества сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 и определённого порядка на нём, называемого порядком Schreyer.
 Однако, поскольку данный порядок не исчерпывает все возможные согласованные
 порядки на сигнатурах, мы сформулируем одноэтапную версию алгоритма для
 произвольного порядка 
\begin_inset Formula $\prec_{a}$
\end_inset

 на 
\begin_inset Formula $\mathbf{T}$
\end_inset

, согласованного с порядком на мономах, и покажем её корректность.
 Конкретные порядки будут рассмотрены позже.
 Как и в случае инкрементального алгоритма случаи, когда среди входных многочлен
ов 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 есть элемент из 
\begin_inset Formula $\mathcal{K}$
\end_inset

, не представляют интереса: если он ненулевой, то 
\begin_inset Formula $\left(f_{1},\ldots,f_{m}\right)=\left(1\right)=\mathcal{P}$
\end_inset

, а если нулевой, то его можно выкинуть из входного множества без влияния
 на результат.
 Поэтому далее предполагается, что алгоритм применяется только при 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} \cap\mathcal{K}=\varnothing$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Псевдокод одноэтапного алгоритма 
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:SingleStepSignatureGroebner"

\end_inset


\family typewriter
SingleStepSignatureGroebner
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Вход: многочлены 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 с 
\begin_inset Formula $\HC(f_{i})=1$
\end_inset

,
\family default
 согласованный с мономиальным порядка 
\begin_inset Formula $\prec_{a}$
\end_inset

 на 
\begin_inset Formula $\mathbf{T}$
\end_inset

, индуцированный им частичный порядок 
\begin_inset Formula $<_{H}$
\end_inset

 на 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Переменные: 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 -- подмножества 
\begin_inset Formula $H$
\end_inset

, 
\begin_inset Formula $(\sigma,p')\in H$
\end_inset

 -- отмеченный многочлен текущего шага до редукции, 
\begin_inset Formula $(\sigma,p)$
\end_inset

 -- он же после редукции, 
\begin_inset Formula $r,b$
\end_inset

 -- элементы 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
Результат: базис Грёбнера идеала 
\begin_inset Formula $I=\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\cup_{1\leqslant i<j\leqslant m}\left\{ \left(\max_{\prec_{a}}\left(\left(\HM(f_{i}),j\right),\left(\HM(f_{j}),i\right)\right),0\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{((1,1),f_{1}),((1,2),f_{2}),\dots,((1,m),f_{m})\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $B\neq\varnothing$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\sigma,p')\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec_{a}$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-sigma-from-B-sstep"

\end_inset


\series bold
if
\series default
 
\begin_inset Formula $\sigma=\left(1,\sigidx\left(\sigma\right)\right)$
\end_inset


\series bold
:
\series default

\begin_inset Formula $B\leftarrow B\setminus\{b\in B,\Sig(b)=\sigma\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-before-reduce-sstep"

\end_inset


\begin_inset Formula $p\leftarrow$
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

((
\begin_inset Formula $\sigma,p'),R$
\end_inset

)
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-after-reduce-sstep"

\end_inset


\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
if
\series default
 
\begin_inset Formula $p\not=0$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:-remove-from-B-sstep"

\end_inset

 
\begin_inset Formula $B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\Sig(r)|\Sig(b)\}$
\end_inset

, где под делимостью сигнатур подразумевается делимость определённая для
 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)\,|\, r\in R,\poly(r)\ne0\}$
\end_inset


\end_layout

\begin_layout Standard

\series medium
Код процедуры 
\series default

\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset


\series medium
 не меняется по сравнению с инкрементальной версией и выполняется для отмеченных
 многочленов с сигнатурами из 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
\end_layout

\begin_layout Standard
Как и алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

, представленная версия алгоритма оказывается похожей на несколько известных
 алгоритмов.
 Алгоритм GVW описан в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

 похожим псевдокодом, но имеет принципиальное отличие в работе: обобщённый
 критерий отбрасывания шага 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:-remove-from-B-sstep"

\end_inset

, учитывающий делимость сигнатур, применяется там лишь для многочленов редуциров
авшихся к нулю, в то время как для остальных многочленов GVW применяет более
 слабый критерий на шаге 3b.iii, не гарантирующий получение минимального
 S-базиса.
 Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "TheF5Revised"

\end_inset

 содержит неименованный 
\begin_inset Quotes fld
\end_inset

алгоритм 6
\begin_inset Quotes frd
\end_inset

, псевдокод которого также очень похож на приведённый.
 Его отличие с вычислительной точки зрения в состоит в том что 
\begin_inset Quotes fld
\end_inset

алгоритм 6
\begin_inset Quotes frd
\end_inset

 производит вычисление старших мономов S-многочленов до применения критериев.
 Это зачастую приводит к лишним вычислениям, поскольку вычисление старшего
 монома линейной комбинации многочленов, в случае сокращения мономов, может
 оказаться также трудоёмко, как полное вычисление линейной комбинации, а
 результат этого вычисления алгоритм может отбросить по критериям.
\end_layout

\begin_layout Standard
С другой стороны, алгоритмы TRB-MJ и SB, описанные в
\begin_inset CommandInset citation
LatexCommand cite
key "HuangConception,PracticalGB"

\end_inset

, псевдокод которых формулируется менее похожим образом, по сути производят
 вычисления, совпадающие с вычислениями алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, и также дают минимальный S-базис в качестве результата.
 Отличие приведённого здесь алгоритма проявляется не с точки зрения сложности
 вычислений, а сточки зрения обоснования -- унифицированная формулировка
 критерия отбрасывания на шаге 
\begin_inset CommandInset ref
LatexCommand nameref
reference "enu:-remove-from-B-sstep"

\end_inset

 приводит к упрощению доказательства.
\end_layout

\begin_layout Lemma
Все пары из 
\begin_inset Formula $\mathbf{T}\times\mathcal{P}$
\end_inset

 в алгоритме -- отмеченные многочлены.
 При этом, среди элементов 
\begin_inset Formula $R$
\end_inset

 до первого выполнения шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 нет элементов с единичным мономом сигнатуры.
\end_layout

\begin_layout Proof
Элементы, формирующие 
\begin_inset Formula $R$
\end_inset

 и 
\begin_inset Formula $B$
\end_inset

 до начала главного цикла, являются рассмотренными в примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:labeled-polys"

\end_inset

 отмеченными многочленами.
 Все остальные отмеченные многочлены в алгоритме формируются или умножением
 на 
\begin_inset Formula $t\in\mathbb{T}$
\end_inset

 или редукцией с сохранением сигнатуры, поэтому они корректны и лежат в
 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Proof
Мономы сигнатуры элементов 
\begin_inset Formula $R$
\end_inset

 до шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 являются старшими мономами одного из исходных многочленов, и не являются
 единичными, поскольку 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} \cap\mathcal{K}=\varnothing$
\end_inset

.
\end_layout

\begin_layout Standard
Доказательства корректности и остановки основаны на той же схеме, что и
 доказательства для шага инкрементального алгоритма, однако сильно отличаются
 в деталях, поэтому приведём изменившиеся утверждения.
\end_layout

\begin_layout Subsubsection
Остановка
\end_layout

\begin_layout Standard
В отличии от леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor"

\end_inset

 в одноэтапном алгоритме возможность редукции утверждается лишь для многочленов
 с отличными от единицы мономами сигнатуры.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:exist-reductor-not1-sstep"

\end_inset

В любой момент работы алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, любой отмеченный многочлен из 
\begin_inset Formula $B$
\end_inset

, моном сигнатуры которого не равен 1, может быть редуцирован с сохранением
 сигнатуры по некоторому элементу 
\begin_inset Formula $R.$
\end_inset


\end_layout

\begin_layout Proof
Отмеченные многочлены c не равным 1 мономом сигнатуры добавляются в 
\begin_inset Formula $B$
\end_inset

 таким образом, чтобы иметь хотя бы один подходящий редуктор.
 
\begin_inset Formula $(\sigma,p)\in R$
\end_inset

 является таким редуктором при добавлении в первом цикле 
\series bold
for
\series default
, 
\begin_inset Formula $r\in R$
\end_inset

 -- во втором.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-small-sstep"

\end_inset

До редукции многочлена 
\begin_inset Formula $p'$
\end_inset

, то есть на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-before-reduce-sstep"

\end_inset

 любой итерации алгоритма, сигнатуры элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $
\end_inset

 не делят 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
На первой итерации алгоритма это выполняется, поскольку все мономы сигнатур
 равны 1, а все элементы 
\begin_inset Formula $R$
\end_inset

 имеют сигнатуры не равные 1.
 На последующих итерациях это выполнено, поскольку, если бы в 
\begin_inset Formula $R$
\end_inset

 существовали такие элементы, то 
\begin_inset Formula $\left(\sigma,p'\right)$
\end_inset

 был бы убран из 
\begin_inset Formula $B$
\end_inset

 в предыдущей итерации на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:r-gvw-big-sstep"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 любой итерации алгоритма, старшие мономы элементов 
\begin_inset Formula $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $
\end_inset

 не делят 
\begin_inset Formula $\HM(p)$
\end_inset

.
\end_layout

\begin_layout Proof
Полностью идентично лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big"

\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:adds-really-new-sstep"

\end_inset

После редукции многочлена 
\begin_inset Formula $p'$
\end_inset

 до 
\begin_inset Formula $p$
\end_inset

, на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 любой итерации алгоритма, элементы 
\begin_inset Formula $R$
\end_inset

 не могут одновременно иметь старшие мономы, делящие 
\begin_inset Formula $\HM(p)$
\end_inset

, и сигнатуры, делящие 
\begin_inset Formula $\sigma$
\end_inset

.
\end_layout

\begin_layout Proof
Для элементов с мономом сигнатуры, отличным от 1, В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:exist-reductor-not1-sstep"

\end_inset

 будет произведена хотя бы одна редукция 
\begin_inset Formula $p'$
\end_inset

, поэтому 
\begin_inset Formula $(\sigma,p')\GVWg(\sigma,p)$
\end_inset

.
 Отсюда по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:greater-or-smaller"

\end_inset

 для 
\begin_inset Formula $\forall r\in R$
\end_inset

 имеем 
\begin_inset Formula $r\GVWg(\sigma,p)$
\end_inset

 или 
\begin_inset Formula $r\GVWl(\sigma,p')$
\end_inset

.
 Выполнение одного из неравенств позволяет применить одну из лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-small-sstep"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:r-gvw-big-sstep"

\end_inset

.
\end_layout

\begin_layout Proof
Для элементов с мономом сигнатуры 1 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce"

\end_inset

 в 
\begin_inset Formula $R$
\end_inset

 не может быть делящих сигнатуру элементов, поскольку все элементы, добавленные
 изначально, имеют не равные 1 мономы сигнатуры, а среди добавляемых позже
 элементов 
\begin_inset Formula $\left(\sigma,p\right)=\left(\left(1,\sigidx(\sigma)\right),p\right)$
\end_inset

 -- это первый элемент с индексом 
\begin_inset Formula $\sigidx(\sigma)$
\end_inset

, который не может иметь делителей сигнатуры.
 Повторное добавление элемента с сигнатурой 
\begin_inset Formula $\left(1,\sigidx(\sigma)\right)$
\end_inset

невозможно, поскольку такие элементы явно удаляются из 
\begin_inset Formula $B$
\end_inset

 сразу после извлечения на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-sigma-from-B-sstep"

\end_inset

, и никогда не добавляются позднее.
\end_layout

\begin_layout Theorem
Алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 останавливается
\end_layout

\begin_layout Proof
Для доказательства остановки нужно показать, что все циклы 
\series bold
do
\series default
 выполняются лишь конечное число раз.
 Остановка 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 показана в доказательстве теоремы 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:SSG-stop"

\end_inset

.
 На каждом шаге основного цикла 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 пополняется множество 
\begin_inset Formula $R\subset P=\mathbf{T}\times\mathcal{P}$
\end_inset

.
 Оно может быть разбито как 
\begin_inset Formula 
\[
\bigcup_{i=1,\dots,m}R_{i0}\cup R_{i*},
\]

\end_inset

 где 
\begin_inset Formula $R_{i0}\subset\left\{ (\sigma,i),\sigma\in\mathbb{T}\right\} \times\left\{ 0\right\} ,R_{i*}\subset\left\{ (\sigma,i),\sigma\in\mathbb{T}\right\} \times\mathcal{P}\setminus\left\{ 0\right\} $
\end_inset

.
 Для 
\begin_inset Formula $R_{i0}$
\end_inset

 и 
\begin_inset Formula $R_{i*}$
\end_inset

 применим подход, аналогичный теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:SSG-stop"

\end_inset

.
 Рассмотрим следующие множества, являющиеся идеалами моноидов: 
\begin_inset Formula $L_{i0}=\left(\left\{ \sigma\,|\,((\sigma,i),0)\in R_{i0}\right\} \right)\subset\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $L_{i*}=\left(\left\{ (\sigma,t)\,|\,\exists((\sigma,i),p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$
\end_inset

.
 В силу леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:adds-really-new-sstep"

\end_inset

 добавляемые в 
\begin_inset Formula $R$
\end_inset

 элементы расширяют на каждом шаге одно из 
\begin_inset Formula $L_{i0}$
\end_inset

 или 
\begin_inset Formula $L_{i*}$
\end_inset

.
 Поскольку моноиды 
\begin_inset Formula $\mathbb{T}$
\end_inset

 и 
\begin_inset Formula $\mathbb{T}\times\mathbb{T}$
\end_inset

 изоморфны 
\begin_inset Formula $\mathbb{N}^{n}$
\end_inset

 и 
\begin_inset Formula $\mathbb{N}^{2n}$
\end_inset

, к их идеалам может быть применена лемма Диксона, которая и утверждает,
 что расширение может происходить лишь конечное число раз.
\end_layout

\begin_layout Subsubsection
Корректность
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:exist-r-sigma-sstep"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

 выполнен инвариант: для 
\begin_inset Formula $\forall\sigma\in\mathbf{T},\sigma\prec_{a}$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, найдутся 
\begin_inset Formula $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\Sig(t_{\sigma}r_{\sigma})=\sigma$
\end_inset

 и 
\begin_inset Formula $t_{\sigma}r_{\sigma}$
\end_inset

 не редуцируется сигнатурно по 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
До начала итераций множество 
\begin_inset Formula $B$
\end_inset

 содержит элементы с сигнатурой 
\begin_inset Formula $\left(1,i\right)$
\end_inset

 для всех индексов сигнатуры 
\begin_inset Formula $i=1,\dots,m$
\end_inset

.
 В процессе работы алгоритма элемент c сигнатурой 
\begin_inset Formula $\left(1,i\right)$
\end_inset

 не может быть удалён из 
\begin_inset Formula $B$
\end_inset

 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

, поскольку 
\begin_inset Formula $R$
\end_inset

 изначально не содержит элементов с единичной сигнатурой, а для исключения
 такого элемента нужен элемент 
\begin_inset Formula $R$
\end_inset

 с такой же сигнатурой.
 Когда какой-то из элементов с сигнатурой 
\begin_inset Formula $\left(1,i\right)$
\end_inset

 исключается на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-sigma-from-B-sstep"

\end_inset

, то после этого производится его редукция и сохранение в 
\begin_inset Formula $R$
\end_inset

.
 Таким образом получается, что если 
\begin_inset Formula $\sigma\prec_{a}$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, то в 
\begin_inset Formula $R$
\end_inset

 есть элемент 
\begin_inset Formula $r_{0}$
\end_inset

 с 
\begin_inset Formula $\Sig(r_{0})=\left(1,\sigidx(\sigma)\right)$
\end_inset

 и можно утверждать что множество 
\begin_inset Formula $R_{\sigma}=\left\{ r\in R\,|\,\Sig(r)|\sigma\right\} $
\end_inset

 непусто, так как содержит элемент 
\begin_inset Formula $r_{0}$
\end_inset

.
\end_layout

\begin_layout Proof
Дальнейшее доказательство совпадает с окончанием доказательства теоремы
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:exist-r-sigma"

\end_inset

 с дополнением о том, что на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-sigma-from-B-sstep"

\end_inset

 отбрасываются только элементы, добавленные в 
\begin_inset Formula $B$
\end_inset

 при инициализации, а элементы, добавленные позже, могут быть удалены только
 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:has-s-repr-sstep"

\end_inset

На каждой итерации алгоритма после шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-remove-from-B-sstep"

\end_inset

 выполнен инвариант: 
\begin_inset Formula $\forall h\in H,\Sig(h)\prec$
\end_inset

 сигнатур элементов 
\begin_inset Formula $B$
\end_inset

, имеет сигнатурное представление над 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Proof
Предположим нарушение инварианта на какой-то итерации и рассмотрим 
\begin_inset Formula $\prec_{a}$
\end_inset

-минимальную 
\begin_inset Formula $\sigma$
\end_inset

, для которой непусто 
\begin_inset Formula $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\Sig(h)=\sigma\}$
\end_inset

.
 Тогда 
\begin_inset Formula $R$
\end_inset

 -- S
\emph on

\begin_inset Formula $_{\sigma}$
\end_inset


\emph default
-базис.
 Из определения 
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $V_{\sigma}$
\end_inset

 вытекает, что многочленов с нулевым 
\begin_inset Formula $\HM$
\end_inset

 в нём нет.
 Выберем 
\begin_inset Formula $v_{\sigma}$
\end_inset

 -- один из элементов 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\prec$
\end_inset

-наименьшим 
\begin_inset Formula $\HM$
\end_inset

.
 Он не может быть редуцирован с сохранением сигнатуры по 
\begin_inset Formula $R$
\end_inset

, поскольку результат редукции 
\begin_inset Formula $v_{1}$
\end_inset

 был бы элементом 
\begin_inset Formula $V_{\sigma}$
\end_inset

 с 
\begin_inset Formula $\HM(v_{1})\prec\HM(v_{\sigma})$
\end_inset

.
\end_layout

\begin_layout Proof
Дальнейшее доказательство совпадает с окончанием доказательства теоремы
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr"

\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 возвращает базис Грёбнера
\end_layout

\begin_layout Proof
Доказательство полностью аналогично инкрементальному случаю: к моменту остановки
 
\begin_inset Formula $B=\varnothing$
\end_inset

, значит по теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:has-s-repr-sstep"

\end_inset

 
\begin_inset Formula $R$
\end_inset

 -- S-базис, а значит и базис Грёбнера.
\end_layout

\begin_layout Subsection
Взвешенные порядки
\end_layout

\begin_layout Standard
Формулировка алгоритма приведённая выше не фиксировала конкретный порядок
 
\begin_inset Formula $\prec_{a}$
\end_inset

 на 
\begin_inset Formula $\mathbf{T}$
\end_inset

, требуя от него лишь согласованность с мономиальным порядком.
 Определения и сравнение эффективности различных согласованных порядков
 можно найти в параграфе Term Orders работы
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

.
 Среди приведённых там порядков остановимся на двух: POT (position over
 term) и 
\series bold
g
\series default
2, называемом также порядком Schreyer 
\begin_inset CommandInset citation
LatexCommand cite
key "Eder2012inhomogeneous"

\end_inset

.
\end_layout

\begin_layout Standard
Порядок POT определён в начале этой работы как 
\begin_inset Formula $\prec_{P}$
\end_inset

 и является согласованным по лемме 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:precP_compatible"

\end_inset

.
 По сути, его использование превращает многие одноэтапные алгоритмы в инкремента
льные, поскольку следующий входной многочлен не рассматривается до тех пор,
 пока не завершится вычисление для предыдущих.
 Алгоритм GVW с порядком 
\begin_inset Formula $\prec_{P}$
\end_inset

 превращается в алгоритм G2V из 
\begin_inset CommandInset citation
LatexCommand cite
key "G2V"

\end_inset

, а 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с порядком 
\begin_inset Formula $\prec_{P}$
\end_inset

 даёт в точности алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

.
\end_layout

\begin_layout Standard
Для второго порядка понадобится формулировка в обобщённом виде:
\end_layout

\begin_layout Definition
Взвешенным порядком на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 для одноэтапного вычисления с 
\begin_inset Formula $m$
\end_inset

 входными многочленами называется порядок 
\begin_inset Formula $\prec_{w}$
\end_inset

 с параметром 
\begin_inset Formula $w=(w_{1},\dots,w_{m})\in\mathbb{T}^{m}$
\end_inset

, определяемый как
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\left(t_{1},i_{1}\right)\prec_{w}\left(t_{2},i_{2}\right)\Longleftrightarrow\left[\begin{aligned} & t_{1}w_{i_{1}}\prec t_{2}w_{i_{2}}\\
 & t_{1}w_{i_{1}}=t_{2}w_{i_{2}},i{}_{1}<i_{2}
\end{aligned}
\right..
\]

\end_inset


\end_layout

\begin_layout Lemma
Взвешенный порядок с любым значением параметра является согласованным с
 мономиальным порядком 
\begin_inset Formula $\prec$
\end_inset


\end_layout

\begin_layout Proof
Пусть 
\begin_inset Formula $\sigma=(s,i)\in\mathbf{T}$
\end_inset

.
 Тогда 
\begin_inset Formula 
\[
t_{1}\sigma\prec_{w}t_{2}\sigma\Longleftrightarrow\left(t_{1}s,i\right)\prec_{w}\left(t_{2}s,i\right)\Longleftrightarrow t_{1}sw_{i}\prec t_{2}sw_{i}\Longleftrightarrow t_{1}\prec t_{2}
\]

\end_inset


\end_layout

\begin_layout Definition
Порядком Schreyer на множестве сигнатур 
\begin_inset Formula $\mathbf{T}$
\end_inset

 для одноэтапного вычисления с входными многочленами 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 называется взвешенный порядок 
\begin_inset Formula $\prec_{w}$
\end_inset

 со значением параметра 
\begin_inset Formula $w=(\HM(f_{1}),\dots,\HM(f_{m}))$
\end_inset

.
 Этот порядок будем обозначать как 
\begin_inset Formula $\prec_{S}$
\end_inset

.
\end_layout

\begin_layout Standard
Эмпирические эксперименты в 
\begin_inset CommandInset citation
LatexCommand cite
key "GVW"

\end_inset

 показали, что одноэтапные алгоритмы вычислений базисов Грёбнера с порядком
 
\begin_inset Formula $\prec_{s}$
\end_inset

 в среднем оказываются, как минимум, не менее эффективными, чем вычисления
 с другими известными порядками на сигнатурах, совместимыми с порядком на
 мономах.
 Поэтому в качестве базового алгоритма вычисления базиса Грёбнера в следующей
 части будет рассматриваться алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с порядком 
\begin_inset Formula $\prec_{s}$
\end_inset

.
\end_layout

\begin_layout Part
Решение систем полиномиальных уравнений
\end_layout

\begin_layout Section
Системы уравнений и методы их решения
\end_layout

\begin_layout Standard
Задачи решения систем уравнений, образованных многочленами 
\begin_inset Formula $f_{1},\ldots,f_{m}$
\end_inset

 из кольца
\begin_inset Formula $\mathcal{P}=\mathcal{K}\left[x_{1},\dots,x_{n}\right]$
\end_inset

, возникают в различных областях науки, в частности криптографии и алгоритмах
 компьютерного зрения.
 Для решения таких систем могут применяться общие методы решения систем
 уравнений заданных аналитическими функциями, в частности итерационные методы.
 Такие методы не всегда позволяют найти все решения рассматриваемой системы.
 Однако тот факт, что уравнения заданы многочленами, позволяет применять
 специализированные методы решения систем полиномиальных уравнений.
\end_layout

\begin_layout Standard
Наиболее простым методом этого типа является метод, основанный на вычислении
 базиса Грёбнера относительно лексикографического порядка на мономах с последующ
им последовательным исключением переменных путём решения одномерных задач.
 Этот метод рассматривается в книге 
\begin_inset CommandInset citation
LatexCommand cite
key "UsingAlgebraicGeometry"

\end_inset

 (глава 2 §1).
 Его недостатком является необходимость вычислять базис Грёбнера именно
 относительно лексикографического порядка, что может оказаться значительно
 более трудоёмкой задачей, нежели вычисление с другими мономиальными порядками.
\end_layout

\begin_layout Standard
Другой метод решения применим для случая систем с конечным числом решений
 и основан на собственных векторах линейного оператора в векторном пространстве
 
\begin_inset Formula $\mathcal{A}=\mathcal{P}/\left(f_{1},\ldots,f_{m}\right)$
\end_inset

, задаваемого матрицей действий умножением, называемой также просто матрицей
 действий.
 Данный метод описывается и доказывается в книге 
\begin_inset CommandInset citation
LatexCommand cite
key "UsingAlgebraicGeometry"

\end_inset

 (Предложение 4.7 главы 2).
 Поскольку наиболее важным для дальнейших рассуждений является взаимодействие
 данного метода с алгоритмами базисов Грёбнера, опишем схему метода и порядок
 применения базисов в нём, но не будем повторять его обоснование.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:action-matrix-method"

\end_inset

Метод матриц действия
\end_layout

\begin_layout Enumerate
Рассматривается идеал 
\begin_inset Formula $I=\left(f_{1},\ldots,f_{m}\right)$
\end_inset

, находится набор образующих радикала 
\begin_inset Formula $I'=\sqrt{I}$
\end_inset

 с использованием метода описанного в параграфе 2 той же главы 
\begin_inset CommandInset citation
LatexCommand cite
key "UsingAlgebraicGeometry"

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:use-basis-for-radical"

\end_inset

определяется некоторый конечный базис 
\begin_inset Formula $D$
\end_inset

 в линейном пространстве 
\begin_inset Formula $\mathcal{A}=\mathcal{P}/I$
\end_inset

 и находится оператор нормальной формы 
\begin_inset Formula $N_{D}$
\end_inset

, позволяющий для любого элемента 
\begin_inset Formula $\mathcal{P}$
\end_inset

 находить его 
\begin_inset Formula $D$
\end_inset

-координаты.
 Как правило, для нахождения такого базиса и оператора используются методы,
 связанные с базисами Грёбнера.
 
\end_layout

\begin_layout Enumerate
если конечный базис построить не удалось, алгоритм завершается, поскольку
 является применимым лишь для систем с конечным числом решений, дающим нульмерны
е идеалы.
\end_layout

\begin_layout Enumerate
для каждой из переменных 
\begin_inset Formula $x_{i}$
\end_inset

 при помощи оператора 
\begin_inset Formula $N_{D}$
\end_inset

 находится линейная зависимость в 
\begin_inset Formula $\mathcal{A}$
\end_inset

 среди различных степеней этой переменной
\end_layout

\begin_layout Enumerate
строится минимальный многочлен 
\begin_inset Formula $m_{i}\in I\cup\mathcal{K}\left[x_{i}\right]$
\end_inset

, соответствующей найденной линейной зависимости
\end_layout

\begin_layout Enumerate
для многочленов от одной переменной определяются генераторы радикалов 
\begin_inset Formula $\left(r_{i}\right)=\sqrt{\left(m_{i}\right)}$
\end_inset


\end_layout

\begin_layout Enumerate
идеал 
\begin_inset Formula $I'$
\end_inset

 задаётся как 
\begin_inset Formula $I\cup\left\{ r_{1},\dots,r_{n}\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Вычисляется матрица 
\begin_inset Formula $m_{F}$
\end_inset

 линейного оператора в линейном пространстве 
\begin_inset Formula $\mathcal{A}'=\mathcal{P}/I'$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:use-basis-for-matrix"

\end_inset

 фиксируется некоторый базис 
\begin_inset Formula $B=\left\{ b_{1},\dots,b_{l}\right\} \subset\mathcal{A}'$
\end_inset

 и находится оператор нормальной формы 
\begin_inset Formula $N_{B}:\mathcal{P}\rightarrow\mathcal{K}^{l}$
\end_inset

, позволяющий по любому многочлену из 
\begin_inset Formula $\mathcal{P}$
\end_inset

 находить коэффициенты соответствующего ему элемента 
\begin_inset Formula $\mathcal{A}$
\end_inset

 в базисе 
\begin_inset Formula $B$
\end_inset

.
 Этот шаг отличается от шага 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:use-basis-for-radical"

\end_inset

только рассматриваемым идеалом и также обычно использует методы, связанные
 с базисами Грёбнера.
 
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:selecting-ci"

\end_inset

выбирается произвольный набор ненулевых случайных констант 
\begin_inset Formula $c_{1},\dots,c_{n}\in\mathcal{K}$
\end_inset


\end_layout

\begin_layout Enumerate
рассматривается оператор умножения на многочлен 
\begin_inset Formula $F=\sum_{i=1}^{n}c_{i}x_{i}\in\mathcal{P}$
\end_inset

 как линейный оператор в 
\begin_inset Formula $\mathcal{A}'$
\end_inset


\end_layout

\begin_layout Enumerate
строится матрица этого оператора 
\begin_inset Formula $m_{F}$
\end_inset

, являющаяся 
\begin_inset Formula $l\times l$
\end_inset

 матрицей с элементами из 
\begin_inset Formula $\mathcal{K}$
\end_inset

.
 При этом 
\begin_inset Formula $N_{B}$
\end_inset

 используется для вычисления нормальной формы многочлена, являющейся однозначным
 представителем класса в 
\begin_inset Formula $\mathcal{A}'$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Находится 
\begin_inset Formula $l$
\end_inset

 различных собственных векторов матрицы 
\begin_inset Formula $m_{F}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
при помощи метода поиска собственных значений матрицы в поле 
\begin_inset Formula $\mathcal{K}$
\end_inset

, определяются собственные значения матрицы 
\begin_inset Formula $m_{F}$
\end_inset


\end_layout

\begin_layout Enumerate
если число различных собственных значений оказывается меньше 
\begin_inset Formula $l$
\end_inset

, выполняется возврат к шагу 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:selecting-ci"

\end_inset

, где выбираются другие случайные константы.
 На практике возникновение такой ситуации крайне маловероятно.
\end_layout

\begin_layout Enumerate
путём решения системы линейных уравнений над 
\begin_inset Formula $\mathcal{K}$
\end_inset

, находятся левые вектора-строки, отвечающие собственным значениям
\end_layout

\end_deeper
\begin_layout Enumerate
Находятся значения 
\begin_inset Formula $x_{1},\dots,x_{n}$
\end_inset

, соответствующие каждому собственному вектору
\end_layout

\begin_deeper
\begin_layout Enumerate
значения собственного вектора трактуются как значения базисных элементов
 
\begin_inset Formula $b_{1},\dots,b_{l}$
\end_inset

 в точке, являющейся решением исходной системы.
\end_layout

\begin_layout Enumerate
для каждого 
\begin_inset Formula $x_{j}$
\end_inset

 при помощи 
\begin_inset Formula $N_{B}$
\end_inset

 находится 
\begin_inset Formula $B$
\end_inset

-координаты 
\begin_inset Formula $x_{j1},\dots,x_{jl}$
\end_inset


\end_layout

\begin_layout Enumerate
для каждого собственного вектора значение 
\begin_inset Formula $x_{j}$
\end_inset

 находится как 
\begin_inset Formula $x_{j}=\sum_{i}x_{ji}b_{i}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Приведённому алгоритму необходим базис фактор-пространства и оператор нормальной
 формы на шагах 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:use-basis-for-matrix"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:use-basis-for-radical"

\end_inset

, и это единственное для чего в алгоритме может быть использован базис Грёбнера.
 Поэтому описанный алгоритм не накладывает никакого ограничения на мономиальный
 порядок, относительно которого считается базис Грёбнера.
 Также допустимо использование 
\emph on
краевого базиса
\emph default
, строгое определение которого даётся в 
\begin_inset CommandInset citation
LatexCommand cite
key "NumericalPolynomialAlgebra"

\end_inset

, и который является более общим понятием по сравнению с базисом Грёбнера.
 Работы 
\begin_inset CommandInset citation
LatexCommand cite
key "FastStablePolySolving,ComputingBorderBases"

\end_inset

 предлагают различные алгоритмы его вычисления, в частности оптимизированные
 для численных задач, однако эти алгоритмы не используют сигнатурных методов,
 показавших свою эффективность при вычислении базисов Грёбнера.
 
\end_layout

\begin_layout Section
Задачи с приближёнными входными данными
\end_layout

\begin_layout Standard
Если вычисление проходит в 
\begin_inset Formula $\mathcal{K}=\mathbb{C}$
\end_inset

, входные данные могут быть заданы с некоторой погрешностью.
 Определим приближённую систему, а также введём понятие её специализации,
 аналогичное предложенному в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "ArtificialDiscontinuities"

\end_inset

.
\end_layout

\begin_layout Definition
Назовём 
\emph on
приближённым комплексным числом
\emph default
 пару 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

, где 
\begin_inset Formula $a\in\mathbb{C},0\leqslant\varepsilon\in\mathbb{R}$
\end_inset

.
 Элемент
\begin_inset Formula $a$
\end_inset

 будем называть приближением, а 
\begin_inset Formula $\varepsilon$
\end_inset

 -- радиусом вариации.
 Приближённое число 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

 будем также записывать как 
\begin_inset Formula $_{\varepsilon}a$
\end_inset

.
 Множество 
\begin_inset Formula $\left\{ a+e|e\in\mathbb{C},\left|e\right|\leqslant\varepsilon\right\} \subset\mathbb{C}$
\end_inset

 называется 
\emph on
множеством специализаций
\emph default
 приближённого комплексного числа.
 Множество приближённых комплексных чисел будет обозначаться 
\begin_inset Formula $\tilde{\mathbb{C}}$
\end_inset

.
 Формальный многочлен с такими коэффициентами называется 
\emph on
приближённым многочленом
\emph default
 над 
\begin_inset Formula $\mathbb{C}$
\end_inset

.
 Многочлены, получаемые подстановкой коэффициентов из множества вариаций,
 называются 
\emph on
специализациями приближённого многочлена
\emph default
.
 Аналогично определяется 
\emph on
приближённая система полиномиальных уравнений
\emph default
 и 
\emph on
специализации системы
\emph default
.
\end_layout

\begin_layout Standard
Множество специализаций системы изоморфно декартову произведению конечного
 числа множеств специализаций коэффициентов и является топологическим пространст
вом.
 Далее множество специализаций будет обозначаться за 
\begin_inset Formula $E$
\end_inset

.
 Точно известные 
\begin_inset Formula $\mathbb{C}$
\end_inset

-коэффициенты 
\begin_inset Formula $_{0}a$
\end_inset

 будут записываться просто как 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
Обозначим множество всех конечных наборов элементов 
\begin_inset Formula $\mathbb{C}^{n}$
\end_inset

 за 
\begin_inset Formula $D$
\end_inset

.
 На множестве 
\begin_inset Formula $D$
\end_inset

 можно ввести структуру топологического пространства, основываясь на геометричес
кой топологии 
\begin_inset Formula $\mathbb{C}^{n}$
\end_inset

: подмножество 
\begin_inset Formula $D'\subset D$
\end_inset

 входит в базу топологии 
\begin_inset Formula $D$
\end_inset

, если 
\begin_inset Formula $\exists d'\subset\mathbb{C}^{n}$
\end_inset

, являющееся открытым, такое что, 
\begin_inset Formula $d\in D'\Longleftrightarrow$
\end_inset

 все элементы 
\begin_inset Formula $d$
\end_inset

 лежат в 
\begin_inset Formula $d'$
\end_inset

.
\end_layout

\begin_layout Definition
Система уравнений, заданная набором приближённых многочленов, называется
 
\emph on
системой с конечным непрерывным решением,
\emph default
 если множество решений любой её специализации является конечным набором
 элементов 
\begin_inset Formula $\mathbb{C}^{n}$
\end_inset

, содержащим не более 
\begin_inset Formula $l$
\end_inset

 элементов, который представляется как ограниченная непрерывная функция.
 Ограниченность здесь подразумевает наличие шара, содержащего все решения
 всех специализаций.
 Непрерывность подразумевается как непрерывность функции из топологического
 пространства 
\begin_inset Formula $E$
\end_inset

 в топологическое пространство 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Example
С точки зрения приведённого определения уравнение 
\begin_inset Formula $x^{2}-p_{1}$
\end_inset

 будет являться системой с конечным непрерывным решением при любом приближённом
 числе 
\begin_inset Formula $p_{1}$
\end_inset

, поскольку отображение 
\begin_inset Formula $\sqrt{*}:E\rightarrow D$
\end_inset

, задаваемое комплексным корнем, в любой точке является непрерывным отображением
 с точки зрения введённой топологии в 
\begin_inset Formula $D$
\end_inset

.
 Заметим, что такую непрерывность нельзя интерпретировать как непрерывность
 вектор-функции 
\begin_inset Formula $E\rightarrow\mathbb{C}^{2}$
\end_inset

, задающей упорядоченный список двух возможно повторяющихся значений, так
 как комплексный корень можно бесконечным числом способов записать в виде
 функции 
\begin_inset Formula $E\rightarrow\mathbb{C}^{2}$
\end_inset

, но все они будут иметь точки разрыва в любой окрестности нуля.
 
\end_layout

\begin_layout Standard
Дадим примеры более сложных систем удовлетворяющих и не удовлетворяющих
 данному определению
\end_layout

\begin_layout Example
Рассмотрим систему
\begin_inset Formula 
\[
\left\{ \begin{array}{cc}
x^{2}y+x^{2}+x & =0\\
y^{2}-p_{1} & =0
\end{array}\right.,p_{1}=_{0,2}0,9\in E.
\]

\end_inset


\end_layout

\begin_layout Standard
Она допускает простое решение методом исключения переменных, позволяющее
 заключить, что она не является системой с конечным непрерывным решением.
 Это вытекает из того, что для специализаций 
\begin_inset Formula $P_{1}\in\mathbb{R},P_{1}\ne1$
\end_inset

 система имеет корень 
\begin_inset Formula 
\[
\left\{ \begin{array}{ccc}
y & = & -\sqrt{P_{1}}\\
x & = & \frac{1}{\sqrt{P_{1}}-1}
\end{array}\right.,
\]

\end_inset

который нельзя непрерывно продолжить при 
\begin_inset Formula $P_{1}=1$
\end_inset

, поскольку выражающая его функция не является ограниченной при 
\begin_inset Formula $P_{1}\rightarrow1$
\end_inset

.
 Эта же система с параметром 
\begin_inset Formula $p_{1}=_{0,2}0,7$
\end_inset

 или 
\begin_inset Formula $p_{1}=_{0,01}0,9$
\end_inset

 является системой с конечным непрерывным решением, поскольку все выражающие
 решения функции непрерывны.
 Значение параметра 
\begin_inset Formula $p_{1}=_{0,01}1$
\end_inset

 снова даёт отсутствие непрерывности решений.
\end_layout

\begin_layout Standard
Заметим, что отсутствие непрерывности функции решения происходит из-за обнуления
 старшего коэффициента уравнения, возникающего в процессе исключения переменных,
 приводящего к изменению степени и, как следствие, количества решений этого
 уравнения.
 Приведём ещё один пример подобной ситуации.
\end_layout

\begin_layout Example
Рассмотрим систему
\begin_inset Formula 
\[
\left\{ \begin{array}{cc}
xy+x & =0\\
y^{2}-p_{1} & =0
\end{array}\right.,p_{1}=_{0,2}0,9\in E.
\]

\end_inset


\end_layout

\begin_layout Standard
Она не является системой с конечным непрерывным решением, поскольку специализаци
я 
\begin_inset Formula $P_{1}=1$
\end_inset

 даёт бесконечное множество решений вида 
\begin_inset Formula $\left(x_{1},-1\right),x_{1}\in\mathbb{C}$
\end_inset

.
 Это также вызвано изменением степени возникающего при решении многочлена,
 в котором обнуляется единственный ненулевой моном.
\end_layout

\begin_layout Standard
С другой стороны, если при изменении специализации исчезает моном, не являющийся
 мономом с наибольшей степенью, решение остаётся непрерывным.
\end_layout

\begin_layout Example
Рассмотрим систему с двумя приближёнными числами 
\begin_inset Formula $p_{1},p_{2}\in E$
\end_inset

.
 
\begin_inset Formula 
\[
\left\{ \begin{array}{cc}
x^{2}+xy+p_{2} & =0\\
y^{2}-p_{1} & =0
\end{array}\right..
\]

\end_inset


\end_layout

\begin_layout Standard
Она является системой с конечным непрерывным решением, поскольку при любых
 выбранных приближённых числах 
\begin_inset Formula $p_{1},p_{2}$
\end_inset

 решения системы будут выражаться на всём множестве специализаций одними
 и теми же формулами, дающими решения квадратных уравнений с единичным старшим
 коэффициентом, которые являются непрерывными отображениями 
\begin_inset Formula $E\rightarrow D$
\end_inset

.
 В силу определения топологии на 
\begin_inset Formula $D$
\end_inset

, непрерывность сохраняется и в точке, где специализации обоих параметров
 равны нулю и единственным решением системы является точка 
\begin_inset Formula $\left(0,0\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Теперь можно сформулировать наиболее общую постановку задачи, методики решения
 которой будут рассматриваться далее:
\end_layout

\begin_layout Problem
\begin_inset CommandInset label
LatexCommand label
name "problem:approx-poly-system"

\end_inset

Для заданной над 
\begin_inset Formula $\mathbb{C}$
\end_inset

 приближённой системы уравнений 
\begin_inset Formula $\left\{ f_{1}=0,\ldots,f_{m}=0\right\} $
\end_inset

 определить, является ли она системой с конечным непрерывным решением, и
 если является -- найти решение -- набор 
\begin_inset Formula $l$
\end_inset

 приближённых чисел в 
\begin_inset Formula $\mathbb{C}^{n}$
\end_inset

, такой что каждая специализация системы имеет решения, являющихся специализация
ми точек этого множества.
 Менее формально это можно выразить как задачу нахождения окрестностей в
 
\begin_inset Formula $\mathbb{C}^{n}$
\end_inset

, содержащих решения системы уравнений для всех специализаций.
 
\end_layout

\begin_layout Remark
Для применимости алгоритма решения такой задачи на практике, найденное множество
 должно быть достаточно малым, что можно сформулировать, например, следующим
 требованием: при стремлении к нулю радиуса вариаций всех входных параметров,
 радиус вариации получаемого ответа также должен стремиться к нулю.
\end_layout

\begin_layout Standard
При решении этой задачи с применением базиса Грёбнера необходимо решить
 проблему, возникающую в ситуации, когда выраженный приближённым числом
 старший коэффициент многочлена имеет ноль в качестве одной из своих специализац
ий, что делает невозможным обычное продолжение алгоритма, поскольку использовани
е такого многочлена в качестве редуктора невозможно.
 Большинство работ, посвящённых этой проблеме 
\begin_inset CommandInset citation
LatexCommand cite
key "NumericalComputationGB,NumericalComputationOfGBVarSubsttution,ArtificialDiscontinuities,GroebnerInExtFields"

\end_inset

, предлагают решения, связанные с расширением множества мономов 
\begin_inset Formula $\mathbb{T}$
\end_inset

.
 Однако, описываемые в них методы не допускают прозрачного применения к
 сигнатурным алгоритмам: после каждого расширения множества мономов требуется
 перезапуск алгоритмов, во многом повторяющий уже проведённые вычисления.
\end_layout

\begin_layout Standard
В данной работе будет предложена модификация алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, позволяющая расширять идеал на ходу вычислений, не требуя полного перезапуска
 алгоритма.
 
\end_layout

\begin_layout Section
Проблемы применения алгоритмов Базиса Грёбнера в интервальной арифметике
\end_layout

\begin_layout Standard
Одним из способов решения задачи с приближёнными комплексными числами является
 применение алгоритма базиса Грёбнера к многочленам непосредственно в интервальн
ой записи.
 Опишем подробнее этот процесс.
 Прежде всего определим какой смысл должны иметь приближённые многочлены,
 получаемые в процессе вычислений.
 При вычислении базиса Грёбнера над полем, про каждый промежуточный многочлен
 
\begin_inset Formula $p$
\end_inset

 известно, что он лежит в идеале, порождаемом входными многочленами.
 В случае приближённых чисел будем требовать выполнения более слабого инварианта.
 
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "needed-poly-prop"

\end_inset

Пусть 
\begin_inset Formula $p$
\end_inset

 -- промежуточный приближённый многочлен в вычислении базиса Грёбнера, а
 
\begin_inset Formula $I'$
\end_inset

 -- идеал порождаемый некоторой специализацией входных данных.
 Тогда существует специализация 
\begin_inset Formula $p$
\end_inset

, лежащая в 
\begin_inset Formula $I'$
\end_inset

.
 Обратное выполняться не обязано -- могут существовать специализации 
\begin_inset Formula $p$
\end_inset

, не соответствующие ни одной из специализаций входных данных.
\end_layout

\begin_layout Standard
Применяя данное свойство к выданному алгоритмом ответу -- набору нормализованных
 многочленов -- мы получим, что для любой специализации входных данных существуе
т специализация каждого из многочленов набора, лежащая в соответствующем
 идеале 
\begin_inset Formula $I'$
\end_inset

.
 Свойство набора быть базисом Грёбнера не зависит от коэффициентов, поэтому
 оно будет выполняться для всех специализаций при том условии, что структура
 идеала мономов, порождаемого старшими мономами 
\begin_inset Formula $I'$
\end_inset

 остаётся неизменной для всех специализаций.
 К вопросу о том, при каких условиях получаемая специализация набора является
 базисом Грёбнера мы вернёмся позже, а сейчас определим операции над приближённы
ми многочленами так, чтоб выполнялся инвариант и таким образом получаемая
 специализация лежала в идеале.
\end_layout

\begin_layout Definition
Арифметические операции над приближёнными числами определяются следующим
 образом:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Сложение 
\begin_inset Formula $(a_{1},\varepsilon_{1})+(a_{2},\varepsilon_{2})=(a_{1}+a_{2},\varepsilon_{1}+\varepsilon_{2})$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Умножение 
\begin_inset Formula $(a_{1},\varepsilon_{1})\times(a_{2},\varepsilon_{2})=(a_{1}a_{2},\varepsilon_{1}\left|a_{2}\right|+\varepsilon_{2}\left|a_{1}\right|+\varepsilon_{1}\varepsilon_{2})$
\end_inset

, в частности 
\begin_inset Formula $(a_{1},\varepsilon_{1})\times(a_{2},0)=(a_{1}a_{2},\varepsilon_{1}\left|a_{2}\right|)$
\end_inset


\end_layout

\begin_layout Standard
Вычитание получается на основе сложения и умножения на 
\begin_inset Formula $-1$
\end_inset

:
\begin_inset Formula 
\[
(a_{1},\varepsilon_{1})-(a_{2},\varepsilon_{2})=(a_{1},\varepsilon_{1})+((a_{2},\varepsilon_{2})\times_{0}-1)=(a_{1}-a_{2},\varepsilon_{1}+\varepsilon_{2})
\]

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Обращение определяется только для приближённых чисел, для которых 0 не является
 специализацией, что эквивалентно 
\begin_inset Formula $\left|a\right|-\varepsilon>0$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{1}{(a,\varepsilon)}=\left(\frac{1}{a},\frac{\varepsilon}{\left|a\right|\left(\left|a\right|-\varepsilon\right)}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
При практических вычислениях в приближённой арифметике, приближение 
\begin_inset Formula $a$
\end_inset

 и радиус вариации 
\begin_inset Formula $\varepsilon$
\end_inset

 могут записываться различными способами, при чём как правило, множество
 возможных значений записи образует счётное подмножество 
\begin_inset Formula $W\subset\mathbb{C}$
\end_inset

.
 Это могут быть как допускающие произвольную точность способы, записывающие
 число в рациональном или алгебраическом виде, так и приближённые варианты,
 записывающие число в виде конечной десятичной или двоичной дроби с плавающей
 точкой и заданным числом значащих цифр.
 В последнем случае, при большинстве из проводимых арифметических операций
 их результат, посчитанный согласно данным выше определениям не будет допускать
 записи в 
\begin_inset Formula $W$
\end_inset

.
 
\end_layout

\begin_layout Definition

\emph on
Округлением до точности записи
\emph default
 называется замена приближённого числа 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

 на 
\begin_inset Formula $\left(a_{w},\varepsilon_{w}\right)$
\end_inset

, где 
\begin_inset Formula $a_{w},\varepsilon_{w}\in W$
\end_inset

, и все вариации числа до округления являются вариациями числа после округления:
 
\begin_inset Formula $\mathbf{\varepsilon_{w}}\geqslant\varepsilon+\left|a_{w}-a\right|$
\end_inset

.
 Формально говоря, выбор 
\begin_inset Formula $\left(a_{w},\varepsilon_{w}\right)$
\end_inset

 является произвольным, однако, на практике алгоритм округления до точности
 записи выбирает элементы в каком-либо смысле близкие к 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

.
 Одно из условий такой близости можно сформулировать как 
\begin_inset Formula $\mathbf{\varepsilon_{w}}\leqslant(1+E)\varepsilon$
\end_inset

, где 
\begin_inset Formula $E\in\mathbb{R}$
\end_inset

 близкое к нулю положительное число.
\end_layout

\begin_layout Standard
В системах компьютерной алгебры вычисления с плавающей точкой могут оказываться
 значительно быстрее точных рациональных вычислений.
 Однако, при вычислении базиса Грёбнера для входных данных с коэффициентами
 в 
\begin_inset Formula $\mathbb{C}$
\end_inset

, они, как правило, не используются, поскольку, несмотря на точность задания
 входных данных, получаемый результат будет иметь приближённые коэффициенты
 из 
\begin_inset Formula $\tilde{\mathbb{C}}$
\end_inset

.
 Основная потеря точности при этом происходит при обращении элементов 
\begin_inset Formula $W$
\end_inset

, обратные к которым не лежат в 
\begin_inset Formula $W$
\end_inset

.
 Для двоичных и десятичных дробей такими оказываются многие целые числа,
 например 
\begin_inset Formula $3$
\end_inset

.
 Округление до точности записи при этом меняет нулевой радиус вариации на
 ненулевой, что может привести к радикальному изменению задачи и, в частности,
 отсутствию непрерывного конечного решения.
\end_layout

\begin_layout Standard
С другой стороны, при решении задачи 
\begin_inset CommandInset ref
LatexCommand ref
reference "problem:approx-poly-system"

\end_inset

, в которой все входные коэффициенты заданы приближёнными коэффициентами
 из 
\begin_inset Formula $\tilde{\mathbb{C}}$
\end_inset

, округление до точности записи, при достаточно малых значениях 
\begin_inset Formula $E$
\end_inset

, даст снижение точности, не превышающее расширению радиусов вариации входных
 данных в 
\begin_inset Formula $(1+E)^{N}$
\end_inset

 раз, где 
\begin_inset Formula $N$
\end_inset

 -- число арифметических операций в алгоритме.
 Из этого выражения 
\begin_inset Formula $E$
\end_inset

 можно выбрать достаточно малым для того, чтобы такое увеличение радиусов
 входных данных было не принципиальным с точки зрения постановки приближённой
 задачи.
\end_layout

\begin_layout Standard
Для того чтоб выстраиваемая теория была применима к случаю записи в виде
 чисел с плавающей точкой, далее мы будем предполагать что после всех арифметиче
ских операций происходит операция округления до точности записи, обозначаемая
 как 
\begin_inset Formula $\omega\left(\left(a,\varepsilon\right)\right)$
\end_inset

.
\end_layout

\begin_layout Lemma
Заданные таким образом арифметические операции обладают следующим свойством:
 численный 
\begin_inset Formula $\mathbb{C}$
\end_inset

-результат арифметической операции над любым набором специализаций операндов
 равен некоторой специализации результата операции в 
\begin_inset Formula $\tilde{\mathbb{C}}$
\end_inset

.
 
\end_layout

\begin_layout Proof
Для сложения и вычитания утверждение доказываются прямой проверкой.
 Для умножения следует из того, что 
\begin_inset Formula 
\[
\left|(a_{1}+e_{1})(a_{2}+e_{2})-a_{1}a_{2}\right|=\left|e_{1}a_{2}+e_{2}a_{1}+e_{1}e_{2}\right|\leqslant\varepsilon_{1}\left|a_{2}\right|+\varepsilon_{2}\left|a_{1}\right|+\varepsilon_{1}\varepsilon_{2}.
\]

\end_inset

Для обращения:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
\left|\frac{1}{a+e}-\frac{1}{a}\right|=\left|\frac{a-(a+e)}{a\left(a+e\right)}\right|=\left|\frac{e}{a\left(a+e\right)}\right|\leqslant\frac{\varepsilon}{\left|a\left(a+e\right)\right|}\leqslant\frac{\varepsilon}{\left|a\right|\left(\left|a\right|-\varepsilon\right)}.
\]

\end_inset


\end_layout

\begin_layout Standard
Обратное выполняется только для сложения и вычитания при отсутствии округления
 до точности записи: любая специализация результата операции сложения/вычитания
 в 
\begin_inset Formula $\tilde{\mathbb{C}}$
\end_inset

 является результатом соответствующей операции в 
\begin_inset Formula $\mathbb{C}$
\end_inset

 над некоторыми специализациями операндов.
\end_layout

\begin_layout Standard
Доказанное свойство позволяет придать строгий смысл знаку равенства, применяемом
у к приближённым числам.
 Он означает не совпадение приближённых чисел слева и справа, а то что для
 любой специализации левой части, найдётся равная ей специализация правой
 части.
 Поскольку обратное при этом не обязано выполняться, понятие, выражаемое
 знаком равенства является некоммутативным, и по сути знак равенства является
 знаком разрешения перехода от одной части к другой.
 Тем не менее, за ним остаётся обозначение 
\begin_inset Quotes fld
\end_inset

=
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
На основе сложения чисел определим сложение приближённых многочленов, а
 на основе операции умножения -- операцию умножения многочлена на элемент
 
\begin_inset Formula $\tilde{\mathbb{C}}$
\end_inset

.
 Умножение на моном определяется без использования арифметических операций.
 
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:linear-comb"

\end_inset

Если приближённые многочлены 
\begin_inset Formula $p_{1},p_{2}$
\end_inset

 удовлетворяют утверждению 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

, то 
\begin_inset Formula $\forall\left(a,\varepsilon\right)\in\tilde{\mathbb{C}},t\in\mathbb{T}$
\end_inset

 приближённый многочлен 
\begin_inset Formula $p_{1}+\left(a,\varepsilon\right)t\cdot p_{2}$
\end_inset

 тоже ему удовлетворяет.
 Более того, если при фиксированных входных данных, дающих идеал 
\begin_inset Formula $I'$
\end_inset

 зафиксировать лежащие в 
\begin_inset Formula $I'$
\end_inset

 специализации 
\begin_inset Formula $p_{1}',p_{2}'$
\end_inset

 и дополнительно зафиксировать для 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

 произвольную специализацию 
\begin_inset Formula $a+e$
\end_inset

, то 
\begin_inset Formula $p_{1}'+\left(a+e\right)tp_{2}'$
\end_inset

 даёт специализацию 
\begin_inset Formula $p_{1}+\left(a,\varepsilon\right)t\cdot p_{2}$
\end_inset

 которая лежит в 
\begin_inset Formula $I'$
\end_inset

.
\end_layout

\begin_layout Proof
Из предыдущей леммы вытекает, что 
\begin_inset Formula $p_{1}'+\left(a+e\right)tp_{2}'$
\end_inset

 есть специализация приближённого многочлена.
 Кроме того она лежит в 
\begin_inset Formula $I'$
\end_inset

, поскольку есть мономиальная комбинация элементов идеала.
 Это означает что взяв любую специализацию для 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

 мы получаем специализацию многочлена, необходимую для выполнения утверждения
 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

.
\end_layout

\begin_layout Standard
Для алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 необходимы две операции над многочленами, причём обе они применяются в
 процедуре 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

.
 Это редукция многочлена по многочлену с единичным старшим коэффициентом
 и нормализация старшего коэффициента.
 Если редукцию многочлена 
\begin_inset Formula $p$
\end_inset

 по нормализованному многочлену 
\begin_inset Formula $r$
\end_inset

 с 
\begin_inset Formula $\HC(r)=_{0}1$
\end_inset

 определить стандартным образом -- как 
\begin_inset Formula $p-\left(a,\varepsilon\right)\frac{\HM(p)}{\HM(r)}\cdot r$
\end_inset

, где 
\begin_inset Formula $\left(a,\varepsilon\right)=\HC(p)$
\end_inset

, мы получим многочлен, удовлетворяющий утверждению 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

.
 Но при этом его старший моном с коэффициентом будет равен 
\begin_inset Formula $(0,2\varepsilon)\HM(p)$
\end_inset

, поскольку сокращение не произойдёт.
 Обозначим за 
\begin_inset Formula $p'$
\end_inset

 специализацию 
\begin_inset Formula $p,$
\end_inset

 лежащую в 
\begin_inset Formula $I'$
\end_inset

.
 Тогда, если применить предыдущую лемму взяв в качестве фиксированной специализа
ции 
\begin_inset Formula $\left(a,\varepsilon\right)$
\end_inset

 число равное 
\begin_inset Formula $\HC(p')$
\end_inset

, будет получена специализация 
\begin_inset Formula $p-\HC(p)\frac{\HM(p)}{\HM(r)}\cdot r$
\end_inset

 лежащая в 
\begin_inset Formula $I'$
\end_inset

 со старшим мономом 
\begin_inset Formula $\prec_{0}$
\end_inset


\begin_inset Formula $\HM(p)$
\end_inset

, поскольку в ней произойдёт сокращение.
 Обозначим за 
\family typewriter
ApproxReduce
\family default

\begin_inset Formula $(p,r)$
\end_inset

 процедуру, возвращающую многочлен 
\begin_inset Formula $p-\HC(p)\frac{\HM(p)}{\HM(r)}\cdot r$
\end_inset

 с отброшенным старшим мономом 
\begin_inset Formula $\HM(p)$
\end_inset

.
 
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:ApproxReduce-is-matching"

\end_inset

Если пара приближённых многочленов 
\begin_inset Formula $p,r$
\end_inset

 с 
\begin_inset Formula $\HM(r)|\HM(p),\HC(r)=_{0}1$
\end_inset

 удовлетворяет утверждению 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

, то многочлен 
\family typewriter
\emph on
ApproxReduce
\family default
\emph default

\begin_inset Formula $(p,r)$
\end_inset

 также ему удовлетворяет.
 Более того, если при фиксированных входных данных, дающих идеал 
\begin_inset Formula $I'$
\end_inset

, зафиксировать лежащие в 
\begin_inset Formula $I'$
\end_inset

 специализации 
\begin_inset Formula $p',r'$
\end_inset

, то 
\begin_inset Formula $p'-\frac{\HC(p')\HM(p')}{\HM(r')}r'$
\end_inset

 даёт лежащую в 
\begin_inset Formula $I'$
\end_inset

 специализацию 
\family typewriter
\emph on
ApproxReduce
\family default
\emph default

\begin_inset Formula $(p,r)$
\end_inset

.
\end_layout

\begin_layout Proof
Рассмотрим фиксированную специализацию входных данных, дающую идеал 
\begin_inset Formula $I'$
\end_inset

.
 Из леммы 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:linear-comb"

\end_inset

 следует, что 
\begin_inset Formula $p'-\frac{\HC(p')\HM(p')}{\HM(r')}r'$
\end_inset

 -- лежащая в 
\begin_inset Formula $I'$
\end_inset

 специализация 
\begin_inset Formula $p-\HC(p)\frac{\HM(p)}{\HM(r)}\cdot r$
\end_inset

, которая будет являться и специализацией 
\family typewriter
ApproxReduce
\family default

\begin_inset Formula $(p,r)$
\end_inset

, поскольку при вычитании старший моном сокращается.
 Это доказывает оба утверждения леммы.
\end_layout

\begin_layout Standard
Обратное утверждение неверно -- не любая специализация 
\family typewriter
ApproxReduce
\family default

\begin_inset Formula $(p,r)$
\end_inset

 будет лежать в идеале, порождённом некоторой специализацией входных данных.
 Рассмотрим переход от системы уравнений, задаваемой входными приближёнными
 многочленами, к системе задаваемой приближённым базисом Грёбнера, рассчитанным
 при помощи алгоритма, использующего процедуру 
\family typewriter
ApproxReduce
\family default
.
 В общем случае он будет не равносильным, а переходом к более общей системе,
 множество решений которой при различных специализациях содержит множество
 решений исходной системы.
 Поскольку рассматриваемая задача 
\begin_inset CommandInset ref
LatexCommand ref
reference "problem:approx-poly-system"

\end_inset

 требует лишь найти окрестности, содержащие решения, то такой переход 
\begin_inset Quotes fld
\end_inset

к следствию
\begin_inset Quotes frd
\end_inset

 вполне применим для её решения.
\end_layout

\begin_layout Standard
Нормализация старшего коэффициента многочлена 
\begin_inset Formula $p$
\end_inset

 с обратимым старшим коэффициентом в случае точных вычислений определяется
 как 
\begin_inset Formula $\frac{1}{\HC\left(p\right)}p$
\end_inset

.
 Если продолжить это определение на случай приближённых вычислений, применяя
 его в случае обратимого 
\begin_inset Formula $\HC\left(p\right)$
\end_inset

, то старший коэффициент полученного многочлена будет приближённым числом
 вида 
\begin_inset Formula $_{\alpha}1,\alpha>0$
\end_inset

, а не в точности единицей 
\begin_inset Formula $_{0}1$
\end_inset

.
 К многочлену
\begin_inset Formula $\frac{1}{\HC\left(p\right)}p$
\end_inset

 можно применить лемму 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:linear-comb"

\end_inset

 интерпретировав его как 
\begin_inset Formula $0+\frac{1}{\HC\left(p\right)}\cdot p$
\end_inset

, поэтому для любой специализации входных многочленов, дающей идеал 
\begin_inset Formula $I'$
\end_inset

 найдётся специализация 
\begin_inset Formula $\frac{1}{\HC\left(p\right)}p$
\end_inset

, лежащая в 
\begin_inset Formula $I'$
\end_inset

.
 Покажем, что это будет выполняться и после замены 
\begin_inset Formula $_{\alpha}1$
\end_inset

 на 
\begin_inset Formula $_{0}1$
\end_inset

 рассуждая аналогично случаю редукции многочлена по многочлену.
 Обозначим 
\begin_inset Formula $\frac{1}{\HC\left(p\right)}p$
\end_inset

 с такой заменой за 
\family typewriter
ApproxNormalize
\family default

\begin_inset Formula $\left(p\right)$
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:ApproxNormalize-is-matching"

\end_inset

Если приближённый многочлен 
\begin_inset Formula $p$
\end_inset

 с обратимым 
\begin_inset Formula $\HC(p)$
\end_inset

 удовлетворяет утверждению 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

, то многочлен 
\family typewriter
\emph on
ApproxNormalize
\family default
\emph default

\begin_inset Formula $\left(p\right)$
\end_inset

 также ему удовлетворяет.
 Более того, если при фиксированных входных данных, дающих идеал 
\begin_inset Formula $I'$
\end_inset

, зафиксировать лежащую в 
\begin_inset Formula $I'$
\end_inset

 специализацию 
\begin_inset Formula $p'$
\end_inset

, то 
\begin_inset Formula $\frac{1}{\HC\left(p'\right)}p'$
\end_inset

 даёт лежащую в 
\begin_inset Formula $I'$
\end_inset

 специализацию 
\family typewriter
\emph on
ApproxNormalize
\family default
\emph default

\begin_inset Formula $\left(p\right)$
\end_inset

.
\end_layout

\begin_layout Proof
Зафиксируем специализацию входных данных, дающую идеал 
\begin_inset Formula $I'$
\end_inset

 и специализацию 
\begin_inset Formula $p'\in I'$
\end_inset

.
 Снова рассмотрим лемму 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:linear-comb"

\end_inset

 по отношению к выражению 
\begin_inset Formula $0+\frac{1}{\HC\left(p\right)}\cdot p$
\end_inset

.
 Применим вторую часть утверждения леммы, взяв 
\begin_inset Formula $\frac{1}{\HC\left(p'\right)}$
\end_inset

 в качестве специализации для 
\begin_inset Formula $\frac{1}{\HC\left(p\right)}$
\end_inset

.
 Получится 
\begin_inset Formula $\frac{1}{\HC\left(p'\right)}p'\in I'$
\end_inset

, являющийся специализацией 
\begin_inset Formula $\frac{1}{\HC\left(p\right)}\cdot p$
\end_inset

 с единичным старшим мономом.
 Значит он является и специализацией 
\family typewriter
ApproxNormalize
\family default

\begin_inset Formula $\left(p\right)$
\end_inset

, что доказывает оба утверждения леммы.
\end_layout

\begin_layout Standard
Операции 
\family typewriter
ApproxReduce 
\family default
и
\family typewriter
 ApproxNormalize
\family default
 позволяют провести в приближённом случае процедуру аналогичную процедуре
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ReduceCheckingSignatures"

\end_inset

 и найти таким образом при помощи алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 множество приближённых многочленов, образующее базис Грёбнера.
\end_layout

\begin_layout Standard
Однако применение алгоритма возможно только в том случае, если все многочлены
 поступившие на вход 
\family typewriter
ApproxNormalize
\family default
 имеют обратимый старший коэффициент.
 При этом будет выполняться следующая связь между приближённым и специализирован
ными случаями.
 Отметим, что поскольку алгоритм в начале работы добавляет в множество 
\begin_inset Formula $R$
\end_inset

 сигнатуры, зависящие от старших мономов входных данных, мы будем требовать
 чтоб старшие коэффициенты входных данных не обращались в ноль при специализации.
 Это требование эквивалентно требованию обратимости старших коэффициентов
 входного множества многочленов.
\end_layout

\begin_layout Theorem
Если алгоритм вычисления базиса Грёбнера на наборе приближённых многочленов
 с обратимыми старшими коэффициентами оказалось возможным провести до конца,
 то Базис Грёбнера специализации входных данных является специализацией
 приближённого базиса Грёбнера.
\end_layout

\begin_layout Proof
Доказательство этого утверждения проведём индукцией по итерациям алгоритма.
 Будем доказывать, что на каждой итерации состояние алгоритма на специализации
 входных данных является специализацией для алгоритма в приближённом случае,
 причём старшие коэффициенты не меняются при специализации.
 Базой индукции является состояние в начале алгоритма -- входные данные
 специализированного алгоритма являются специализацией приближённых.
 Докажем, что на каждой итерации это свойство сохраняется.
 В силу лемм 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:ApproxReduce-is-matching"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:ApproxNormalize-is-matching"

\end_inset

 многочлены, возникшие после итерации будут соответствовать друг другу для
 приближённого и специализированного случаев.
 При этом сокращения старшего коэффициента происходить не будет в силу обратимос
ти приближённых коэффициентов многочлена подаваемого на вход 
\family typewriter
ApproxNormalize
\family default
, а значит старшие мономы, возникающие в алгоритмах будут одинаковы.
 Поскольку на ход алгоритма влияют лишь они, то схема алгоритма с точки
 зрения появляющихся мономов, то и все аспекты состояния алгоритма, не касающиес
я коэффициентов, будут одинаковы.
\end_layout

\begin_layout Standard
В случае вычислений над полем 
\begin_inset Formula $\mathcal{K}$
\end_inset

 единственным необратимым элементом был 0, который мог соответствовать только
 нулевому многочлену.
 В случае же приближённых вычислений возможно появление ненулевого многочлена
 с необратимым старшим коэффициентом что делает продолжение алгоритма невозможны
м.
 Далее мы рассмотрим возможные причины появления необратимых коэффициентов
 и опишем методы, позволяющие в большинстве случаев продолжить вычисление
 базиса Грёбнера.
 
\end_layout

\begin_layout Subsection
Символические нули
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example:symbolic-zeroes"

\end_inset

Рассмотрим следующий набор отмеченных приближённых многочленов 
\begin_inset Formula $\left\{ f_{1},f_{2},f_{3}\right\} $
\end_inset

с мономиальным порядком degrevlex(
\begin_inset Formula $x,y,z$
\end_inset

):
\begin_inset Formula 
\[
\begin{array}{ccc}
\poly(f_{1})= & y^{2}z+_{0,1}1, & \Sig(f_{1})=\left(1,1\right)\\
\poly(f_{2})= & y^{2}z^{2}+xz+1, & \Sig(f_{2})=\left(1,2\right)\\
\poly(f_{3})= & y^{3}z+xy+1, & \Sig(f_{3})=\left(1,3\right)
\end{array}
\]

\end_inset

и применим алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с порядком Schreyer на сигнатурах.
 Итерации алгоритма будут происходить следующим образом:
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ f_{1},f_{2},f_{3}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(y^{3}z,3\right),0\right),\left(\left(y^{2}z,2\right),0\right)\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{4}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{4})=\poly(f_{1})=y^{2}z+_{0,1}1,\Sig(f_{4})=\left(1,1\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ f_{2},f_{3}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(y^{3}z,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{5}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{5})=\poly(f_{2})-z\poly(f_{4})=xz-\left(_{0,1}1\right)z+1,\Sig(f_{5})=\left(1,2\right)
\]

\end_inset

В 
\begin_inset Formula $B$
\end_inset

 добавляется 
\begin_inset Formula $y^{2}f_{5}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $xf_{4}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ f_{3},y^{2}f_{5}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(y^{3}z,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4},f_{5}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{6}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{6})=\poly(f_{3})-y\poly(f_{4})=xy-\left(_{0,1}1\right)y+1,\Sig(f_{6})=\left(1,3\right)
\]

\end_inset

В 
\begin_inset Formula $B$
\end_inset

 добавляется 
\begin_inset Formula $zf_{6}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $yf_{5}$
\end_inset

, а также
\begin_inset Formula $yzf_{6}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $xf_{4}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ zf_{6},y^{2}f_{5},yzf_{6}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(y^{3}z,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4},f_{5},f_{6}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{7}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{7})=z\poly(f_{6})-y\poly(f_{5})=\left(_{0,2}0\right)yz+z-y,\Sig(f_{7})=\left(z,3\right).
\]

\end_inset

То есть приближённые вычисления дали элемент с необратимым старшим мономом.
\end_layout

\begin_layout Standard
При этом, если во входных многочленах заменить приближённое число на символическ
ий параметр 
\begin_inset Formula $b$
\end_inset

, то мы получим 
\begin_inset Formula 
\begin{eqnarray*}
\poly\left(f_{5}\right) & = & xz-bz+1\\
\poly\left(f_{6}\right) & = & xy-by+1\\
\poly\left(f_{7}\right) & = & z-y,
\end{eqnarray*}

\end_inset

то есть коэффициент при 
\begin_inset Formula $yz$
\end_inset

 в 
\begin_inset Formula $f_{7}$
\end_inset

обнуляется.
 Из обнуления в случае символических вычислений следует, что обнуление произойдё
т и при любой специализации входных данных.
 Дадим название таким необратимым элементам, возникающим в приближённых
 вычислениях.
\end_layout

\begin_layout Definition
Необратимый приближённый элемент, возникший в процессе приближённых вычислений
 алгоритмом 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 называется 
\emph on
символическим нулём
\emph default
, если при любой специализации входных данных при проведении соответствующих
 вычислений получается точный ноль.
 Иными словами, для любой специализации входных данных существует лежащая
 в порождаемом ими идеале специализация многочлена, содержащего рассматриваемый
 необратимый коэффициент, с нулём на его месте.
 Необратимые элементы, не являющиеся символическими нулями называются 
\emph on
приближёнными нулями
\emph default
.
\end_layout

\begin_layout Standard
Таким образом, при появлении символического нуля в качестве старшего коэффициент
а одного из многочленов, вычисление может быть продолжено путём отбрасывания
 такого старшего монома, поскольку отбрасывание не нарушит выполнение утверждени
я 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

 для рассматриваемого многочлена.
 Однако, чтоб применить этот подход на практике нужно уметь обнаруживать
 символические нули, поэтому ниже будет предложен метод их обнаружения.
\end_layout

\begin_layout Subsection
Приближённые нули, индуцированные входными данными
\end_layout

\begin_layout Standard
Основой для классификации приближённых нулей, индуцированных входными данными,
 является их влияние на структуру решений системы уравнений.
 Одной из причин такого влияния является ситуация, когда для некоторых специализ
аций достигается точное равенство нулю, а для других нет.
\end_layout

\begin_layout Definition
Приближённый ноль называется 
\emph on
приближённым нулём, индуцированным входными данными
\emph default
, если существует специализация входных данных, при проведении для которой
 алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 на соответствующем месте будет получен точный ноль.
 При этом, поскольку данный приближённый коэффициент не является символическим
 нулём, будут существовать и специализации, дающие ненулевой коэффициент
 на этом месте.
\end_layout

\begin_layout Standard
Остальные приближённые нули не имеют ни одной специализации, дающей ноль
 при вычислениях.
 Введём название и для них.
\end_layout

\begin_layout Definition
Приближённый ноль называется 
\emph on
внесённым вычислением
\emph default
 
\emph on
нулём
\emph default
, если не существует специализации входных данных, при проведении для которой
 алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 на соответствующем месте будет получен точный ноль.
\end_layout

\begin_layout Standard
Приближённые нули, индуцированные входными данными, не всегда являются причиной
 отсутствия непрерывности решений.
 Будем классифицировать их в соответствии со следующим определением.
\end_layout

\begin_layout Definition
Приближённый ноль, индуцированный входными данными называется 
\emph on
устранимым нулём
\emph default
, если в множестве специализаций входных данных существует окрестность специализ
ации, в которой достигается точное равенство нулю соответствующего коэффициента,
 в которой у системы есть конечное непрерывное решение.
 Иначе такой ноль называется 
\emph on
неустранимым нулём
\emph default
.
 
\end_layout

\begin_layout Standard
При появлении неустранимого нуля система не имеет конечного непрерывного
 решения, и продолжение вычислений в рамках решения задачи 
\begin_inset CommandInset ref
LatexCommand ref
reference "problem:approx-poly-system"

\end_inset

 не имеет смысла.
 В случае же устранимого нуля система может иметь конечное непрерывное решение
 на всём множестве специализаций, поэтому имеет смысл искать методы продолжения
 решения.
 К сожалению, универсального критерия для определения устранимости нуля
 без знания решения системы найти не удалось.
 В некоторых простых случаях устранимость зависит от наличия рядом с приближённы
м нулём других членов такой же полной степени.
\end_layout

\begin_layout Example
Рассмотрим систему вида 
\begin_inset Formula 
\[
\left\{ \begin{array}{cc}
p(x,y) & =0\\
x+y-1 & =0
\end{array}\right..
\]

\end_inset

Число её решений зависит от степени многочлена, получаемого после подстановки
 
\begin_inset Formula $y=1-x$
\end_inset

 в первый многочлен.
 Обозначим необратимый приближённый элемент за 
\begin_inset Formula $b=_{0,1}0$
\end_inset

.
 Тогда, если в качестве 
\begin_inset Formula $p$
\end_inset

 взять приближённый многочлен со старшим коэффициентом 
\begin_inset Formula $b$
\end_inset

, такой что старший моном -- единственный моном максимальной полной степени,
 например 
\begin_inset Formula $bx+1$
\end_inset

 или 
\begin_inset Formula $bx^{3}+2xy+y^{2}$
\end_inset

, то при стремлении к нулю специализации 
\begin_inset Formula $b$
\end_inset

 одно из решений будет уходить на бесконечность и система не будет иметь
 конечного непрерывного решения.
 Если же в качестве 
\begin_inset Formula $p$
\end_inset

 взять многочлен, где максимум полной степени достигается не на единственном
 мономе, такой как 
\begin_inset Formula $bx+y+1$
\end_inset

 или 
\begin_inset Formula $bx^{3}-xy^{2}+2xy+y^{2}$
\end_inset

, то система может иметь конечное непрерывное решение.
 Однако это будет верно не для всех таких многочленов, поскольку после подстанов
ки старший коэффициент всё равно может обнулиться.
 Такое к примеру произойдёт для многочлена 
\begin_inset Formula $bx^{3}-y^{3}-xy^{2}+x$
\end_inset

.
\end_layout

\begin_layout Standard
Необратимые приближённые коэффициенты, появляющиеся в старших мономах не
 редуцированных до конца многочленов не представляют проблемы для алгоритма
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, поскольку после редукции старшим будет уже совсем другой моном.
\end_layout

\begin_layout Example
Поэтому возможна ситуация, когда максимум полной степени достигается на
 единственном старшем элементе с необратимым коэффициентом, но при этом
 система имеет конечное непрерывное решение.
 Такова к примеру система 
\begin_inset Formula 
\[
\left\{ \begin{array}{cc}
\left(_{0,1}0\right)x^{4}+x^{2}+y & =0\\
x^{3}-1 & =0
\end{array}\right..
\]

\end_inset


\end_layout

\begin_layout Standard
Таким образом, хотя в простых случаях и можно проследить связь между полными
 степенями мономов и устранимостью нуля, в общем случае такой зависимости
 нет.
 В следующем разделе будут рассмотрены методики устранения индуцированных
 входными данными нулей, основанные по сути на искусственной модификации
 мономиального порядка.
 Данные методы позволяют однозначно сделать заключение о устранимости нуля
 лишь в том случае, когда за фиксированное число применений такого метода
 получается базис Грёбнера, не содержащей необратимых элементов среди ведущих.
 Если же за фиксированное число применений базис Грёбнера не был найден,
 метод признаётся неподходящим для рассматриваемой системы и вопрос устранимости
 нуля остаётся открытым.
\end_layout

\begin_layout Subsection
Приближённые нули, внесённые вычислениями
\end_layout

\begin_layout Standard
Для понимания причин возникновения внесённых вычислениями нулей рассмотрим
 случай их возникновения в алгоритме 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с порядком Schreyer.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "example:introduced-zeroes"

\end_inset

В кольце многочленов с мономиальным порядком degrevlex(
\begin_inset Formula $x,y,z$
\end_inset

) рассмотрим набор отмеченных приближённых многочленов 
\begin_inset Formula $\left\{ f_{1},f_{2},f_{3}\right\} $
\end_inset

 с параметрами 
\begin_inset Formula $a$
\end_inset

 и 
\begin_inset Formula $b$
\end_inset

, являющимися приближёнными числами:
\begin_inset Formula 
\[
\begin{array}{ccc}
\poly(f_{1})= & y^{2}z+z^{2}+az, & \Sig(f_{1})=\left(1,1\right)\\
\poly(f_{2})= & xyz, & \Sig(f_{2})=\left(1,2\right)\\
\poly(f_{3})= & xy^{2}+bx+1, & \Sig(f_{3})=\left(1,3\right)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Итерации алгоритма будут происходить следующим образом:
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ f_{1},f_{2},f_{3}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(xyz,3\right),0\right),\left(\left(y^{2}z,2\right),0\right)\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{4}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{4})=\poly(f_{1})=y^{2}z+z^{2}+az,\Sig(f_{4})=\left(1,1\right).
\]

\end_inset


\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ f_{2},f_{3}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(xyz,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{5}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{5})=\poly(f_{2})=xyz,\Sig(f_{5})=\left(1,2\right)
\]

\end_inset

В 
\begin_inset Formula $B$
\end_inset

 добавляется 
\begin_inset Formula $yf_{5}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $xf_{4}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ f_{3},yf_{5}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(xyz,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4},f_{5}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{6}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{6})=\poly(f_{3})=xy^{2}+bx+1,\Sig(f_{6})=\left(1,3\right)
\]

\end_inset

В 
\begin_inset Formula $B$
\end_inset

 добавляется 
\begin_inset Formula $zf_{6}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $yf_{5}$
\end_inset

 и 
\begin_inset Formula $xf_{4}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ yf_{5},zf_{6}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(xyz,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4},f_{5},f_{6}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{7}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{7})=-\left(y\poly(f_{5})-x\poly(f_{4})\right)=xz^{2}+axz,\Sig(f_{7})=\left(y,2\right)
\]

\end_inset

В 
\begin_inset Formula $B$
\end_inset

 добавляется 
\begin_inset Formula $yf_{7}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $zf_{5}$
\end_inset

 и также
\begin_inset Formula $y^{2}f_{7}$
\end_inset

, как редуцируемый по 
\begin_inset Formula $z^{2}f_{6}$
\end_inset

 и 
\begin_inset Formula $xzf_{4}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Первый элемент множества 
\begin_inset Formula $B=\left\{ zf_{6},yf_{7},y^{2}f_{7}\right\} $
\end_inset

 редуцируется по 
\begin_inset Formula $R=\left\{ \left(\left(y^{2}z,3\right),0\right),\left(\left(xyz,3\right),0\right),\left(\left(y^{2}z,2\right),0\right),f_{4},f_{5},f_{6},f_{7}\right\} ,$
\end_inset

 давая 
\begin_inset Formula $f_{8}$
\end_inset

 в результате
\begin_inset Formula 
\[
\poly(f_{8})=(z\poly(f_{6})-x\poly(f_{4}))+\poly(f_{7})=
\]

\end_inset


\begin_inset Formula 
\[
=\left(\left(xy^{2}z+bxz+z\right)-\left(xy^{2}z+xz^{2}+axz\right)\right)+xz^{2}+axz=
\]

\end_inset


\begin_inset Formula 
\[
=((b-a)+a)xz+z,
\]

\end_inset


\begin_inset Formula 
\[
\Sig(f_{8})=\left(z,3\right)
\]

\end_inset


\end_layout

\begin_layout Standard
При приближённых вычислениях выражение вида 
\begin_inset Formula $((b-a)+a)xz+z$
\end_inset

 может иметь необратимый старший коэффициент даже в том случае, если 
\begin_inset Formula $b$
\end_inset

 обратим.
 Это возможно например в случае, если радиус вариации 
\begin_inset Formula $a$
\end_inset

 много больше абсолютного значения приближения 
\begin_inset Formula $b$
\end_inset

.
 С другой стороны, символические вычисления показывают, что при любой специализа
ции входных данных старший коэффициент 
\begin_inset Formula $\poly(f_{8})$
\end_inset

 не обращается в нуль.
 Для борьбы с такими необратимыми коэффициентами будет предложен метод вычислени
я приближённых коэффициентов, позволяющий получать результат с меньшими
 значениями вариации.
\end_layout

\begin_layout Section
Борьба с необратимыми элементами
\end_layout

\begin_layout Standard
Рассмотрим вопрос определения различных типов необратимых элементов, при
 выполнении алгоритма с приближёнными числами, представляемыми как конечные
 двоичные дроби к задаче 
\begin_inset CommandInset ref
LatexCommand ref
reference "problem:approx-poly-system"

\end_inset

, в которой входные данные также заданы приближёнными двоичными дробями.
\end_layout

\begin_layout Subsection
Определение символических нулей
\end_layout

\begin_layout Standard
Наиболее простой способ определения символических нулей состоит в рассмотрении
 всех приближённых чисел ненулевой вариации как параметров 
\begin_inset Formula $\left\{ a_{i}\right\} $
\end_inset

 со значениями в 
\begin_inset Formula $\mathbb{C}$
\end_inset

, а чисел с нулевой вариацией просто как элементов 
\begin_inset Formula $\mathbb{C}$
\end_inset

.
 В этом случае каждый из коэффициентов представляется как многочлен от нескольки
х переменных из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

.
\end_layout

\begin_layout Lemma
Необратимый приближённый коэффициент является символическим нулём тогда
 и только тогда, когда многочлен из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

, возникающий на соответствующем месте при вычислениях с параметрами является
 тождественно нулевым.
\end_layout

\begin_layout Proof
Если коэффициент является символическим нулём, то значения соответствующего
 многочлена на всех специализациях входных данных, будут равны нулю.
 Поскольку множество специализаций входных данных содержит непустое открытые
 множество значений 
\begin_inset Formula $\left\{ a_{i}\right\} $
\end_inset

, это возможно в 
\begin_inset Formula $\mathbb{C}$
\end_inset

 только тогда, когда соответствующий многочлен тождественно равен нулю.
 Обратное тривиально.
\end_layout

\begin_layout Standard
Метод символических вычислений тесно связан с понятием исчерпывающего базиса
 Грёбнера, предложенного в работе 
\begin_inset CommandInset citation
LatexCommand cite
key "ComprehensiveGB"

\end_inset

.
 Алгоритм вычисления исчерпывающего базиса позволяет найти множество многочленов
 с коэффициентами из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

, являющееся базисом Грёбнера параметрического идеала при любой специализации
 параметров.
 Таким образом нахождение исчерпывающего базиса позволяет решить рассматриваемую
 нами задачу.
 Однако, при большом количестве параметров исчерпывающий базис обладает
 серьёзным недостатком: 
\begin_inset CommandInset citation
LatexCommand cite
key "ComprehensiveGB"

\end_inset

 даёт оценку сложности работы алгоритмов его вычисления оценивается в терминах
 количества операций с параметрическими многочленами, проводящую сравнение
 числа таких операций с числом операций, необходимым для вычисления обычного
 не параметрического базиса Грёбнера, но при этом не проводится сравнение
 сложностей операций над коэффициентами для параметрического и непараметрическог
о случаев.
\end_layout

\begin_layout Standard
При проведении одних и тех же операций с многочленами в символическом и
 приближённом случаях сложность арифметических операций может асимптотически
 различаться: при символических вычислениях количество различных мономов
 в многочленах из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

 будет как правило нарастать в процессе вычислений, а при вычислении в двоичных
 дробях, в которых число значащих цифр в коэффициенте никогда не увеличивается
 в процессе работы, сложность остаётся постоянной.
 Поэтому применение символических вычислений как метода определения символически
х нулей является неэффективным, поскольку данный метод с одной стороны позволяет
 самостоятельно решить рассматриваемую задачу, путём нахождения исчерпывающего
 базиса Грёбнера, но с другой его вычислительная сложность больше сложности
 метода приближённых вычислений.
\end_layout

\begin_layout Standard
Многочлены из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

, соответствующие входным данным могут быть рассмотрены как многочлены с
 коэффициентами из кольца комплексных дробно-рациональных чисел.
 Поскольку символический ноль появляется только при тождественном обнулении
 многочлена из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

 верна следующая лемма.
\end_layout

\begin_layout Lemma
Необходимым условием символического нуля является равенство нулю соответствующег
о коэффициента при точных вычислениях в дробно-рациональных комплексных
 числах с произвольными числами в качестве параметров, при условии, что
 не произошло обнулений, повлиявших на ход алгоритма до получения рассматриваемо
го коэффициента.
\end_layout

\begin_layout Standard
Целые комплексные числа, рассматриваемые по простому модулю 
\begin_inset Formula $p$
\end_inset

 вида 
\begin_inset Formula $4k+3$
\end_inset

 образуют конечное поле из 
\begin_inset Formula $p^{2}$
\end_inset

 элементов.
 Дробно-рациональные комплексные коэффициенты многочленов могут быть отображены
 в такое конечное поле модулярных комплексных чисел, что приводит к ещё
 одной аналогичной лемме.
\end_layout

\begin_layout Lemma
Необходимым условием символического нуля является равенство нулю соответствующег
о коэффициента при вычислениях в модулярных комплексных числах по простому
 модулю вида 
\begin_inset Formula $4k+3$
\end_inset

 с произвольными числами в качестве параметров, при условии, что не произошло
 обнулений, повлиявших на ход алгоритма до получения рассматриваемого коэффициен
та.
\end_layout

\begin_layout Standard
Две полученные леммы дают способы определения необходимого условия символическог
о нуля.
 На практике дробно-рациональные вычисления имеют ту же проблему, что и
 символические -- рост времени, необходимого на арифметические операции
 в процессе работы, вызванный абсолютным увеличением числителей и знаменателей.
 Однако, модулярные вычисления по простому модулю не имеют такой проблемы
 и имеют сложность проведения пропорциональную сложности приближённых вычислений.
 Если зафиксировать произвольные значения модулярных коэффициентов на местах
 приближённых чисел возможно проведение алгоритма вычисления Базиса Грёбнера
 для многочленов, коэффициенты которых представлены парами 
\begin_inset Formula $\left\{ a,\alpha\right\} $
\end_inset

, состоящими из приближённого 
\begin_inset Formula $\alpha\in\tilde{\mathbb{C}}$
\end_inset

 и комплексно-модулярного 
\begin_inset Formula $a$
\end_inset

, взятого по модулю 
\begin_inset Formula $4k+3$
\end_inset

.
\end_layout

\begin_layout Standard
Модулярные вычисления дают лишь необходимое условие для символического нуля.
 Однако если предположить что вероятность получения нуля в модулярных вычисления
х при отсутствии символического нуля в каком-то смысле 
\begin_inset Quotes fld
\end_inset

мала
\begin_inset Quotes frd
\end_inset

, можно предложить следующий практический метод определения символических
 нулей: если старшая пара-коэффициент многочлена, содержит необратимый приближён
ный элемент и нулевой модулярный, такой коэффициент признаётся символическим
 нулём и отбрасывается.
 Если старшая пара содержит необратимый приближённый элемент и ненулевой
 модулярный -- она не трактуется как символический ноль.
 
\end_layout

\begin_layout Standard
Покажем, как данный метод вычислений будет работать на примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:symbolic-zeroes"

\end_inset

, в котором появляются символические нули.
 Запишем получаемые многочлены при использовании вычислений по произвольно
 взятому модулю 
\begin_inset Formula $107$
\end_inset

 с произвольно взятым коэффициентом 
\begin_inset Formula $76$
\end_inset

 на месте коэффициента с ненулевой вариацией:
\begin_inset Formula 
\[
\begin{array}{ccc}
\poly(f_{1})= & y^{2}z+\left\{ 76,{}_{0,1}1\right\} , & \Sig(f_{1})=\left(1,1\right)\\
\poly(f_{2})= & y^{2}z^{2}+xz+1, & \Sig(f_{2})=\left(1,2\right)\\
\poly(f_{3})= & y^{3}z+xy+1, & \Sig(f_{3})=\left(1,3\right)\\
\poly(f_{4})= & \poly(f_{1})=y^{2}z+\left\{ 76,{}_{0,1}1\right\} , & \Sig(f_{4})=\left(1,1\right)\\
\poly(f_{5})= & \poly(f_{2})-z\poly(f_{4})=xz+\left\{ 31,{}_{0,1}-1\right\} z+1, & \Sig(f_{5})=\left(1,2\right)\\
\poly(f_{6})= & \poly(f_{3})-y\poly(f_{4})=xy+\left\{ 31,{}_{0,1}-1\right\} y+1, & \Sig(f_{6})=\left(1,3\right)\\
\poly(f_{7})= & z\poly(f_{6})-y\poly(f_{5})=\\
 & \left(\left\{ 76,{}_{0,1}1\right\} +\left\{ 31,{}_{0,1}-1\right\} \right)yz+z-y=\\
 & \left(\left\{ 0,{}_{0,2}0\right\} \right)yz+z-y, & \Sig(f_{7})=\left(z,3\right)
\end{array}
\]

\end_inset

и, применяя отбрасывание, в итоге получаем многочлен с обратимым старшим
 коэффициентом: 
\begin_inset Formula 
\[
\poly\left(f_{7}\right)=z-y.
\]

\end_inset


\end_layout

\begin_layout Standard
Для этого метода не удалось получить оценку вероятности того, что произвольно
 выбранные модулярные значения дадут ноль при отсутствии символического
 нуля, поэтому вероятность корректности приведённого алгоритма остаётся
 неизвестной.
 Альтернативный подход, допускающий такую оценку вероятности, а также позволяющи
й бороться с внесёнными вычислениями нулями, будет дан в следующем разделе.
\end_layout

\begin_layout Subsection
Модулярные методы
\end_layout

\begin_layout Standard
Помимо определения символических нулей символические вычисления могут в
 некоторых случаях быть использованы для определения и устранения нулей,
 внесённых вычислениями.
 Идея метода основана на наблюдении, которое можно сделать на основе примера
 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:introduced-zeroes"

\end_inset

: причиной потери точности в приближённых вычислениях может являться добавление
 и последующее вычитание одного и того же многочлена.
 Потеря точности будет происходить и в случае, если один и тот же многочлен
 добавлялся с коэффициентами противоположных знаков, не дающих в сумме 0:
\begin_inset Formula 
\[
2\cdot_{0,4}1-1\cdot_{0,4}1={}_{0,8}2-{}_{0,4}1=_{1,2}1
\]

\end_inset

При этом, если бы мы вначале рассчитали сумму коэффициентов, радиус вариации
 результата был бы меньше, что позволило бы его обратить:
\begin_inset Formula 
\[
2\cdot_{0,4}1-1\cdot_{0,4}1=(2-1)\cdot_{\cdot0,4}1=1\cdot_{0,4}1={}_{0,4}1
\]

\end_inset

Поэтому попытаемся найти выражение рассматриваемого приближённого многочлена
 через исходные.
 Для этого необходимо в многочлен из 
\begin_inset Formula $\mathbb{C}\left[a_{i}\right]$
\end_inset

-- символическое выражение для коэффициентов -- в качестве 
\begin_inset Formula $a_{i}$
\end_inset

 подставить приближённые числа, соответствующие входным данным.
 Полученное приближённое число может иметь вариацию меньшую, чем коэффициент,
 получаемый на этом же месте при проведении приближённых вычислений в течении
 всего алгоритма.
 Однако такое использование символических вычислений обладает уже упоминавшейся
 выше проблемой -- их асимптотическая вычислительная сложность может оказаться
 больше, чем сложность приближённых вычислений.
\end_layout

\begin_layout Standard
При этом модулярные вычисления снова позволяют избежать данной проблемы
 и могут быть использованы для устранения внесённых нулей.
 Для этого, для каждого многочлена 
\begin_inset Formula $p$
\end_inset

, лежащего в S-базисе, на основе модулярных вычислений определяются многочлены
 
\begin_inset Formula $q_{i}$
\end_inset

, на которые необходимо домножить входные многочлены 
\begin_inset Formula $\left\{ f_{1},\ldots,f_{m}\right\} $
\end_inset

 чтоб получить выражение вида 
\begin_inset Formula $p=\sum_{i}q_{i}f_{i}$
\end_inset

.
 Эти многочлены, найденные для модулярного случая, получаются из соответствующих
 символических подстановкой модулярных коэффициентов в качестве параметров.
 Поэтому, если при этой подстановке не произошло обнулений коэффициентов,
 структура модулярного многочлена будет совпадать со структурой символического,
 а значит и со структурой приближённого 
\begin_inset Formula $q_{i}$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:system-approx"

\end_inset

Рассмотрим в приближённых числах СЛАУ для коэффициентов 
\begin_inset Formula $q_{i}$
\end_inset

, выражающую требование того, в сумме 
\begin_inset Formula $\sum_{i}q_{i}f_{i}$
\end_inset

 коэффициенты при мономах старше 
\begin_inset Formula $\HM(p)$
\end_inset

 равны нулю, а коэффициент при 
\begin_inset Formula $\HM(p)$
\end_inset

 равен 1.
 Если метод решения линейной системы, основанный на операциях со строками,
 подобных 
\family typewriter
ApproxReduce 
\family default
и
\family typewriter
 ApproxNormalize
\family default
, дал некоторое решение 
\begin_inset Formula $q_{i}=\tilde{q_{i}}$
\end_inset

, то многочлен со старшим членом 
\begin_inset Formula $1\HM\left(p\right)$
\end_inset

 с добавленными членами степеней 
\begin_inset Formula $\prec\HM\left(p\right)$
\end_inset

 из приближённого многочлена 
\begin_inset Formula $\sum_{i}\tilde{q_{i}}f_{i}$
\end_inset

 удовлетворяет свойству 
\begin_inset CommandInset ref
LatexCommand ref
reference "needed-poly-prop"

\end_inset

.
\end_layout

\begin_layout Proof
Решение операциями над строками в приближённой арифметике соответствует
 расширению вариации системы в том смысле, что для каждой специализации
 исходной системы найдётся эквивалентная ей специализация системы после
 проведения операции над строкой.
 Поэтому, если операциями над строками привела к системе имеющей решение
 при любой специализации, исходная система также имеет решение при любой
 специализации, и оно является решением одной из специализаций приведённой
 системы.
 Взяв такое решение для каждой специализации входных данных мы получим многочлен
 являющийся специализацией приближённого многочлена, указанного в следствии
 теоремы, что доказывает выполнение свойства для этого приближённого многочлена.
\end_layout

\begin_layout Standard
Подробное описание применения модулярных вычислений для борьбы с символическими
 и внесёнными нулями дано в следующем алгоритме, основанном на алгоритме
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:Select-prime"

\end_inset

Выбирается простое число вида 
\begin_inset Formula $4k+3$
\end_inset

, система многочленов рассматривается над конечным модулярным комплексным
 полем.
 При этом коэффициентам с ненулевой вариацией ставятся в соответствие произвольн
ые комплексно модулярные числа, а значения с нулевой вариацией, рассматриваются
 как комплексно-рациональные числа и отображаются в комплексно-модулярные
 взятием всех коэффициентов по модулю.
 Если при этом получилось деление на ноль -- происходит возврат к началу
 шагу 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Select-prime"

\end_inset

, где берётся следующее простое число вида 
\begin_inset Formula $4k+3$
\end_inset

.
\end_layout

\begin_layout Enumerate
В каждый из входных многочленов 
\begin_inset Formula $f_{i}$
\end_inset

 добавляется моном 
\begin_inset Formula $1\cdot t_{i}$
\end_inset

 с единичным модулярным коэффициентом.
 Все мономы содержащие 
\begin_inset Formula $t_{i}$
\end_inset

 игнорируются при определении старшего монома и при сравнении с нулём, однако
 подвергаются стандартным операциям при суммировании и умножении на моном.
 Таким образом, при образовании сумм исходных многочленов с полиномиальными
 коэффициентами оказывается, что все многочлена 
\begin_inset Formula $p$
\end_inset

 мономы содержащие 
\begin_inset Formula $t_{i}$
\end_inset

 дают сумму вида 
\begin_inset Formula $\sum_{i}q_{i}t_{i}$
\end_inset

, где 
\begin_inset Formula $q_{i}$
\end_inset

 -- рассмотренные выше многочлены, удовлетворяющие 
\begin_inset Formula $p=\sum_{i}q_{i}f_{i}$
\end_inset

.
 В силу того, что их коэффициенты получаются из коэффициентов 
\begin_inset Formula $p$
\end_inset

 при содержащих 
\begin_inset Formula $t_{i}$
\end_inset

 мономах, для них справедливы данные для случая символических нулей оценки
 вероятности того, что будет получен ноль в модулярном случае при отсутствии
 нуля в символическом.
\end_layout

\begin_layout Enumerate
К таким модулярным многочленам применяется алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

.
 Для каждого модулярного многочлена 
\begin_inset Formula $p$
\end_inset

, добавляемого в 
\begin_inset Formula $R$
\end_inset

 на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 проводится следующее:
\end_layout

\begin_deeper
\begin_layout Enumerate
На основе мономов, содержащих 
\begin_inset Formula $t_{i}$
\end_inset

 с ненулевыми модулярными коэффициентами определим, на какие мономы умножаются
 входные многочлены для порождения текущего.
 При этом для них известны модулярные коэффициенты, но не известны приближённые.
 В силу возможности обнулений модулярных коэффициентов при 
\begin_inset Formula $t_{i}$
\end_inset

 без отсутствия символического нуля нельзя утверждать, что найденные мономы
 позволяют построить многочлен с 
\begin_inset Formula $\HM\left(p\right)$
\end_inset

 в приближённом случае.
 Однако этого и не требуется: они трактуются лишь как предположительные
 и в случае, если они некорректны -- система окажется несовместной.
 За счёт этого становится не нужной оценка вероятности их корректности,
 в которую упёрлось обоснование описанного ранее метода отбрасывания символическ
их нулей.
\end_layout

\begin_layout Enumerate
Составляется СЛАУ в приближённых числах, соответствующую условию теоремы
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:system-approx"

\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:Select-prime-for-matrix"

\end_inset

Зафиксируем ещё одно простое число вида 
\begin_inset Formula $4k+3$
\end_inset

.
 Оно может как совпадать, так и отличаться от зафиксированного ранее.
 Ниже будет дан способ его выбора по виду входных многочленов и количеству
 строк системы, основанный на оценке вероятности корректности результата.
 Рядом с каждым приближённым коэффициентом в системе ставится модулярный
 -- он выбирается в зависимости от вариации приближённого коэффициента по
 тому же принципу, что и на шаге 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Select-prime"

\end_inset


\end_layout

\begin_layout Enumerate
Система решается применением линейных операций над строками с применением
 численных методов минимизации погрешности по отношению к приближённым коэффицие
нтам при выборе редуцирующей строки.
 При этом возможна ситуация, когда выбрана строка, у которой в редуцируемом
 столбце обратимым является только приближённый или только модулярный коэффициен
т.
 Рассмотрим разновидности таких случаев:
\end_layout

\begin_deeper
\begin_layout Enumerate
Если возникла ситуация что модулярный коэффициент ведущего элемента одной
 из строк равен нулю, а приближённый обратим -- выполняется возврат к шагу
 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Select-prime-for-matrix"

\end_inset

 и выбирается другое простое число
\end_layout

\begin_layout Enumerate
Если модулярный коэффициент равен нулю, а приближённый необратим, то есть
 содержит ноль среди своих специализаций, -- предполагается наличие символическо
го нуля и приближённый коэффициент заменяется на нулевой.
 Алгоритм редукции продолжается поиском новой строки.
\end_layout

\begin_layout Enumerate
Если модулярный коэффициент не равен нулю, а приближённый необратим -- алгоритм
 решения системы прерывается и применяются другие методы борьбы с необратимыми
 коэффициентами.
\end_layout

\end_deeper
\begin_layout Enumerate
Если алгоритм решения показывает, что система несовместна, выполняется возврат
 к шагу 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:Select-prime-for-matrix"

\end_inset

 и выбирается другое простое число, поскольку такая ситуация обозначает
 неверность предположения о структуре 
\begin_inset Formula $q_{i}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Если же решение 
\begin_inset Formula $\tilde{q_{i}}$
\end_inset

 найдено, то строится приближённый многочлен 
\begin_inset Formula $p'$
\end_inset

, равный сумме домноженных входных многочленов с коэффициентами 
\begin_inset Formula $\tilde{q_{i}}$
\end_inset

, при этом отбрасываются мономы старшие 
\begin_inset Formula $HM(p)$
\end_inset

, и принимается равным единице коэффициент при 
\begin_inset Formula $HM(p)$
\end_inset

.
 Этот многочлен записывается в результирующий приближённый S-базис 
\begin_inset Formula $\tilde{R}$
\end_inset

.
 Это множество будет являться S-базисом, поскольку сигнатуры и старшие мономы
 его элементов будут такие же как у элементов модулярного S-базиса 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Покажем, как данный метод вычислений будет работать на примере 
\begin_inset CommandInset ref
LatexCommand ref
reference "example:introduced-zeroes"

\end_inset

, в котором появляются внесённые вычислениями нули при 
\begin_inset Formula $a=_{0.1}1,b=_{1}10$
\end_inset

.
 Запишем получаемые модулярные многочлены при использовании вычислений по
 произвольно взятому модулю 
\begin_inset Formula $107$
\end_inset

 с произвольно взятыми коэффициентами на месте коэффициентов с ненулевой
 вариацией:
\begin_inset Formula 
\[
\begin{array}{ccc}
\poly(f_{1})= & y^{2}z+z^{2}+24z+t_{1}, & \Sig(f_{1})=\left(1,1\right)\\
\poly(f_{2})= & xyz+t_{2}, & \Sig(f_{2})=\left(1,2\right)\\
\poly(f_{3})= & xy^{2}+70x+1+t_{3}, & \Sig(f_{3})=\left(1,3\right)\\
\poly(f_{4})= & \poly(f_{1})=y^{2}z+z^{2}+24z+t_{1}, & \Sig(f_{4})=\left(1,1\right)\\
\poly(f_{5})= & \poly(f_{2})=xyz+t_{2}, & \Sig(f_{5})=\left(1,2\right)\\
\poly(f_{6})= & \poly(f_{3})=xy^{2}+70x+1+t_{3}, & \Sig(f_{6})=\left(1,3\right)\\
\poly(f_{7})= & -\left(y\poly(f_{5})-x\poly(f_{4})\right)=\\
 & xz^{2}+24xz+xt_{1}-yt_{2}, & \Sig(f_{7})=\left(y,2\right)\\
\poly(f_{8})= & (z\poly(f_{6})-x\poly(f_{4}))+\poly(f_{7})=\\
 & \left(\left(xy^{2}z+70xz+z+zt_{3}\right)+\right.\\
 & \left.\left(-xy^{2}z-xz^{2}+83xz+106xt_{1}\right)\right)+\\
 & xz^{2}+24xz+xt_{1}-yt_{2}=\\
 & \left(\left(70+83\right)+24\right)xz+z+\\
 & zt_{3}-yt_{2}+(1+106)xt_{1}=\\
 & 70xz+z+zt_{3}-yt_{2}, & \Sig(f_{8})=\left(z,3\right)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Реальный интерес имеет лишь получение приближённого аналога 
\begin_inset Formula $f_{8}$
\end_inset

, поскольку прямое применение алгоритма к приближённой системе давало необратимы
й старший коэффициент.
 Основываясь на мономах 
\begin_inset Formula $t_{i}$
\end_inset

 можно предположить, что приближённый многочлен сигнатуры 
\begin_inset Formula $\left(z,3\right)$
\end_inset

 со старшим мономом 
\begin_inset Formula $xz$
\end_inset

 представляется в виде 
\begin_inset Formula $c_{1}zf_{3}+c_{2}yf_{2}$
\end_inset

.
 В качестве простого числа возьмём 
\begin_inset Formula $31$
\end_inset

, а коэффициенту с ненулевой вариацией поставим в соответствие модулярный
 коэффициент 
\begin_inset Formula $8$
\end_inset

.
 Требуя обнуления коэффициента при 
\begin_inset Formula $xy^{2}z$
\end_inset

 и единичности коэффициента при 
\begin_inset Formula $xz$
\end_inset

 получаем систему:
\begin_inset Formula 
\begin{eqnarray*}
\begin{pmatrix}1 & 1\\
\left\{ 8,_{0,1}1\right\}  & 0
\end{pmatrix}\begin{pmatrix}c_{1}\\
c_{2}
\end{pmatrix} & = & \begin{pmatrix}0\\
1
\end{pmatrix}\\
 & \Downarrow\\
\begin{pmatrix}1 & 1\\
1 & 0
\end{pmatrix}\begin{pmatrix}c_{1}\\
c_{2}
\end{pmatrix} & = & \begin{pmatrix}0\\
\left\{ 4,_{0,12}1\right\} 
\end{pmatrix}\\
 & \Downarrow\\
\begin{pmatrix}0 & 1\\
1 & 0
\end{pmatrix}\begin{pmatrix}c_{1}\\
c_{2}
\end{pmatrix} & = & \begin{pmatrix}\left\{ 27,_{0,12}-1\right\} \\
\left\{ 4,_{0,12}1\right\} 
\end{pmatrix},
\end{eqnarray*}

\end_inset

откуда получаем, что система совместна и младшие коэффициенты 
\begin_inset Formula $f_{8}$
\end_inset

 можно получить на основе выражения 
\begin_inset Formula 
\[
_{0,12}1zf_{3}+{}_{0,12}-1yf_{2}=
\]

\end_inset


\begin_inset Formula 
\[
={}_{0,12}1z\left(xy^{2}+{}_{0,1}1x+1\right)+{}_{0,12}-1y\left(xyz\right)=
\]

\end_inset

 
\begin_inset Formula 
\[
={}_{0,24}0xy^{2}z+{}_{0,232}1xz+{}_{0,12}1z
\]

\end_inset

После замены двух старших коэффициентов будет получено следующее приближённое
 выражение, дающее многочлен с единичным старшим коэффициентом:
\begin_inset Formula 
\[
\poly\left(f_{8}\right)=xz+{}_{0,12}1z
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Оценка вероятности модулярного нуля
\end_layout

\begin_layout Standard
В случае появления в процессе редукции матрицы для решения системы элемента
 с необратимым приближённым коэффициентом и нулевым модулярным такой элемент
 трактуется как символический нуль.
 То есть предполагается, что если проводить редукцию символическим методом,
 рассматривая все коэффициенты с ненулевой вариацией как параметры 
\begin_inset Formula $\left\{ a_{i}\right\} $
\end_inset

, на соответствующем месте будет тождественно нулевой многочлен над 
\begin_inset Formula $\mathbb{C}$
\end_inset

.
 Однако это лишь предположение, и возможна ситуация, описываемая следующим
 определением.
\end_layout

\begin_layout Definition
Коэффициент, возникающий в процессе редукции матрицы называется 
\emph on
модулярным нулём
\emph default
, если соответствующий многочлен над 
\begin_inset Formula $\mathbb{C}$
\end_inset

 не является тождественно нулевым, но при этом обнуляется при подстановке
 конкретных модулярных констант.
\end_layout

\begin_layout Standard
Для оценки вероятности появления такой ситуации определим как именно выбираются
 простой модуль 
\begin_inset Formula $p$
\end_inset

 и коэффициенты на месте приближённых чисел с ненулевой вариацией.
 Выбор модуля осуществляется равновероятно среди конечного множества из
 
\begin_inset Formula $N_{p}$
\end_inset

 простых чисел вида 
\begin_inset Formula $4k+3$
\end_inset

 больших фиксированного 
\begin_inset Formula $P_{0}\in\mathbb{N}$
\end_inset

.
 Каждый из варьируемых коэффициентов равновероятно выбирается из 
\begin_inset Formula $p^{2}$
\end_inset

 элементов поля.
\end_layout

\begin_layout Standard
Рассмотрим процесс решения СЛАУ в символическом случае.
\end_layout

\begin_layout Theorem
Рассмотрим СЛАУ над 
\begin_inset Formula $\mathbb{C}$
\end_inset

, содержащую в качестве входных данных систему из 
\begin_inset Formula $R$
\end_inset

 строк и 
\begin_inset Formula $C$
\end_inset

 столбцов, элементами которой являются одночлены полной степени не выше
 1 -- то есть 
\begin_inset Formula $\mathbb{C}$
\end_inset

-константы, и мономы с коэффициентом, содержащие одну переменную.
 Тогда после проведения первого этапа метода Гаусса, приводящему матрицу
 системы к верхнетреугольному виду, элементы этой системы будут представляться
 многочленами степени не выше 
\begin_inset Formula $2^{R}$
\end_inset

, содержащими не более 
\begin_inset Formula $2^{2^{R}-1}$
\end_inset

 мономов.
\end_layout

\begin_layout Proof
Для приведения к верхнетреугольному виду матрицы с 
\begin_inset Formula $R$
\end_inset

 строками требуется 
\begin_inset Formula $R$
\end_inset

 операций вида 
\begin_inset Quotes fld
\end_inset

Редуцировать все строки с ведущим элементов в столбце 
\begin_inset Formula $c'$
\end_inset

 по выбранной строке 
\begin_inset Formula $r'$
\end_inset

, ведущий элемент которой также расположен в столбце 
\begin_inset Formula $c'$
\end_inset

.
 При этом ведущие элементы изменяемых строк становятся нулевыми, а остальные
 преобразуются по формуле 
\begin_inset Formula 
\[
m_{r,c}\rightarrow m_{r',c'}m_{r,c}-m_{r,c'}m_{r,c'}
\]

\end_inset

.
\end_layout

\begin_layout Proof
Будем доказывать по индукции следующее утверждение: после 
\begin_inset Formula $s$
\end_inset

 таких операций элементы матрицы представляются многочленами степени не
 выше 
\begin_inset Formula $2^{s}$
\end_inset

, содержащими не более 
\begin_inset Formula $2^{2^{s}-1}$
\end_inset

 мономов.
 База индукции при 
\begin_inset Formula $s=0$
\end_inset

 выполняется, поскольку оба из ограничивающих чисел обращаются в единицу.
 Выполнимость шага индукции следует из формулы для 
\begin_inset Formula $m_{r,c}$
\end_inset

 -- степень новых элементов превышает степень элементов прошлого шага не
 более чем в 2 раза, а максимальное число мономов 
\begin_inset Formula $M_{s}$
\end_inset

 ограничено 
\begin_inset Formula $2M_{s-1}^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
При проведении процесса решения СЛАУ каждая строка матрицы единственный
 раз применяется как редуцирующая.
 Именно в этот момент представляет интерес вопрос о появлении модулярного
 нуля.
 Рассмотрим произведение всех ненулевых многочленов, стоящих при проведении
 в символическом случае на тех местах, где модулярные коэффициенты сравниваются
 с нулём.
 Необходимым и достаточным условием отсутствия символических нулей является
 неравенство этого многочлена нулю при подстановке модулярных чисел в качестве
 параметров 
\begin_inset Formula $\left\{ a_{i}\right\} $
\end_inset

.
 Обозначим его за 
\begin_inset Formula $A\in\mathbb{C}\left[a_{i}\right]$
\end_inset

.
 Его степень ограничена 
\begin_inset Formula $R2^{R}$
\end_inset

, а число мономов 
\begin_inset Formula $2^{R2^{R}-1}<2^{R2^{R}}$
\end_inset

.
 Поскольку коэффициенты с нулевой вариацией выражаются целыми числами, они
 оказывают влияние на максимальный коэффициент многочлена 
\begin_inset Formula $A$
\end_inset

.
 Если все постоянные коэффициенты из 
\begin_inset Formula $\mathbb{C}$
\end_inset

 во входных данных не превышают по модулю 
\begin_inset Formula $Z_{0}\in\mathbb{N}$
\end_inset

, то он может быть оценен по модулю сверху значением
\begin_inset Formula $A_{0}=Z_{0}^{R2^{R}}2^{R2^{R}}=(2Z_{0})^{R2^{R}}$
\end_inset

.
 Оценим, на какое максимальное количество простых чисел, больших 
\begin_inset Formula $P_{0}$
\end_inset

 может делить все коэффициенты 
\begin_inset Formula $A$
\end_inset

.
 Минимальный модуль коэффициента не превышает 
\begin_inset Formula $A_{0}$
\end_inset

, и значит не может делиться на более чем 
\begin_inset Formula $N_{d}=\log_{P_{0}}A_{0}$
\end_inset

 таких простых.
 Оценка зависит максимального модуля во входных данных, числа строк матрицы
 и 
\begin_inset Formula $P_{0}:$
\end_inset

 
\begin_inset Formula 
\[
N_{d}\left(P_{0},Z_{0},R\right)=\log_{P_{0}}A_{0}=R2^{R}\log_{P_{0}}2Z_{0}.
\]

\end_inset

Значит, для того чтоб получить вероятность тождественного обнуления многочлена
 в модулярном случае, меньше чем 
\begin_inset Formula $\alpha$
\end_inset

, необходимо взять 
\begin_inset Formula $N_{p}>\frac{N_{d}}{\alpha}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Оценку на 
\begin_inset Formula $P_{0}$
\end_inset

 получим из требования на низкую вероятность того, что при подстановке конкретны
х значений в ненулевой модулярный многочлен получается ненулевое значение.
 Докажем для этого следующую теорему.
\end_layout

\begin_layout Theorem
Ненулевой многочлен 
\begin_inset Formula $g$
\end_inset

 степени не выше 
\begin_inset Formula $r$
\end_inset

 от 
\begin_inset Formula $n$
\end_inset

 переменных над конечным полем из 
\begin_inset Formula $q$
\end_inset

 имеет не более 
\begin_inset Formula $q^{n-1}rn$
\end_inset

 наборов из 
\begin_inset Formula $n$
\end_inset

 значений, являющихся корнями.
\end_layout

\begin_layout Proof
Доказательство будем проводить по индукции по числу переменных.
 Для многочлена от одной переменной над конечным полем число корней не превышает
 его степени 
\begin_inset Formula $r$
\end_inset

, что даёт базу индукции.
 Для доказательства шага индукции рассмотрим максимальную (возможно нулевую)
 степень 
\begin_inset Formula $x_{n}^{s}$
\end_inset

, входящую в 
\begin_inset Formula $g$
\end_inset

.
 Вынося 
\begin_inset Formula $x_{n}^{s}$
\end_inset

 за скобки из содержащих её мономов мы получим разложение 
\begin_inset Formula 
\[
g\left(x_{1},\dots,x_{n}\right)=x_{n}^{s}g'\left(x_{1},\dots,x_{n-1}\right)+g''\left(x_{1},\dots,x_{n}\right).
\]

\end_inset

Число наборов из 
\begin_inset Formula $n-1$
\end_inset

 переменной, обнуляющих 
\begin_inset Formula $g'$
\end_inset

 не превышает 
\begin_inset Formula $q^{n-2}r(n-1)$
\end_inset

 по предположению индукции.
 Каждый из них может быть дополнен 
\begin_inset Formula $q$
\end_inset

 способами до 
\begin_inset Formula $n-$
\end_inset

набора.
 Поэтому, общее число наборов корней, образуемых таким образом не превышает
 
\begin_inset Formula $q^{n-1}r(n-1)$
\end_inset

.
\end_layout

\begin_layout Proof
Все остальные наборы 
\begin_inset Formula $n-1$
\end_inset

 переменной не обнуляют 
\begin_inset Formula $g'$
\end_inset

, и значит подстановка соответствующих значений в 
\begin_inset Formula $g$
\end_inset

 даст ненулевой многочлен от единственной переменной 
\begin_inset Formula $x_{n}$
\end_inset

.
 Количество его корней не превышает 
\begin_inset Formula $r$
\end_inset

.
 Число наборов корней, образуемых таким образом, не превышает 
\begin_inset Formula $q^{n-1}r$
\end_inset

.
 Суммируя это с оценкой на количество корней предыдущего типа мы получаем
 оценку из утверждения теоремы.
\end_layout

\begin_layout Theorem
Доля наборов, дающих ноль при подстановке в многочлен степени не выше 
\begin_inset Formula $r$
\end_inset

 от 
\begin_inset Formula $n$
\end_inset

 переменных над конечным полем из 
\begin_inset Formula $q$
\end_inset

 элементов, по отношению ко всем возможным наборам не превышает 
\begin_inset Formula $\frac{rn}{q}$
\end_inset

.
\end_layout

\begin_layout Proof
Вытекает из результата предыдущей теоремы делением на общее число наборов
 
\begin_inset Formula $q^{n}$
\end_inset


\end_layout

\begin_layout Standard
Применяя эту оценку к многочлену 
\begin_inset Formula $A$
\end_inset

 получаем, что вероятность получить модулярный ноль подстановкой произвольных
 констант в ненулевой модулярный многочлен не превышает 
\begin_inset Formula $\frac{R2^{R}V}{P_{0}^{2}}$
\end_inset

, где за 
\begin_inset Formula $V$
\end_inset

 обозначено число переменных, для которых подставляются значения.
 Отсюда получается, что для получения вероятности обнуления при подстановке
 значений меньше чем 
\begin_inset Formula $\beta$
\end_inset

 необходимо взять 
\begin_inset Formula 
\[
P_{0}>P_{d}(R,V,\beta)=\sqrt{\frac{R2^{R}V}{\beta}}.
\]

\end_inset


\end_layout

\begin_layout Subsection
Методы дополнительных переменных
\end_layout

\begin_layout Standard
Рассмотренные выше модулярные способы борьбы с нулями имеют серьёзный недостаток
 -- их корректность носит вероятностный характер, а оценки на размеры простого
 модуля, позволяющего гарантировать приемлемую на практике вероятность ошибки,
 могут оказываться довольно большими.
\end_layout

\begin_layout Subsubsection
Применение расширенного базиса к задаче решения системы
\end_layout

\begin_layout Standard
Принципиально иные методы борьбы с устранимыми нулями основаны на идее внесения
 в идеал многочленов вида 
\begin_inset Formula $t_{i}-y_{i}$
\end_inset

, где 
\begin_inset Formula $t_{i}\in\mathbb{T}$
\end_inset

, а 
\begin_inset Formula $y$
\end_inset

 -- новая переменная.
 Используя терминологию работы 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

 можно сказать, что добавление таких многочленов превращает идеал 
\begin_inset Formula $I=\left(f_{1},\ldots,f_{m}\right)\subset\mathcal{K}\left[x_{1},\dots,x_{n}\right]=\mathcal{P}$
\end_inset

 в расширенный идеал 
\begin_inset Formula $I^{E}=\left(f_{1},\ldots,f_{m},t_{1}-y_{1},\ldots,t_{s}-y_{s}\right)\subset\mathcal{K}\left[x_{1},\dots,x_{n},y_{1},\dots,y_{s}\right]=\mathcal{P}^{E}$
\end_inset

.
 Поэтому алгоритмы использующие данный метод находят базис Грёбнера не для
 идеала 
\begin_inset Formula $I$
\end_inset

, а для 
\begin_inset Formula $I^{E}$
\end_inset

.
 Предложение 4.2 из 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

 показывает, что нули сохраняются при расширении идеала, и, таким образом,
 найдя нули расширенного идеала можно получить решение системы.
 
\end_layout

\begin_layout Standard
Однако возможно и более прозрачное применение базиса расширенного идеала
 непосредственно к алгоритму 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:action-matrix-method"

\end_inset

, выполняемому для 
\begin_inset Formula $I$
\end_inset

.
 
\end_layout

\begin_layout Definition
Назовём 
\emph on
оператором сужения
\emph default
 отображение колец
\begin_inset Formula $e^{-}:\mathcal{P}^{E}\rightarrow\mathcal{P}$
\end_inset

, осуществляющее замену всех 
\begin_inset Formula $y_{i}$
\end_inset

 на 
\begin_inset Formula $t_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Обозначим за 
\begin_inset Formula $M^{E}\subset\mathcal{P}^{E}$
\end_inset

 множество мономов, не делящихся на 
\begin_inset Formula $\HM\left(I^{E}\right)$
\end_inset

.
\end_layout

\begin_layout Definition
Назовём редукцию по базису Грёбнера 
\begin_inset Formula $I^{E}$
\end_inset

 
\emph on
оператором нормальной формы 
\begin_inset Formula $N_{I^{E}}$
\end_inset


\emph default
.
 Он позволяет найти для любого многочлена из 
\begin_inset Formula $\mathcal{P}^{E}$
\end_inset

 координаты в 
\begin_inset Formula $B^{E}$
\end_inset

 -- базисе 
\begin_inset Formula $\mathcal{P}^{E}/I^{E}$
\end_inset

, который задаётся представителями из 
\begin_inset Formula $M^{E}$
\end_inset

.
\end_layout

\begin_layout Theorem
Множество 
\begin_inset Formula $e^{-}\left(M^{E}\right)\subset\mathbb{T}$
\end_inset

 является базисом в 
\begin_inset Formula $\mathcal{P}/I$
\end_inset

, а ограничение 
\begin_inset Formula $N_{I^{E}}$
\end_inset

 на 
\begin_inset Formula $\mathcal{P}$
\end_inset

 позволяет найти координаты в нём.
\end_layout

\begin_layout Proof
Координаты не меняются от сужения:
\begin_inset Formula $N_{I^{E}}\left(f\right)=N_{I^{E}}\left(e^{-}\left(f\right)\right)\,\forall f$
\end_inset

.
 Значит в качестве представителей базиса 
\begin_inset Formula $B^{E}$
\end_inset

 могут быть взяты элементы 
\begin_inset Formula $e^{-}\left(M^{E}\right)\subset\mathcal{P}$
\end_inset

.
 Они являются линейно независимыми в 
\begin_inset Formula $\mathcal{P}^{E}/I^{E}$
\end_inset

 и порождают его.
 Их линейная независимость в 
\begin_inset Formula $\mathcal{P}/I$
\end_inset

 вытекает отсюда немедленно.
 Любой элемент 
\begin_inset Formula $\mathcal{P}/I$
\end_inset

, заданный представителем 
\begin_inset Formula $p$
\end_inset

 из 
\begin_inset Formula $\mathcal{P}$
\end_inset

 выражается данный базис, поскольку выполняется его принадлежность сумме
 с линейной оболочкой: 
\begin_inset Formula 
\[
p\in I^{E}+\left\langle M^{E}\right\rangle 
\]

\end_inset

что после сужения даёт
\begin_inset Formula 
\[
p=e^{-}\left(p\right)\in e^{-}\left(I^{E}+\left\langle M^{E}\right\rangle \right)=I+e^{-}\left(\left\langle M^{E}\right\rangle \right)=I+\left\langle e^{-}\left(M^{E}\right)\right\rangle .
\]

\end_inset


\end_layout

\begin_layout Proof
Ограничение 
\begin_inset Formula $N_{I^{E}}$
\end_inset

 на 
\begin_inset Formula $\mathcal{P}$
\end_inset

 является искомой нормальной формой, дающей координаты в 
\begin_inset Formula $e^{-}\left(M^{E}\right)$
\end_inset

 поскольку координаты не меняются от применения 
\begin_inset Formula $e^{-}$
\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\[
p=I^{E}+\sum_{j}k_{j}m_{j}\Longrightarrow e^{-}\left(p\right)=I+\sum_{j}k_{j}\left(m_{j}\right).
\]

\end_inset


\end_layout

\begin_layout Standard
Базис и нормальная форма, упоминаемые в формулировке доказанной теоремы,
 в точности оказываются понятиями необходимыми для работы алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:action-matrix-method"

\end_inset

.
\end_layout

\begin_layout Standard
Существует несколько приёмов, позволяющих повлиять на мономиальный порядок
 в возникающих многочленах добавлением новых многочленов рассмотренного
 вида.
 Работа 
\begin_inset CommandInset citation
LatexCommand cite
key "NumericalComputationGB"

\end_inset

 предлагает умножение некоторых мономов на вновь добавляемую переменную
 
\begin_inset Formula $\varepsilon$
\end_inset

 путём вводе многочлена 
\begin_inset Formula $1-\varepsilon$
\end_inset

.
 Этот метод позволяет в процессе работы алгоритмов, не использующих сигнатуры,
 при возникновении необратимого коэффициента при старшем мономе переносить
 его в конец многочлена.
 Однако, доказательство корректности этого метода требует внесения существенных
 дополнений в доказательство корректности применяемого алгоритма, и его
 применимость к сигнатурным методам остаётся открытым вопросом.
\end_layout

\begin_layout Standard
Цикл работ 
\begin_inset CommandInset citation
LatexCommand cite
key "NumericalComputationOfGBVarSubsttution,ArtificialDiscontinuities,GroebnerInExtFields"

\end_inset

 предлагает метод, применимый и к сигнатурным алгоритмам.
 При каждом обнаружении многочлена 
\begin_inset Formula $p$
\end_inset

 с необратимым старшим коэффициентом он добавляет во входные данные многочлен
 
\begin_inset Formula $\HM\left(p\right)-y_{i}$
\end_inset

 с новой переменной 
\begin_inset Formula $y_{i}$
\end_inset

 и запускает алгоритм с начала.
 Конечность числа необходимых перезапусков не была доказана, однако практические
 эксперименты показали, что их число как правило является небольшим.
 Но сама необходимость перезапуска приводит к тому, что некоторые уже проведённы
е вычисления будут проведены вновь.
 
\end_layout

\begin_layout Standard
Предлагаемый ниже метод в каком-то смысле совмещает два вышеописанных подхода:
 он является применимым к основанным на сигнатурах однопроходным алгоритмам,
 не требует внесения серьёзных изменений в обоснование их корректности и
 позволяет продолжать алгоритм, не начиная его сначала.
 Основная идея состоит в том, чтоб назначать добавляемому во входные данные
 многочлену такую сигнатуру, чтоб ход алгоритма до момента добавления многочлена
 от него не зависел.
 
\end_layout

\begin_layout Subsubsection
Вещественно-взвешенный порядок
\end_layout

\begin_layout Standard
Однопроходные сигнатурные алгоритмы могут работать с произвольным порядком
 на сигнатурах.
 Однако большинство распространённых порядков определяют сигнатуры входных
 многочленов на основе их порядка и старших мономов.
 Для реализации идеи добавления многочлена во входные данные в процессе
 работы алгоритма потребуется более общий порядок, позволяющий назначать
 добавляемому многочлену достаточно произвольное значение сигнатуры.
 Это становится возможным благодаря применению взвешенного порядка, дополненного
 возможностью использовать в качестве индекса сигнатуры вещественные числа
 вместо целых.
 
\end_layout

\begin_layout Definition
Вещественно-взвешенным порядком на сигнатурах называется порядок с двумя
 параметрами 
\begin_inset Formula $w=(w_{1},\dots,w_{m})\in\mathbb{T}^{m}$
\end_inset

 и 
\begin_inset Formula $j=(j_{1},\dots,j_{m})\in\mathbb{R}^{m}$
\end_inset

, для которого сравнение сигнатур определяется следующим образом:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\left(t_{1},i_{1}\right)\prec_{w}\left(t_{2},i_{2}\right)\Longleftrightarrow\left[\begin{aligned} & t_{1}w_{i_{1}}\prec t_{2}w_{i_{2}}\\
 & t_{1}w_{i_{1}}=t_{2}w_{i_{2}},j_{i{}_{1}}<j_{i_{2}}
\end{aligned}
\right..
\]

\end_inset


\end_layout

\begin_layout Standard
Любой взвешенный порядок является частным случаем вещественно-взвешенного
 с параметрами 
\begin_inset Formula $j_{i}=i$
\end_inset

.
\end_layout

\begin_layout Definition
Пусть задан набор из 
\begin_inset Formula $m$
\end_inset

 входных многочленов и вещественно-взвешенный порядок на нём с параметрами
 
\begin_inset Formula $(w_{1},\dots,w_{m})$
\end_inset

 и 
\begin_inset Formula $(j_{1},\dots,j_{m})$
\end_inset

.
 Назовём 
\emph on
дополнением с сигнатурой предшествующей 
\emph default

\begin_inset Formula $\left(t,i\right)$
\end_inset

 добавление во входное множество на место 
\begin_inset Formula $m+1$
\end_inset

 многочлена, параметры сигнатуры которого определяются как 
\begin_inset Formula $w_{m+1}=t\cdot w_{i},\, j_{m+1}=\frac{j_{i}+\max\left\{ j_{k}\in j_{1},\dots,j_{m}|j_{k}<j_{i}\right\} }{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Сигнатура добавленного входного многочлена оказывается строго максимальной
 в множестве сигнатур, меньших 
\begin_inset Formula $\left(t,i\right)$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Adding-polys"

\end_inset

Рассмотрим шаг 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:-after-reduce-sstep"

\end_inset

 на 
\begin_inset Formula $N$
\end_inset

-й итерации алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, выполняющегося со взвешенным порядком порядок 
\begin_inset Formula $\prec_{w}$
\end_inset

 с параметрами 
\begin_inset Formula $(w_{1},\dots,w_{m})$
\end_inset

 и 
\begin_inset Formula $(j_{1},\dots,j_{m})$
\end_inset

.
 Пусть на нём был получен многочлен 
\begin_inset Formula $p$
\end_inset

 сигнатуры 
\begin_inset Formula $\left(t,i\right)$
\end_inset

.
 Тогда при дополнении входного множества многочленом со старшим мономом
 
\begin_inset Formula $\HM\left(p\right)$
\end_inset

и сигнатурой предшествующей 
\begin_inset Formula $\left(t,i\right)$
\end_inset

 и перезапуске алгоритма с начала, первые 
\begin_inset Formula $N-1$
\end_inset

 итераций пройдут без изменений, а редукции произведённые на итерации 
\begin_inset Formula $N$
\end_inset

 будут произведены на итерации 
\begin_inset Formula $N+1$
\end_inset


\end_layout

\begin_layout Proof
После добавления входного многочлена в работе алгоритма произойдёт следующее:
\end_layout

\begin_deeper
\begin_layout Itemize
на этапе инициализации в 
\begin_inset Formula $B$
\end_inset

 добавится многочлен 
\begin_inset Formula $f_{m+1}$
\end_inset

, а в 
\begin_inset Formula $R$
\end_inset

 -- нули с сигнатурами, не меньшими 
\begin_inset Formula $\left(\HM\left(f_{j}\right),m+1\right),j\leqslant m$
\end_inset

.
\end_layout

\begin_layout Itemize
итерации главного цикла 
\begin_inset Formula $1\dots N-1$
\end_inset

 пройдут без изменений, поскольку добавленный в 
\begin_inset Formula $B$
\end_inset

 многочлен 
\begin_inset Formula $f_{m+1}$
\end_inset

 имеет сигнатуру, превышающую сигнатуру обрабатываемых на этих итерациях
 многочленах
\end_layout

\begin_layout Itemize
на 
\begin_inset Formula $N$
\end_inset

-й итерации многочлен 
\begin_inset Formula $f_{m+1}$
\end_inset

 перемещается из 
\begin_inset Formula $B$
\end_inset

 в 
\begin_inset Formula $R$
\end_inset

.
 Он не может быть редуцирован, поскольку на итерации 
\begin_inset Formula $N$
\end_inset

 до добавления многочлен с таким же старшим мономом и большей сигнатурой
 
\begin_inset Formula $\left(t,i\right)$
\end_inset

 не редуцировался по такому же множеству
\begin_inset Formula $R$
\end_inset

 при редукции.
\end_layout

\begin_layout Itemize
на 
\begin_inset Formula $N+1$
\end_inset

-й итерации будет рассматриваться многочлен, дающий 
\begin_inset Formula $p$
\end_inset

 в процессе редукции.
 Но после добавления редукция не остановится на данном этапе, а будет продолжена
 редукцией 
\begin_inset Formula $p$
\end_inset

 по 
\begin_inset Formula $f_{m+1}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
Таким образом, доказано, что при добавлении многочлена с указанным старшим
 мономом вместо перезапуска алгоритма возможно добавление многочлена сразу
 в 
\begin_inset Formula $R$
\end_inset

 и продолжение редукции.
\end_layout

\begin_layout Standard
Для применимости этой теоремы к алгоритму, необходимо чтоб добавлнмый многочлен
 
\begin_inset Formula $\HM\left(p\right)-y$
\end_inset

 имел старший моном 
\begin_inset Formula $\HM\left(p\right)$
\end_inset

.
 Для достижения этого будем продолжать мономиальный порядок на 
\begin_inset Formula $y$
\end_inset

 так, чтоб 
\begin_inset Formula $y$
\end_inset

 был 
\begin_inset Formula $\prec$
\end_inset

-меньше всех имеющихся переменных.
 При 
\begin_inset Formula $\HM\left(p\right)\ne1$
\end_inset

 такое продолжение порядка гарантирует, что 
\begin_inset Formula $y\prec\HM\left(p\right)$
\end_inset

.
 Однако при 
\begin_inset Formula $\HM\left(p\right)=1$
\end_inset

 старшим членом всегда будет оказываться 
\begin_inset Formula $y$
\end_inset

, и добавление многочлена со старшим мономом нужного вида совершить не удастся.
 
\end_layout

\begin_layout Subsubsection
Алгоритм для приближённых вычислений
\end_layout

\begin_layout Standard
Эти рассуждения позволяет сформулировать алгоритм, работающий с приближёнными
 многочленами, строящий расширенный базис Грёбнера.
 Его входные данные совпадают с входными данными алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, с тем ограничением, что порядок 
\begin_inset Formula $\prec_{a}$
\end_inset

 на сигнатурах является вещественно-взвешенным порядком с некоторыми параметрами.
\end_layout

\begin_layout Paragraph

\family typewriter
\begin_inset CommandInset label
LatexCommand label
name "par:ApproxSignatureGroebner"

\end_inset

ApproxSignatureGroebner
\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow\cup_{1\leqslant i<j\leqslant m}\left\{ \left(\max_{\prec_{a}}\left(\left(\HM(f_{i}),j\right),\left(\HM(f_{j}),i\right)\right),0\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow\{((1,1),f_{1}),((1,2),f_{2}),\dots,((1,m),f_{m})\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $k\leftarrow0$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $B\neq\varnothing$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(\sigma,p)\leftarrow$
\end_inset

 элемент 
\begin_inset Formula $B$
\end_inset

 с 
\begin_inset Formula $\prec_{a}$
\end_inset

-минимальной сигнатурой
\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\setminus\{b\in B,\Sig(b)=\sigma\}$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
infinite loop:
\end_layout

\begin_deeper
\begin_layout Enumerate

\series bold
do while 
\begin_inset Formula $\exists r\in R\, r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset

 
\family typewriter
ApproxReduce
\family default
(
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $\GVWg$
\end_inset

-максимальный элемент 
\begin_inset Formula $r$
\end_inset

 среди указанных в условии цикла)
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
if 
\series default

\begin_inset Formula $\HC\left(p\right)$
\end_inset

 обратим 
\series bold
or 
\series default

\begin_inset Formula $p=0$
\end_inset


\series bold
: break infinite loop
\end_layout

\begin_layout Enumerate

\series bold
if 
\series default

\begin_inset Formula $\HM\left(p\right)=1$
\end_inset


\series bold
: exit(
\series default

\begin_inset Quotes fld
\end_inset

Алгоритм неприменим к данной задаче
\begin_inset Quotes frd
\end_inset


\series bold
)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $k\leftarrow k+1$
\end_inset


\end_layout

\begin_layout Enumerate
Расширим набор параметров порядка 
\begin_inset Formula $\prec_{a}$
\end_inset

 на сигнатурах на индекс 
\begin_inset Formula $m+k$
\end_inset

 в соответствии с правилом добавления многочлена с сигнатурой предшествующей
 
\begin_inset Formula $\Sig\left(p\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Расширим порядок 
\begin_inset Formula $\prec$
\end_inset

 на мономах на переменную 
\begin_inset Formula $y_{k}$
\end_inset

, положив её меньше всех остальных переменных
\end_layout

\begin_layout Enumerate
\begin_inset Formula $f_{m+k}\leftarrow\HM\left(p\right)-y_{k}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\left(1,m+k\right),f_{m+k}\right)\right\} \cup_{1\leqslant i<m+k}\left\{ \left(\max_{\prec_{a}}\left(\left(\HM(f_{i}),k\right),\left(\HM(f_{m+k}),i\right)\right),0\right)\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
if
\series default

\begin_inset Formula $p\ne0$
\end_inset


\series bold
: 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $p\leftarrow$
\end_inset


\family typewriter
ApproxNormalize
\begin_inset Formula $\left(p\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
for 
\series default

\begin_inset Formula $\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$
\end_inset


\series bold
:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Formula $R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\Sig(r)|\Sig(b)\}$
\end_inset

, где под делимостью сигнатур, подразумевается делимость определённая для
 
\begin_inset Formula $\mathbf{T}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
return
\series default
 
\begin_inset Formula $\{\poly(r)\,|\, r\in R,\poly(r)\ne0\}$
\end_inset


\end_layout

\begin_layout Theorem
Если алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:ApproxSignatureGroebner"

\end_inset

 останавливается, то он возвращает базис Грёбнера расширения идеала 
\begin_inset Formula $\left(f_{1},\dots,f_{m}\right)$
\end_inset


\end_layout

\begin_layout Proof
Поскольку все добавляемые в процессе работы алгоритма многочлены удовлетворяют
 теореме 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Adding-polys"

\end_inset

, результат данного алгоритма будет совпадать с результатом алгоритма 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, применённого к расширенному множеству входных данных, про который известно
 что он выдаёт базис Грёбнера.
\end_layout

\begin_layout Standard
Вопрос условий остановки данного алгоритма остаётся открытым.
\end_layout

\begin_layout Part*
Заключение
\end_layout

\begin_layout Standard
Главным результатом данной работы является построение методики применения
 одного из наиболее эффективных алгоритмов вычисления базисов Грёбнера к
 задачам численного решения полиномиальных систем.
 Две предлагаемых методики -- внесение дополнительных переменных и модулярные
 вычисления -- являются независимыми и допускают совместное применение.
\end_layout

\begin_layout Standard
Многие из существующих методик вычисления базисов Грёбнера в приближённом
 случае позволяют основываться на любом алгоритме вычисления точного базиса
 Грёбнера, вызывая его в процессе своей работы.
 Таковы алгоритмы исчерпывающего базиса Грёбнера 
\begin_inset CommandInset citation
LatexCommand cite
key "ComprehenciveGroebnerFastViaGroebner"

\end_inset

 и методика замены мономов, предложенная в 
\begin_inset CommandInset citation
LatexCommand cite
key "GroebnerInExtFields"

\end_inset

.
 Преимуществом таких методик является лёгкий переход на использование любого
 из имеющихся алгоритмов вычисления точного базиса Грёбнера, а недостатком
 -- недостаточно тесное взаимодействие с ходом алгоритма, в результате чего
 происходит много его отдельных вызовов.
 При этом возникает неэффективное поведение: к примеру, перезапуск алгоритмов
 в методе замены мономов приводит к дублированию многих вычислений, а вычисление
 исчерпывающего базиса может рассматривать области значений параметров,
 находящиеся за пределами возможных значений приближённых входных данных,
 вычисляя таким образом базисы Грёбнера для не интересных в частной задаче
 случаев.
\end_layout

\begin_layout Standard
Были проведены исследования алгоритма F5, позволившие разрешить открытый
 ранее вопрос об остановке алгоритма в случае нерегулярных входных данных.
 Сам по себе этот результат не имеет большой ценности, поскольку для предложенны
х позже не менее эффективных сигнатурных алгоритмов проблема остановки уже
 была решена.
 Однако доказанные наряду с фактом установки утверждения позволили сформулироват
ь несколько принципов алгоритма F5, не вытекающих из его классической формулиров
ки явно, на основе которых был построен сигнатурный алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

, достаточно простой и удобный для интеграции с методиками приближённых
 вычислений.
\end_layout

\begin_layout Standard
Оценка эффективности данного алгоритма по сравнению с другими сигнатурными
 алгоритмами произведена в части минимальности порождаемого S-базиса, что
 показывает лишь отсутствие в алгоритме отбрасываемых позже вычислений,
 но теоретически обоснованное сравнение эффективностей по количеству операций
 остаётся открытым вопросом.
 При интеграции в алгоритм модулярного метода ход алгоритма не меняется,
 но на каждом шаге производятся дополнительные вычисления для приближённых
 коэффициентов.
 Для некоторых входных данных модулярный метод не позволит продолжить вычисления
, даже при наличии непрерывного решения.
 В таком случае возможно применение метода дополнительных переменных.
 Добавление многочлена воздействует на дальнейший ход алгоритма, но это
 изменение делает продолжение алгоритма соответствующим работе неизменного
 алгоритма на изменённых входных данных.
 Таким образом, если алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SingleStepSignatureGroebner"

\end_inset

 с применением двух рассматриваемых методик для приближённых вычислений
 завершается, то его ход оказывается эквивалентен ходу данного алгоритма
 без этих методик на некоторых расширенных входных данных.
\end_layout

\begin_layout Standard
При этом для обоих предложенных методик остаются неясными вопросы обоснования
 их эффективности.
 В модулярном случае данная на простой модуль оценка, необходимая для достижения
 приемлемой на практике вероятности ошибки, может оказываться довольно большой.
 Предположительно, в большинстве случаев можно брать сравнительно небольшие
 модули не превышающие 
\begin_inset Formula $2^{64}$
\end_inset

, с которыми наиболее эффективно работают современные вычислительный процессоры,
 однако этот вопрос остаётся открытым.
 Помимо этого неясным остаётся то какую долю времени на фоне общего времени
 работы алгоритма может занимать метод Гаусса, используемый при переходе
 от модулярных вычислений к приближённым.
 Внесение дополнительных переменных оставляет ещё более важный открытый
 вопрос об остановке алгоритма.
 Поэтому, хотя методики приближённых вычислений и были тесно интегрированы
 в алгоритм, однозначно гарантировать их эффективность нельзя.
\end_layout

\begin_layout Standard
С другой стороны, известные методы приближённых вычислений базисов Грёбнера
 также не дают подобных оценок.
 Косвенно можно предположить, что полиномиальные выражения коэффициентов
 зависящего от параметров ответа, который обязаны выдать алгоритмы вычисления
 исчерпывающего базиса Грёбнера, в определённом смысле соответствуют вычислениям
, проводимым в модулярном случае, а значит последние будут не медленнее
 таких алгоритмов, поскольку время работы алгоритма не может быть меньше
 времени формирования ответа.
 Обе предложенные методики обладают преимуществами, не связанными со скоростью.
 Для модулярного метода можно отметить способствующее повышению точности
 результата использование численных методов выбора строки при решении системы,
 а для метода дополнительных переменных -- в случае незначительного отличия
 структуры приближённого базиса от точного, отличия в работе приближённого
 алгоритма как правило будут также незначительны по отношению к точному.
\end_layout

\begin_layout Standard
Таким образом, предложенные методики оказываются корректными способами вычислени
я приближённого базиса Грёбнера, сравнительная эффективность которых остаётся
 неясной.
 Поэтому, при выборе метода решения для той или иной приближённой задачи,
 выбор между приведёнными в этой работе алгоритмами и известными ранее должен
 производиться на основе анализа структуры и требуемого результата задачи.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Эмпирическое сравнение данной реализации с другими алгоритмами вычисления
 базисов Грёбнера, реализованных Кристианом Эдером подтвердили следующие
 соображения:
\end_layout

\begin_layout Itemize
алгоритм 
\begin_inset CommandInset ref
LatexCommand nameref
reference "par:SimpleSignatureGroebner"

\end_inset

 корректно вычисляет базис Грёбнера;
\end_layout

\begin_layout Itemize
результат содержит не большее число многочленов, чем результат других инкремента
льных алгоритмов, возвращающих S-базис, что согласуется с утверждением о
 минимальности S-базиса;
\end_layout

\begin_layout Itemize
время работы алгоритма оказывается не больше, чем у других инкрементальных
 алгоритмов, основанных на сигнатурах.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "f5_references"
options "bibtotoc,gost/ugost2008"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "LastPage"

\end_inset


\end_layout

\end_body
\end_document
