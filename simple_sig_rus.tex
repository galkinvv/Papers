%% LyX 2.0.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[russian]{article}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\setcounter{secnumdepth}{-1}
\usepackage{babel}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[unicode=true]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}
\AtBeginDocument{\DeclareFontEncoding{T2A}{}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
\theoremstyle{definition}
\newtheorem{defn}[thm]{\protect\definitionname}
\theoremstyle{plain}
\newtheorem{lem}[thm]{\protect\lemmaname}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\vestnikonly}[1]{}
\newcommand{\novestnikonly}[1]{#1}
\vestnikonly{
\usepackage{allerree}

\def\wdeb{0}
\usepackage{nameref}
\usepackage{url}
\let\href\undefined
\newcommand{\href}[2]{\url{#1}}

\newcounter{countergvtheorems}

\renewenvironment{lem}
{\refstepcounter{countergvtheorems}\begin{theorem}{Лемма  \arabic{countergvtheorems}.}}
{\end{theorem}\par{\bf Доказательство.}}

\renewenvironment{thm}
{\refstepcounter{countergvtheorems}\begin{theorem}{Теорема \arabic{countergvtheorems}.}}
{\end{theorem}\par{\bf Доказательство.}}

\renewenvironment{defn}
{\par \refstepcounter{countergvtheorems} {\bf Определение \arabic{countergvtheorems}.}}
{\par}
}%\vestnikonly
\novestnikonly{
\newcommand{\iabstract}[4]{
\begin{abstract}
#3
\footnote{\emph{Keywords:} #4}
\end{abstract}
}
}%\novestnikonly


\DeclareMathOperator{\HC}{HC}
\DeclareMathOperator{\HM}{HM}
\DeclareMathOperator{\LCM}{LCM}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\SIG}{\mathcal{S}}

\AtBeginDocument{
  \def\labelitemi{\normalfont\bfseries{--}}
}

\makeatother

\providecommand{\definitionname}{\inputencoding{koi8-r}пРТЕДЕМЕОЙЕ}
\providecommand{\lemmaname}{\inputencoding{koi8-r}мЕННБ}
\providecommand{\theoremname}{\inputencoding{koi8-r}фЕПТЕНБ}

\begin{document}
\global\long\def\GVWl{<_{\text{H}}}


\global\long\def\GVWg{>_{\text{\textnormal{H}}}}


\global\long\def\eqdef{\overset{\mathrm{_{def}}}{=}}


\global\long\def\equivdef{\overset{\mathrm{_{def}}}{\Leftrightarrow}}


\novestnikonly{


\title{Simple signature-based Groebner basis algorithm}


\author{Galkin Vasily\\
Moscow State University\\
email:\href{mailto: galkin-vv@yandex.ru}{ galkin-vv@yandex.ru}}

\maketitle
\providecommand{\definitionname}{Definition}
\providecommand{\lemmaname}{Lemma}
\providecommand{\theoremname}{Theorem} 
}%\novestnikonly
\vestnikonly{
\cleanbegin 
\def\udk{512}
\ltitle{ПРОСТОЙ ИТЕРАТИВНЫЙ АЛГОРИТМ ВЫЧИСЛЕНИЯ БАЗИСОВ ГРЁБНЕРА, ОСНОВАННЫЙ НА СИГНАТУРАХ} {В.\,В.~Галкин\footnote[1]{{\it Галкин Василий Витальевич} --- асп. каф. алгебры мех.-мат. ф-та МГУ, e-mail: galkin-vv@yandex.ru.}}
}%\vestnikonly
\iabstract
{Данная работа описывает алгоритм вычисления базисов Грёбнера, основанный на использовании отмеченных многочленов и идеях из алгоритма F5. Отличительными особенностями алгоритма по сравнению с аналогами являются простота самого алгоритма и доказательства его корректности, достигнутые без потери эффективности. Это позволяет создать простую реализацию, не уступающую более сложным аналогам по производительности}
{базис Грёбнера, алгоритм F5, отмеченные многочлены}
{This paper presents an algorithm for computing Groebner bases based upon labeled polynomials and ideas from the algorithm F5. The main highlights of this algorithm compared with analogues are simplicity both of the algorithm and of the its correctness proof achieved without loss of the efficiency. This leads to simple implementation which performance is in par with more complex analogues} {Groebner basis, F5 algorithm, labeled polynomials}

Рассмотрим кольцо многочленов $P=k[x_{1},\dots,x_{n}]$ над полем
$k$. Будем предполагать, что на моноиде его мономов $\mathbb{T}$
задан допустимый мономиальный порядок $\prec$. В этом кольце может
быть поставлена задача вычисления базиса Грёбнера для произвольного
идеала $\left(f_{1},\dots,f_{l}\right)$. Один из способов её решения
инкрементальный: последовательно вычисляются базисы идеалов $\left(f_{1},\dots,f_{i}\right),i=2\dots l$
на основе уже вычисленного для идеала $\left(f_{1},\dots,f_{i-1}\right)$
базиса $R_{i-1}$ и многочлена $f_{i}$. Представляемый алгоритм позволяет
выполнить шаг такого вычисления. Таким образом, входные данные для
алгоритма -- это некоторый многочлен $f$ и множество многочленов,
обозначаемое $\left\{ g_{1},\dots,g_{m}\right\} $, являющееся базисом
Грёбнера идеала $I_{0}=\left(g_{1},\dots,g_{m}\right)$. В качестве
результата своей работы алгоритм должен построить множество многочленов
$R$, являющееся базисом Грёбнера идеала $I=\left(g_{1},\dots,g_{m},f\right)$.
Поскольку случаи $f=0\Rightarrow I=I_{0}$ и $\exists i\, g_{i}\in k\Rightarrow I=P$
не представляют интереса, далее предполагается что $f\neq0,\forall i\, g_{i}\notin k.$
Заметим, что в отличии от алгоритма F5, описанного в \cite{FaugereF5},
однородность многочленов не требуется.


\section{Определения}

Введём обозначения: $\mathbb{T}_{0}=\mathbb{T}\cup\left\{ 0\right\} $
-- расширенный нулём моноид мономов. Порядок $\prec$ продолжается
с сохранением вполне упорядоченности на $\mathbb{T}_{0}$ как $\prec_{0}$
определением $\forall t\in\mathbb{T}\, t\succ_{0}0$. Понятие делимости
также расширяется на $\mathbb{T}_{0}$: $t_{1}|t_{2}\eqdef\exists t_{3}\, t_{1}t_{3}=t_{2}$.
Для $p\in P,p\neq0$ старшие по $\prec$ моном и коэффициент обозначим
$\HM(p)\in\mathbb{T}$ и $\HC(p)\in k$. Для нуля -- $\HM(0)\eqdef0\in\mathbb{T}_{0}$,
$\HC(0)\eqdef0\in k$. Наименьшее общее кратное $t_{1},t_{2}\in\mathbb{T}$
обозначим $\LCM(t_{1},t_{2})\in\mathbb{T}$. Далее все определения
даются для фиксированных $I_{0}$ и $f$:
\begin{defn}
\emph{Отмеченным многочленом} называется пара $h=(\sigma,p)\in\mathbb{T}_{0}\times P$,
удовлетворяющая условию корректности: $\exists u\in P\,\HM(u)=\sigma,uf\equiv p\pmod{I_{0}}.$
На отмеченные многочлены распространяются определения старшего монома
$\HM(h)\eqdef\HM(p)$ и коэффициента $\HC(h)\eqdef\HC(p)$. Также
определяются \emph{сигнатура} $\SIG(h)\eqdef\sigma$ и вводится обозначение
многочлена -- второго элемента пары: $\poly(h)\eqdef p$. Множество
отмеченных многочленов обозначается за $H\subset\mathbb{T}_{0}\times P$.
Тривиальными примерами отмеченных многочленов являются $\left(1,f\right)$
и $\left(0,g\right)$ для $g\in I_{0}$. Другим примером отмеченного
многочлена является $\left(\HM(g),0\right)$ для $g\in I_{0}$. Он
корректен, поскольку в качестве $u$ можно взять $g$.\end{defn}
\begin{lem}
Умножение для $h\in H,t\in\mathbb{T}$, заданное как $th\eqdef(t\sigma,tp)\in H,$
корректно.
\end{lem}
Корректность определения проверяется явным нахождением $u$ для $th$.
\begin{defn}
Если для некоторых\emph{ $h'_{1},h_{2}\in H,t\in\mathbb{T}$} выполняется
$\SIG(h'_{1})\succ_{0}\SIG(th_{2}),\HM(h'{}_{1})=\HM(th{}_{2})\neq0,$
то возможна \emph{редукция $h'_{1}$ по $h_{2}$ с сохранением сигнатуры},
дающая в результате многочлен $h_{1}\in H$, равный: 
\[
h_{1}=\left(\SIG(h'_{1}),\poly(h'_{1})+Kt\poly(h_{2})\right),
\]
где коэффициент $K\in k$ взят так, чтобы при сложении сократились
старшие мономы и выполнилось $\HM(h{}_{1})\prec_{0}\HM(h'{}_{1})$.
По сути такая редукция представляет из себя обычную редукцию многочлена
с сокращением старшего монома, дополненную требованием того, что сигнатура
редуктора меньше сигнатуры редуцируемого. Корректность проверяется
как и выше.
\end{defn}
Введём частичный порядок $\GVWl$ на $H$: 
\[
h_{1}=(\sigma_{1},p_{1})\GVWl h_{2}=(\sigma_{2},p_{2})\equivdef\HM(p_{1})\sigma_{2}\prec_{0}\HM(p_{2})\sigma_{1}.
\]


Элементы с нулевой сигнатурой и старшим мономом оказываются экстремумами:
\[
\forall\sigma_{1},\sigma_{2},p_{1},p_{2}\,\left(0,p_{1}\right)\not\GVWl\left(\sigma_{2},p_{2}\right),\,\left(\sigma_{1},0\right)\not\GVWg\left(\sigma_{2},p_{2}\right).
\]

\begin{lem}
Пусть $h_{1},h_{2}\in H,t\in\mathbb{T}$. Тогда $h_{1}\GVWg h_{2}\Leftrightarrow h_{1}\GVWg th_{2}$.
\end{lem}
Выводится из того, что умножение на $t$ одного из сравниваемых отмеченных
многочленов приводит к умножению на $t$ обоих частей в определении
$\GVWg$.
\begin{lem}
Пусть $h_{1},h_{2}\in H,\HM(h_{1})|\HM(h_{2}),\HM(h_{2})\neq0$. Тогда
редукция $h_{2}$ по $h_{1}$ с сохранением сигнатуры возможна если
и только если $h_{1}\GVWg h_{2}$.
\end{lem}
Следует из того что оба утверждения равносильны $\SIG(h_{2})\succ_{0}\SIG(h_{1})\frac{\HM(h_{2})}{\HM(h_{1})}$.
\begin{lem}
Пусть $h_{1}\in H$ -- результат редукции $h_{1}'$ с сохранением
сигнатур по некоторому многочлену. Тогда $h_{1}\GVWl h_{1}'$.
\end{lem}
Следует из $\SIG(h_{1})=\SIG(h_{1}')$ и уменьшения $\HM$ при редукции:
$\HM(h_{1})\prec_{0}\HM(h_{1}').$
\begin{lem}
\label{lem:greater-or-smaller}Пусть $h_{1}\GVWl h_{2}$ отмеченные
многочлены. Тогда $\forall h_{3}\in H\setminus\left\{ \left(0,0\right)\right\} $
выполняется хотя бы одно из двух неравенств: $h_{1}\GVWl h_{3}$ или
$h_{3}\GVWl h_{2}$.
\end{lem}
Из условия леммы известно, что
\begin{equation}
\HM(h_{1})\SIG(h_{2})\prec_{0}\HM(h_{2})\SIG(h_{1})\label{eq:gvw-order-3}
\end{equation}
откуда $\HM(h_{2})\neq0,\SIG(h_{1})\neq0$. Поэтому, если $\HM(h_{3})=0$,
имеем $h_{3}\GVWl h_{2}$, а если $\SIG(h_{3})=0$ -- то $h_{1}\GVWl h_{3}$.
Иначе можно домножить неравенство \eqref{eq:gvw-order-3} на ненулевой
элемент $\HM(h_{3})\SIG(h_{3})$: 
\begin{equation}
\HM(h_{3})\SIG(h_{3})\HM(h_{1})\SIG(h_{2})\prec_{0}\HM(h_{3})\SIG(h_{3})\HM(h_{2})\SIG(h_{1}).\label{eq:left-or-right-monom}
\end{equation}
Поэтому $\HM(h_{3})^{2}\SIG(h_{2})\SIG(h_{1})\in\mathbb{T}_{0}$ будет
или $\succ_{0}$ левой или $\prec_{0}$ правой части неравенства \eqref{eq:left-or-right-monom},
и после сокращения даст эквивалентное утверждению леммы неравенство.


\section{Алгоритм}
\begin{lyxlist}{00.00.0000}
\item [{Вход:}] многочлены $\{g_{1},\dots,g_{m}\}$, образующие базис Грёбнера;
многочлен $f$.
\item [{Переменные:}] $R$ и $B$ -- подмножества $H$; $(\sigma,p')\in H$
-- отмеченный многочлен текущего шага до редукции; $(\sigma,p)$ --
он же после редукции; $r,b$ -- элементы $R$ и $B$
\item [{Результат:}] базис Грёбнера идеала $I=\left(g_{1},\dots,g_{m},f\right)$
\end{lyxlist}

\paragraph*{\label{par:SimpleSignatureGroebner}SimpleSignatureGroebner$\left(\left\{ g_{1},\dots,g_{m}\right\} ,f\right)$}
\begin{enumerate}
\item $R\leftarrow\{\left(\HM(g_{1}),0\right),\left(\HM(g_{2}),0\right),\dots,\left(\HM(g_{m}),0\right),(0,g_{1}),(0,g_{2}),\dots,(0,g_{m})\}$
\item $B\leftarrow\{\}$
\item $(\sigma,p')\leftarrow(1,f)$
\item \textbf{do forever:}

\begin{enumerate}
\item \label{enu:-before-reduce}$p\leftarrow$ReduceCheckingSignatures($\sigma,p',R$)
\item \label{enu:-after-reduce}$R\leftarrow R\cup\left\{ \left(\sigma,p\right)\right\} $
\item \textbf{if} $p\not=0$\textbf{:}

\begin{enumerate}
\item \textbf{for $\{r\in R\,|\, r\GVWl\left(\sigma,p\right),\HM(r)\neq0\}$:}

\begin{enumerate}
\item $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(r)}r\}$
\end{enumerate}
\item \textbf{for }$\{r\in R\,|\, r\GVWg\left(\sigma,p\right)\}$\textbf{:}

\begin{enumerate}
\item $B\leftarrow B\cup\{\frac{\LCM(\HM(r),\HM(p))}{\HM(p)}\left(\sigma,p\right)\}$
\end{enumerate}
\end{enumerate}
\item \label{enu:-remove-from-B}$B\leftarrow B\setminus\{b\in B\,|\,\exists r\in R\, r\GVWl b\wedge\SIG(r)|\SIG(b)\}$
\item \textbf{if $B\neq\varnothing$: }$(\sigma,p')\leftarrow$ элемент
$B$ с $\prec$-минимальной сигнатурой
\item \textbf{else: break}
\end{enumerate}
\item \textbf{return} $\{\poly(r)\,|\, r\in R\}$
\end{enumerate}

\paragraph*{\label{par:ReduceCheckingSignatures:}ReduceCheckingSignatures$\left(\sigma,p,R\right)$}
\begin{enumerate}
\item \textbf{do while $\exists r\in R\, r\GVWg(\sigma,p)\wedge\HM(r)|\HM(p)$:}

\begin{enumerate}
\item $p\leftarrow$редуцировать $p$ с сохранением сигнатуры по $\GVWg$-максимальному
элементу $r$ среди указанных в условии цикла
\end{enumerate}
\item \textbf{return} $p$\end{enumerate}
\begin{lem}
Все пары из $\mathbb{T}_{0}\times P$ в алгоритме -- элементы $H\setminus\left\{ \left(0,0\right)\right\} $.
\end{lem}
Элементы, формируемые до начала главного цикла, являются рассмотренными
выше примерами отмеченных многочленов. Все остальные отмеченные многочлены
в алгоритме формируются или умножением на $t\in\mathbb{T}$ или редукцией
с сохранением сигнатуры, поэтому они корректны и лежат в $H$.

Условия циклов, расширяющих $B$, таковы, что в\textbf{ }$B$ нет
ни нулевых сигнатур, ни нулевых старших мономов. Поэтому $\sigma$
никогда не обращается в 0 и нулевые сигнатуры в $R$ лишь у элементов
$(0,g_{1}),...,(0,g_{m}).$ Нулевой старший моном может быть у любого
многочлена, добавляемого в $R$, а нулевых многочленов с одновременно
нулевой сигнатурой в $R$ нет.


\section{Остановка алгоритма}
\begin{lem}
\label{lem:exist-reductor}В любой момент работы алгоритма любой отмеченный
многочлен из $B$ может быть редуцирован с сохранением сигнатуры по
некоторому элементу $R.$
\end{lem}
Отмеченные многочлены добавляются в $B$ таким образом, чтобы иметь
хотя бы один подходящий редуктор. $(\sigma,p)\in R$ является таким
редуктором при добавлении в первом цикле \textbf{for}, $r\in R$ --
во втором.
\begin{lem}
\label{lem:r-gvw-small}До редукции многочлена $p'$, то есть на шаге
\ref{enu:-before-reduce} любой итерации алгоритма, сигнатуры элементов
$\left\{ r\in R\,|\, r\GVWl(\sigma,p')\right\} $ не делят $\sigma$.
\end{lem}
На первой итерации алгоритма это выполняется, поскольку $\sigma=1$
и $R$ не содержит элементы с сигнатурами, делящими 1. На последующих
итерациях это выполнено, поскольку если бы в $R$ существовали такие
элементы, то $\left(\sigma,p'\right)$ был бы убран из $B$ в предыдущей
итерации на шаге \ref{enu:-remove-from-B}.
\begin{lem}
\label{lem:r-gvw-big}После редукции многочлена $p'$ до $p$, на
шаге \ref{enu:-after-reduce} любой итерации алгоритма, старшие мономы
элементов $\left\{ r\in R\,|\, r\GVWg(\sigma,p)\right\} $ не делят
$\HM(p)$.
\end{lem}
Вытекает из того, что цикл в \nameref{par:ReduceCheckingSignatures:}
останавливается по достижении $p$, для которого такие элементы в
$R$ не существуют.
\begin{lem}
\label{lem:adds-really-new}После редукции многочлена $p'$ до $p$,
на шаге \ref{enu:-after-reduce} любой итерации алгоритма, элементы
$R$ не могут одновременно иметь старшие мономы, делящие $\HM(p)$,
и сигнатуры, делящие $\sigma$.
\end{lem}
В силу леммы \ref{lem:exist-reductor} будет произведена хотя бы одна
редукция $p'$, поэтому $(\sigma,p')\GVWg(\sigma,p)$. Отсюда по лемме
\ref{lem:greater-or-smaller} для $\forall r\in R$ имеем $r\GVWg(\sigma,p)$
или $r\GVWl(\sigma,p')$. Выполнение одного из неравенств позволяет
применить одну из лемм \ref{lem:r-gvw-small} и \ref{lem:r-gvw-big}.
\begin{thm}
Алгоритм \nameref{par:SimpleSignatureGroebner} останавливается
\end{thm}
Для доказательства остановки нужно показать, что все циклы \textbf{do}
выполняются лишь конечное число раз. В \nameref{par:ReduceCheckingSignatures:}
при ненулевых $p$ на каждой итерации $\HM(p)$ уменьшается по $\prec_{0}$,
что возможно лишь конечное число раз. При обнулении $p$ он завершится
в силу $\GVWl$-минимальности $(\sigma,0)$.

На каждом шаге основного цикла пополняется множество $R\subset\mathbb{T}_{0}\times P$.
Оно может быть разбито как $R_{*0}\cup R_{0*}\cup R_{**},$ где $R_{*0}\subset\mathbb{T}\times\left\{ 0\right\} ,R_{0*}\subset\left\{ 0\right\} \times P\setminus\left\{ 0\right\} ,R_{**}\subset\mathbb{T}\times P\setminus\left\{ 0\right\} $.
$R_{0*}$ не пополняется в силу $\sigma\neq0$. Для $R_{*0}$ и $R_{**}$
применим подход, основанный на понятии идеалов моноидов, предложенном
в \cite{KreuzerRobbianoBook1} как ``monoid ideal''. Рассмотрим следующие
множества, являющиеся идеалами моноидов: $L_{*0}=\left(\left\{ \sigma\,|\,(\sigma,0)\in R_{*0}\right\} \right)\subset\mathbb{T}$
и $L_{**}=\left(\left\{ (\sigma,t)\,|\,\exists(\sigma,p)\in R_{**}\, t=\HM(p)\right\} \right)\subset\mathbb{T}\times\mathbb{T}$.
В силу леммы \ref{lem:adds-really-new} добавляемые в $R$ элементы
расширяют на каждом шаге $L_{*0}$ или $L_{**}$. Поскольку моноиды
$\mathbb{T}$ и $\mathbb{T}\times\mathbb{T}$ изоморфны $\mathbb{N}^{n}$
и $\mathbb{N}^{2n}$, к их идеалам может быть применена лемма Диксона,
которая и утверждает, что расширение может происходить лишь конечное
число раз.


\section{Корректность результата}
\begin{defn}
\emph{S-представлением} $h\in H$ над множеством $\left\{ r_{i}\right\} \subset H$
будем называть выражение $\poly(h)=\sum_{j}K_{j}t_{j}\poly(r_{i_{j}}),$
$K_{j}\in k,t_{j}\in\mathbb{T},i_{j}\in\mathbb{N}$, такое что $\forall j\,\HM(h)\succcurlyeq_{0}\HM(t_{j}r_{i_{j}}),\SIG(h)\succcurlyeq_{0}\SIG(t_{j}r_{i_{j}})$.\end{defn}
\begin{lem}
\label{lem:one-j-exact}Пусть $\poly(h)=\sum_{j}K_{j}t_{j}\poly(r_{i_{j}})$
-- S-представление для $h$. Тогда для хотя бы одного $j$ достигается
$\HM(h)=\HM(t_{j}r_{i_{j}})$.
\end{lem}
В качестве такого $j$ можно взять то, на котором достигается $\succ$-максимум
$\HM(t_{j}r_{i_{j}})$.

Следующее определение расширяет понятие S-базиса из работы \cite{TheF5Revised}:
\begin{defn}
Назовём $R\subset H$\emph{ S-базисом} (соответственно \emph{S$_{\sigma}$-базисом}),
если все элементы$H$ (соответственно $\left\{ h\in H\,|\,\SIG(h)\prec_{0}\sigma\right\} $)\emph{
}имеют S-представление\emph{ }над $R$\emph{.}\end{defn}
\begin{lem}
\label{lem:s-basis-and-no-reductions}Пусть $\sigma\succ_{0}0,R=\left\{ r_{i}\right\} $
-- S\emph{$_{\sigma}$}-базис и выбраны $h_{1},h_{2}\in H,\SIG(h_{i})=\sigma$,
которые не редуцируются по $R$ с сохранением сигнатуры. Тогда $\HM(h_{1})=\HM(h_{2})$
и у $h_{1}$ есть S-представление над $R\cup\left\{ h_{2}\right\} $.
\end{lem}
Из определения $H$ имеем $\exists u_{i}\in P\,\HM(u_{i})=\sigma,u_{i}f\equiv\poly(h_{i})\pmod{I_{0}},i=1,2.$
Значит некоторой линейной комбинации $\poly(h_{i})$ сопоставляется
$\prec_{0}\sigma$ сигнатура: 
\[
\exists K\in k,v\in P\,\HM(v)=\sigma'\prec_{0}\sigma,vf\equiv\poly(h_{1})-K\poly(h_{2})\pmod{I_{0}},
\]
то есть $\left(\sigma',p'\right)=\left(\sigma',\poly(h_{1})-K\poly(h_{2})\right)\in H$.
Из определения S\emph{$_{\sigma}$}-базиса и $\sigma'\prec_{0}\sigma$
вытекает $\exists r_{j}\in R,t\in\mathbb{T}\,\SIG(tr_{j})\preccurlyeq_{0}\sigma',\HM(tr_{j})=\HM(p')$.
Отсюда $\HM(h_{i})\neq\HM(p'),i=1,2$, иначе $r_{j}$ редуцировало
бы $h_{i}$ с сохранением сигнатуры. Значит, $\HM(h_{i})$ сокращаются
при вычитании с $k$-коэффициентом, что даёт $\HM(h_{1})=\HM(h_{2})$.
S-представление $h_{1}$ получается добавлением $K\poly(h_{2})$ к
S-представлению $\left(\sigma',p'\right)$.
\begin{thm}
\label{thm:exist-r-sigma}На каждой итерации алгоритма после шага
\ref{enu:-remove-from-B} выполнен инвариант: для $\forall\sigma\in\mathbb{T},\sigma\prec$
сигнатур элементов $B$, найдутся $r_{\sigma}\in R,t_{\sigma}\in\mathbb{T}:\SIG(t_{\sigma}r_{\sigma})=\sigma$
и $t_{\sigma}r_{\sigma}$ не редуцируется по $R$ с сохранением сигнатуры.
\end{thm}
Множество $R_{\sigma}=\left\{ r\in R\,|\,\SIG(r)|\sigma\right\} $
непусто, так как содержит добавленный на первой итерации элемент $r_{0}$
с $\SIG(r_{0})=1$. Обозначим за $r_{\sigma}$ его $\GVWl$-минимальный
элемент; положим $t_{\sigma}=\frac{\sigma}{\SIG(r_{\sigma})}$. Предположим,
что $t_{\sigma}r_{\sigma}$ может быть редуцирован с сохранением сигнатуры
относительно некоторого $r_{1}\in R$. Отсюда следует, что $r_{1}\GVWg r_{\sigma}$,
а также что они не нулевые. Значит на той же итерации, когда в $R$
был добавлен последний из $\{r_{\sigma},r_{1}\}$, в множество $B$
был добавлен многочлен $t'r_{\sigma}$, где $t'=\frac{\LCM(\HM(r_{1}),\HM(r_{\sigma}))}{\HM(r_{\sigma})}$,
причём $t'|t_{\sigma}$. Отсюда $\SIG(t'r_{\sigma})|\SIG(t_{\sigma}r_{\sigma})=\sigma\Rightarrow\SIG(t'r_{\sigma})\preccurlyeq\sigma\prec$
сигнатур элементов $B$. В силу этого неравенства на сигнатуры получается,
что $t'r_{\sigma}$ уже не может быть элементом $B$, а значит был
выкинут на шаге \ref{enu:-remove-from-B} одной из итераций, то есть
$\exists r_{2}\in R\, r_{2}\GVWl t'r_{\sigma},\SIG(r_{2})|\SIG(t'r_{\sigma})$.
Это невозможно, поскольку влечёт $r_{2}\GVWl r_{\sigma},r_{2}\in R_{\sigma}$,
что противоречит $\GVWl$-минимальности $r_{\sigma}$.
\begin{thm}
\label{thm:has-s-repr}На каждой итерации алгоритма после шага \ref{enu:-remove-from-B}
выполнен инвариант: $\forall h\in H,\SIG(h)\prec$ сигнатур элементов
$B$, имеет S-представление над $R$.
\end{thm}
Предположим нарушение инварианта на какой-то итерации и рассмотрим
$\prec_{0}$-минимальную $\sigma$, для которой непусто $V_{\sigma}\eqdef\{h\in H\,|\, h\mbox{ нарушает инвариант},\SIG(h)=\sigma\}$.
Тогда $R$ -- S\emph{$_{\sigma}$}-базис. $\forall g\in I_{0}\,\left(0,g\right)$
имеют S-представления над $\{(0,g_{1}),...,(0,g_{m})\}\subset R$,
поэтому $\sigma\succ_{0}0$. Выберем $v_{\sigma}$ -- один из элементов
$V_{\sigma}$ с $\prec_{0}$-наименьшим $\HM$. Он не может быть редуцирован
с сохранением сигнатуры по $R$, поскольку результат редукции $v_{1}$
был бы элементом $V_{\sigma}$ с $\HM(v_{1})\prec_{0}\HM(v_{\sigma})$.
Возьмём $w_{\sigma}\eqdef t_{\sigma}r_{\sigma}$ из инварианта теоремы
\ref{thm:exist-r-sigma} и применим лемму \ref{lem:s-basis-and-no-reductions}
к $v_{\sigma},w_{\sigma}$ и $R$. Получим что $v_{\sigma}$ имеет
S-представление над $R\cup\{w_{\sigma}\}$. Вхождения $w_{\sigma}$
в нём можно заменить на $t_{\sigma}r_{\sigma}$, получив представление
$v_{\sigma}$ над $R$, что приводит к противоречию.
\begin{lem}
Если $R$ -- S-базис, то $\{\poly(r)\,|\, r\in R\}$ является базисом
Грёбнера идеала $I$.
\end{lem}
Для $\forall p\in I$ можно взять некоторый $h=\left(\sigma,p\right)\in H$
и применить лемму \ref{lem:one-j-exact}.
\begin{thm}
\nameref{par:SimpleSignatureGroebner} возвращает базис Грёбнера
\end{thm}
К моменту остановки $B=\varnothing$, значит по теореме \ref{thm:has-s-repr}
$R$ -- S-базис.


\subsection{Сравнение с аналогами}

Представленный алгоритм принадлежит к семейству алгоритмов вычисления
базисов Грёбнера, использующих сигнатуры, которые вычисляют S-базис
и в той или иной степени являются модификациями алгоритма F5 из \cite{FaugereF5}.
Одно из основных направлений его модификации -- упрощение теоретических
обоснований и расширение области применимости -- представлено в \cite{GermanF5Proof,ZobninGeneralization,F5InBBStyle}.
Другое -- повышение эффективности путём ввода дополнительных критериев
отбрасывания некоторых вычислений -- описывается в \cite{F5C,G2V,SignatureBasedGBs}
и позволяет проводить вычисления так, чтобы до конца редуцировались
лишь многочлены, являющиеся новыми элементами S-базиса или дающие
новую сигнатуру нулевого многочлена, расширяющую идеал моноида, содержащий
такие сигнатуры, называемые также \emph{сигнатурами сизигий.} Обобщение
с одновременным применением всех критериев в алгоритмах TRB-MJ и SB
\cite{HuangConception,PracticalGB} позволяет добиться большей эффективности
благодаря тому, что все отбрасывания применяются до проведения таких
вычислительно трудоёмких операций, как редукция многочлена или подсчёт
старшего монома S-пары, -- в результате не оказывается, что результаты
каких-то вычислений были отброшены.

Во всех упомянутых алгоритмах, включая немодифицированный F5, формулируется
два типа критериев отброса: критерии, связанные с сизигиями, и критерии
перезаписи, корректность каждого из которых доказывается независимо.
Также, даже в алгоритмах, не вычисляющих S-полиномы явно, теоретическое
обоснование корректности алгоритма на них опирается.

Данная работа описывает алгоритм вычисляющий минимальный S-базис и
осуществляющий отброс вычислений не менее эффективно, чем в TRB-MJ,
но использующий лишь единственный критерий отброса на шаге \ref{enu:-remove-from-B},
основанный на $\GVWl$-упорядочивании множества $R$. Вопрос наиболее
эффективного способа выбора редуктора в \nameref{par:ReduceCheckingSignatures:}
является открытым. Представленный в этой работе способ выбора основан
на всё том же упорядочении $R$ и совпадает для случая однородных
многочленов со способом выбора, применявшемся в алгоритме F5. Теоретическое
обоснование сформулировано без S-полиномов и позволяет применять к
нему простую алгебраическую интерпретацию из \cite{ZobninGeneralization}.

Упрощение формулировки алгоритма повлекло значительное уменьшение
времени на его реализацию и отладку на компьютере по сравнению с аналогами,
как за счёт меньшего количества множеств, так и за счёт общего для
критериев отбрасывания и процедуры редукции порядка. Простота реализации
и нетребовательность к структурам данных позволяет за небольшое время
внедрять эффективную версию алгоритма в любую систему компьютерной
алгебры. Реализация, упоминаемая ниже, была создана автором за 8 часов,
что на порядок меньше, чем время, затраченное автором на экспериментальные
реализации других алгоритмов в подобных условиях. Доказательство,
основанное на инвариантах в терминах S-представлений, позволило сделать
работу алгоритма более прозрачной с алгебраической точки зрения и
потенциально расширяемым на объекты, обобщающие кольцо многочленов
над полем.

Алгоритм был реализован на С++ с использованием функций ядра программного
комплекса Singular 3-1-4 и открытых наработок Кристиана Эдера (одного
из авторов \cite{SignatureBasedGBs}) по реализации F5-подобных алгоритмов
на этом ядре. Исходный код реализации содержится в функции ssg файла,
доступного по адресу \href{https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc}{https://github.com/galkinvv/Singular-f5-like/blob/ssg/kernel/kstd2.cc}

Сравнение реализации SimpleSignatureGroebner с другими алгоритмами
вычисления базисов Грёбнера, реализованных Кристианом Эдером подтвердили
следующие соображения:
\begin{itemize}
\item алгоритм SimpleSignatureGroebner корректно вычисляет базис Грёбнера;
\item результат содержит не большее число многочленов, чем результат других
инкрементальных алгоритмов, возвращающих S-базис;
\item время работы алгоритма оказывается не больше, чем у других инкрементальных
алгоритмов, основанных на сигнатурах.
\end{itemize}
\newpage{}\vestnikonly{
\spisoklit
\small\wrefdef{11}
\wref{1}{Faug\`{e}re J.-C.} A new efficient algorithm for computing Gr\"{o}bner bases without reduction to zero (F5) // Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2002. 75--83.

\wref{2}{Kreuzer M., Robbiano L.} Computational commutative algebra. 1 // Springer-Verlag. Berlin. 2000.

\wref{3}{Arri A., Perry J.} The F5 criterion revised // Journal of Symbolic Computation. 2011. {\bf46}, \No~9. 1017--1029.

\wref{4}{Герман О.} Доказательство критерия Фожера для алгоритма F5 // Математические заметки. 2010. {\bf88}, \No~4. 502--510.

\wref{5}{Зобнин А.} Обобщение алгоритма F5 вычисления базиса Грёбнера полиномиальных идеалов // Программирование. 2009. \No~2. 21--30.

\wref{6}{Sun, Y., Wang, D.} The F5 algorithm in Buchberger’s style // Journal of Systems Science and Complexity. 2011. {\bf24}, \No~6. 1218--1231. 

\wref{7}{Gao S., Guan Y., Volny F.} A new incremental algorithm for computing Gr\"{o}bner bases // Proceedings of the 2010 International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2010. 13--19.

\wref{8}{Eder C., Perry J.} Signature-based algorithms to compute Gr\"{o}bner bases // Proceedings of the 36th International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2011. 99--106.

\wref{9}{Eder C., Perry J.} F5C: A variant of Faug\`{e}re's F5 algorithm with reduced Gr\"{o}bner bases // Journal of Symbolic Computation. 2010. {\bf45}, \No~12. 1442--1458.

\wref{10}{Huang L.} A new conception for computing Gr\"{o}bner basis and its applications // депонировано: \href{http://arxiv.org/abs/1012.5425v2}{}.

\wref{11}{Roune B., Stillman M.} Practical Gr\"{o}bner basis computation // Proceedings of the 2012 International Symposium on Symbolic and Algebraic Computation. ACM. New York. 2012.

\lend
}%\vestnikonly
\novestnikonly{

\bibliographystyle{plain}
\bibliography{f5_references}


}%\novestnikonly
\end{document}
